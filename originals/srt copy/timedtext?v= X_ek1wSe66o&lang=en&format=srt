1
00:00:01,010 --> 00:00:01,859
>>Eric Bidelman: All right. Are we ready?
Android is processing my photo. Hold on.

2
00:00:01,859 --> 00:00:04,540
All right. Guys, I really want to thank you
for coming to my session. This is The Web

3
00:00:04,540 --> 00:00:07,410
Can Do That, in case you've misplaced what
session you should be in.

4
00:00:07,410 --> 00:00:11,460
Apparently none of you want to get free Android
hardware downstairs, so I do really appreciate

5
00:00:11,460 --> 00:00:17,820
your time for the next hour.
This is going to be adventures into HTML5.

6
00:00:17,820 --> 00:00:20,730
Just so you know who you're talking to up
here, my name is Eric Bidelman and I work

7
00:00:20,730 --> 00:00:27,730
on the Google Chrome team. I'm an advocate
for Chrome team, I teach developers HTML5,

8
00:00:28,180 --> 00:00:33,159
help them use it by writing tutorials. Of
course, if you want to contact me there's

9
00:00:33,159 --> 00:00:37,600
Google+, there's the Twitter and there's also
a blog that I don't write to very often, but

10
00:00:37,600 --> 00:00:43,600
it does have some interesting things I think
on it. So that's who is up on stage.

11
00:00:43,600 --> 00:00:50,530
I get this a lot. People are really skeptical
about HTML5 still and so they don't know what's

12
00:00:50,530 --> 00:00:54,839
possible. And so part of my job is to come
up here and teach you guys and you too, the

13
00:00:54,839 --> 00:00:59,909
folks at home, what is possible on the Web.
So today's talk is that the agenda is there's

14
00:00:59,909 --> 00:01:04,140
going to be no agenda whatsoever.
So I'm going to sort of highlight really cool,

15
00:01:04,140 --> 00:01:08,190
interesting use cases that HTML5 can now solve
that you probably didn't know were possible

16
00:01:08,190 --> 00:01:12,230
on the Web today.
Things that you probably need to build a real

17
00:01:12,230 --> 00:01:18,940
world application on the Web.
So a little bit of convention about this slide

18
00:01:18,940 --> 00:01:22,050
deck. This is a living, breathing slide deck.
I'm doing something a little bit different

19
00:01:22,050 --> 00:01:26,620
with this. You will see in the top right corner
there's a legend and there's a radar, and

20
00:01:26,620 --> 00:01:30,340
that signifies that stuff is on the radar.
Keep it on your radar, it's still pretty new,

21
00:01:30,340 --> 00:01:36,370
it's changing quickly. I can actually make
CORs requests, cross origin resource requests,

22
00:01:36,370 --> 00:01:40,440
[indiscernible] XHRs, to the WebKit issue
tractor, which is really nice. So as soon

23
00:01:40,440 --> 00:01:44,440
as a bug is fixed, I know it's fixed, I can
mark them, denote it with this little bug

24
00:01:44,440 --> 00:01:48,820
guy as it gets crossed off. So you kind of
know when you go back to this slide at greater@html5.com.

25
00:01:48,820 --> 00:01:55,580
It's not up right now. I'll post it after
the slides. But there are spec links and you

26
00:01:55,580 --> 00:02:01,159
know the stuff is up to date.
Okay. So without further adieu let's jump

27
00:02:01,159 --> 00:02:05,550
into the number one main awesome, sweet thing
that the Web can do. The first is that we

28
00:02:05,550 --> 00:02:10,369
have CSS for Web apps. And you're probably
like whoa -- yeah, Mythbuster style. You're

29
00:02:10,369 --> 00:02:14,870
probably like, whoa, Eric, we've had CSS for
a long time. What's up with that? Well, we

30
00:02:14,870 --> 00:02:18,959
have. We had a lot of great stuff in CSS.
We have floats and absolute positioning and

31
00:02:18,959 --> 00:02:23,269
tables and all this stuff kind of working
together. The real problem with that is it

32
00:02:23,269 --> 00:02:27,950
was all designed in times of websites, not
Web apps. So if you want to do complex Web

33
00:02:27,950 --> 00:02:34,870
layout it's really, really hard until now.
So I'm calling 2012 sort of the rise of CSS

34
00:02:34,870 --> 00:02:39,180
for Web apps, and that's because the working
groups have proposed a number, a slew of new

35
00:02:39,180 --> 00:02:43,909
stuff that we can play with eventually as
Web developers. Regions for things like flowing

36
00:02:43,909 --> 00:02:48,959
and magazine type layout and design. Flexbox
layout, which I will talk about, it's one

37
00:02:48,959 --> 00:02:53,239
of my particular favorites, being able to
easily position things on the page in a flexible

38
00:02:53,239 --> 00:02:56,629
manner.
Grid layouts and hierarchies in ASCII and

39
00:02:56,629 --> 00:03:00,749
CSS so you can define where things show up
on a page. It makes sense. If you're building

40
00:03:00,749 --> 00:03:06,739
something on top of CSS you need engines and
different mechanisms to do that for Web apps.

41
00:03:06,739 --> 00:03:09,769
And then there's the bells and whistles, there's
the hierarchies, there's the folders and effects

42
00:03:09,769 --> 00:03:13,090
and other really cool stuff coming down the
pipeline.

43
00:03:13,090 --> 00:03:17,540
CSS variables. If you guys attended the Web
component session earlier, that stuff is finally

44
00:03:17,540 --> 00:03:22,719
coming to CSS. You can finally use variables
in CSS. It's not that exciting, but it's super

45
00:03:22,719 --> 00:03:28,930
exciting as a Web developer that you don't
have to use a Web processor anymore.

46
00:03:28,930 --> 00:03:34,319
So why am I picking on Flexbox out of all
this new stuff? Flexbox is really great for

47
00:03:34,319 --> 00:03:39,079
Web layout design and it's really going to
solve and is solving the sort of common use

48
00:03:39,079 --> 00:03:44,370
cases of a Web app. So that Holy Grail layout,
that header, that footer, that three-column

49
00:03:44,370 --> 00:03:50,230
tiered system, very hard to do with, notoriously
hard to do with CSS today. Very easy with

50
00:03:50,230 --> 00:03:54,419
Flexbox.
And so the way Flexbox works is that there's

51
00:03:54,419 --> 00:03:59,579
a new display property. So I can tell a container
to be a Flexbox container and I'm doing also

52
00:03:59,579 --> 00:04:03,309
something in this slide deck, nobody is going
to catch me on vendor prefixes. I'm using

53
00:04:03,309 --> 00:04:09,749
sort of a compile type syntax, a mix-in syntax
to denote that any time you see a + for CSS

54
00:04:09,749 --> 00:04:14,919
that means vendor prefixes are involved.
I can tell, for instance, this right container

55
00:04:14,919 --> 00:04:21,260
to be a Flexbox container with display vendor
prefix flex. And we can do things like center

56
00:04:21,260 --> 00:04:25,360
content horizontally and vertically super
easy. With three lines of CSS we can do this

57
00:04:25,360 --> 00:04:30,250
now. We don't have to use negative margins
or JavaScript. So along my main access here

58
00:04:30,250 --> 00:04:35,100
-- this is a little bit of Flexbox terminology.
In my cross origin access, I can justify content

59
00:04:35,100 --> 00:04:39,750
to the center, I can flex it to the start,
I can say everything be adjusted far to the

60
00:04:39,750 --> 00:04:44,310
right. And I can also align those items in
that cross access, so I can align items to

61
00:04:44,310 --> 00:04:49,150
the center, I can allow them to the bottom.
I can do things like stretch to take up the

62
00:04:49,150 --> 00:04:53,340
available content of your parent container.
Very, very handy with layout.

63
00:04:53,340 --> 00:04:57,720
And I can do also things like distribute yourself
evenly in a container. Take up the available

64
00:04:57,720 --> 00:05:04,720
space and put an even distribution of white
space around yourself.

65
00:05:06,030 --> 00:05:09,820
Another cool thing about Flexbox is that it
completely takes away the sort of mapping

66
00:05:09,820 --> 00:05:14,030
of your source to how things are rendered
on the page. So typically what happens is

67
00:05:14,030 --> 00:05:19,460
that you define your A, your B and your C
div. These are just three divs inside of this

68
00:05:19,460 --> 00:05:23,170
flex container. And that's how I've weighted
out my markups, right? I have an A, B and

69
00:05:23,170 --> 00:05:27,250
C in my markup. But maybe I don't want to
render A, B and C in that order, and I can

70
00:05:27,250 --> 00:05:31,780
do that through different properties of Flexbox.
I have this flex direction property, so again

71
00:05:31,780 --> 00:05:37,000
vendor prefix. So right now we're flexing
in a row, but I can choose to change the order

72
00:05:37,000 --> 00:05:42,500
of that row. I can reverse the order of the
row using row reverse. I can tell these items

73
00:05:42,500 --> 00:05:48,470
to be in a column so A, B and C are not in
a row now, but they can be rendered in a column.

74
00:05:48,470 --> 00:05:52,180
And then using the order property I can sort
of change the order depending on what value

75
00:05:52,180 --> 00:05:56,280
I set here. So by default these are all the
same order as they're laid out in markup,

76
00:05:56,280 --> 00:06:02,220
but I can tell the second div to come before
A. So this is independent of how I've got

77
00:06:02,220 --> 00:06:06,230
my markup out, just rendering it different
next to the page using the orientation and

78
00:06:06,230 --> 00:06:12,210
direction properties of Flexbox.
I can also tell it to come after everything

79
00:06:12,210 --> 00:06:15,550
as well.
But another really cool thing that Flexbox

80
00:06:15,550 --> 00:06:20,380
solves is sort of this type of use case where
you have the same height columns. So in order

81
00:06:20,380 --> 00:06:24,780
to do same height columns -- this is a great
example of floating three divs across the

82
00:06:24,780 --> 00:06:29,030
page. But if I want to do something like make
these even, right, I have a really awesome

83
00:06:29,030 --> 00:06:34,030
UI, I can do that with a little bit of JavaScript
where I can set these and get the computed

84
00:06:34,030 --> 00:06:38,340
style of the content and know exactly how
tall they should be.

85
00:06:38,340 --> 00:06:43,620
But what happens if my UI is being rendered
through JSON, I'm porting in an RSS feed or

86
00:06:43,620 --> 00:06:49,530
something, and -- my content is dynamic. As
soon as that happens, I put a little bit more

87
00:06:49,530 --> 00:06:53,000
content, my columns are now out of sync, I
have to recalculate, I have to touch JavaScript,

88
00:06:53,000 --> 00:06:58,970
I have to set properties in CSS. It just feels
super, super icky.

89
00:06:58,970 --> 00:07:04,050
So the way Flexbox solves that is through
its bread and butter, flexibility. So it's

90
00:07:04,050 --> 00:07:08,680
really nice. I can tell things to take up
the available amount of the parent container.

91
00:07:08,680 --> 00:07:13,640
In this case all of these items, A, B, and
C, are equally distributed in the Flexbox

92
00:07:13,640 --> 00:07:17,950
container. But I don't have to do that. I
can tell the second difference to be two times

93
00:07:17,950 --> 00:07:22,740
greater, grow to be two times as big as your
siblings or three times as big or four times

94
00:07:22,740 --> 00:07:26,580
as big.
I can also tell it to shrink. So A and C will

95
00:07:26,580 --> 00:07:31,610
be equal size with a flex property of one
and then B is going to be a negative flex

96
00:07:31,610 --> 00:07:34,990
property.
So it's really handy when it comes to that

97
00:07:34,990 --> 00:07:38,150
Holy Grail layout.
So I want to show you an example of this.

98
00:07:38,150 --> 00:07:43,140
This is a live page. Think of this as that
Holy Grail layout, that header, footer, that

99
00:07:43,140 --> 00:07:46,120
three column in the center.
The first thing you will notice is this whole

100
00:07:46,120 --> 00:07:50,900
thing, maybe not the resolution, but the whole
thing is centered vertically and horizontally

101
00:07:50,900 --> 00:07:55,190
in my page with three lines of CSS, right,
the alignment and justification there.

102
00:07:55,190 --> 00:08:01,250
Next thing to happen on this page is a really
sweet navigation bar. You will notice that

103
00:08:01,250 --> 00:08:05,940
that last button up there has more content
than the rest of my buttons, but that's okay.

104
00:08:05,940 --> 00:08:10,530
We can tell the Flexbox items to grow and
shrink. So all my buttons are exactly the

105
00:08:10,530 --> 00:08:15,760
same size. I didn't set anything in CSS, particularly
the widths of those buttons, it's just flexing

106
00:08:15,760 --> 00:08:20,740
to take up the available space of that complete
Web app. But if I add more, all of these buttons

107
00:08:20,740 --> 00:08:24,620
will continue to flex and be of equal weight
and size and distributed evenly. It's great

108
00:08:24,620 --> 00:08:31,410
for navigation, it's great for UI.
We can also use some CSS transitions on the

109
00:08:31,410 --> 00:08:36,010
flex property so I can do really cool UI flex
here, little zippies here, so these are just

110
00:08:36,010 --> 00:08:42,190
Flexbox items within a Flexbox container with
the column orientation. And with the CSS hover

111
00:08:42,190 --> 00:08:45,450
I can tell them to grow with the flex property
to grow to be two times or three times greater

112
00:08:45,450 --> 00:08:50,000
than rest.
My center content in the center of the article

113
00:08:50,000 --> 00:08:54,060
content I can use transforms to do things
with vertical alignment there on the side,

114
00:08:54,060 --> 00:08:58,950
my navigation on my side.
If I wanted to I could combine the media queries,

115
00:08:58,950 --> 00:09:03,430
and you remember I could independently order
my source and how things are presented using

116
00:09:03,430 --> 00:09:09,270
that order property. So that combined media
source may be in my mobile UI. I have something

117
00:09:09,270 --> 00:09:14,110
that is different. If I scale this down to
mobile UI, notice in the case of my desktop,

118
00:09:14,110 --> 00:09:18,310
the article is in the center. That's my main
content, that's what users should be seeing,

119
00:09:18,310 --> 00:09:22,760
but when I scale on to mobile maybe the articles
should come before that navigation element,

120
00:09:22,760 --> 00:09:27,450
that zippy on the side. So I can do that with
that ordering orientation property, very handy

121
00:09:27,450 --> 00:09:34,450
when combined with media queries.
So that's CSS Flexbox. And that's the new

122
00:09:38,460 --> 00:09:42,650
one. There is an older Flexbox if you've been
following this stuff closely.

123
00:09:42,650 --> 00:09:45,540
That's actually available in a number of browsers
right now. So WebKit, Chrome.

124
00:09:45,540 --> 00:09:50,590
IE 10 will have the new Flexbox as well. So
you can expect to use this relatively soon.

125
00:09:50,590 --> 00:09:57,590
All right. Number two amazing thing is dynamic
CSS. By dynamic CSS I actually mean -- that

126
00:09:58,050 --> 00:10:01,970
was confirmed too.
I actually mean the calc function. If you

127
00:10:01,970 --> 00:10:05,930
attended the session earlier today on Web
components, they have CSS variables coming.

128
00:10:05,930 --> 00:10:10,589
But we actually have the ability to do similar
things now with the calc function. It's been

129
00:10:10,589 --> 00:10:14,529
around in Firefox for a long time, just came
to WebKit very recently.

130
00:10:14,529 --> 00:10:19,870
What I have here is a live example of something
that's in the Flexbox specification. So I

131
00:10:19,870 --> 00:10:24,620
basically have a bunch of divs. I have a div
within a div within a div, and I put a border

132
00:10:24,620 --> 00:10:29,800
radius of 50% on this div, so that's what's
creating the circles.

133
00:10:29,800 --> 00:10:35,110
I've specified the parent circle container
to be 300 wide and 300 tall. What's really

134
00:10:35,110 --> 00:10:41,610
nice about this is I can use the CSS calc
function, so again vendor prefix, to calculate

135
00:10:41,610 --> 00:10:47,540
each of these inner divs to be 100% minus
4 EM. Each of these children divs is 4 EM

136
00:10:47,540 --> 00:10:52,960
smaller than its parent container and that's
producing sort of this target effect.

137
00:10:52,960 --> 00:10:56,339
What's really neat about this is you combine
it with what we just talked about, which is

138
00:10:56,339 --> 00:11:00,029
Flexbox, and so that's what's doing the alignment
of the center and justifying the content to

139
00:11:00,029 --> 00:11:03,890
the center. So that vertical center, that
horizontal center with three lines of CSS

140
00:11:03,890 --> 00:11:06,930
now, combined with the calc function you can
do something like this, which you haven't

141
00:11:06,930 --> 00:11:10,260
been able to do before without a little bit
of JavaScript.

142
00:11:10,260 --> 00:11:15,839
Really awesome. This stuff now can work together
really easily with a lot of new CSS stuff.

143
00:11:15,839 --> 00:11:21,390
And support is actually really good for this
as you can see by this slide.

144
00:11:21,390 --> 00:11:24,089
So that's what's happening with CSS.
Number three amazing, awesome thing that the

145
00:11:24,089 --> 00:11:31,089
Web can do is data binding. And you're like
what? The web can't do data binding. Oh, but

146
00:11:31,860 --> 00:11:35,720
it can.
This is actually old hat for JavaScript frameworks.

147
00:11:35,720 --> 00:11:41,980
If you use your framework like Angular JS,
for example, one of my favorites at the moment,

148
00:11:41,980 --> 00:11:46,589
data binding looks like this. This is how
they define a template in Angular. It's just

149
00:11:46,589 --> 00:11:51,250
HTML, which is really, really nice. I don't
have to learn a new API or markup.

150
00:11:51,250 --> 00:11:57,250
If I want to do one-way data binding I can
have an input, I can change the input, and

151
00:11:57,250 --> 00:12:01,440
as I change that my template is being re-rendered.
I'm just re-rendering the value of the input

152
00:12:01,440 --> 00:12:06,880
as it changes. And that's done through sort
of Angular's magic. My model in this case

153
00:12:06,880 --> 00:12:11,680
is this val. That's what I'm calling the model.
And as I change the input, val is being re-rendered

154
00:12:11,680 --> 00:12:15,960
to the template.
So that's one-way data binding use a JavaScript

155
00:12:15,960 --> 00:12:20,870
framework. But we can actually do a neat little
trick that I kind of discovered, which I'm

156
00:12:20,870 --> 00:12:25,029
calling it poor man's data binding, and it's
using data attributes, HTML data attributes.

157
00:12:25,029 --> 00:12:29,670
So we don't need a framework to do one-way
data binding. So the way this works is that

158
00:12:29,670 --> 00:12:33,160
you have a data attribute. That's your data
model. That's where you're going to be storing

159
00:12:33,160 --> 00:12:36,589
your values.
And then a lot of people don't know, but there's

160
00:12:36,589 --> 00:12:41,880
this really awesome, amazing attribute that
you can use to pull out values from the DOM

161
00:12:41,880 --> 00:12:45,860
and use those values in CSS.
So that's how we'll get the data from the

162
00:12:45,860 --> 00:12:50,600
data model. Then our view from this case,
what we're rendering this data to, is generated

163
00:12:50,600 --> 00:12:56,480
content. So before and after pseudo elements
and generating that model to those elements.

164
00:12:56,480 --> 00:12:59,779
And so we don't have a JavaScript framework
to work for us in this case so we have to

165
00:12:59,779 --> 00:13:05,990
actually hook up Web event listeners to do
this and watch for the changes.

166
00:13:05,990 --> 00:13:09,920
So what you get back with the poor man's data
binding is exactly the same thing. So I can

167
00:13:09,920 --> 00:13:15,330
have an input, and as I change that input,
I can re-render that to my template, my pseudo

168
00:13:15,330 --> 00:13:20,860
elements, on the fly.
So a small amount of code to do this. I set

169
00:13:20,860 --> 00:13:25,800
up an event change event on my input. And
then as that input changes, the user changes

170
00:13:25,800 --> 00:13:30,960
it, I'm sending a data attribute using the
data set object. So data-values is my thing

171
00:13:30,960 --> 00:13:36,290
that I'm changing to the new value. And the
really cool part of this is that I'm using

172
00:13:36,290 --> 00:13:40,149
before and after pseudo selectors for this.
So I'm using that attribute method to rip

173
00:13:40,149 --> 00:13:45,010
out that data element, that data attribute,
from the DOM, dividing it by the max attribute,

174
00:13:45,010 --> 00:13:48,520
in this case 100.
So you get the exact same thing as the Angular

175
00:13:48,520 --> 00:13:53,339
JS case. I don't need a framework to do the
-- this type of one-way data binding.

176
00:13:53,339 --> 00:13:58,529
You can do the exact same thing with an extra
span or DOM node and just render the inner

177
00:13:58,529 --> 00:14:02,760
text of that. That's cool. This is a little
cooler in my opinion and it illustrates that

178
00:14:02,760 --> 00:14:07,420
we can do this now in HTML5.
But we can also use something better, which

179
00:14:07,420 --> 00:14:11,750
is the dataless element, something new to
WebKit, and Opera has had this for a slew

180
00:14:11,750 --> 00:14:16,959
of time. This is sort of a semantic way to
do one-way data binding. So in this case your

181
00:14:16,959 --> 00:14:20,930
data model is actually defined in markup.
You have data list element, you can reference

182
00:14:20,930 --> 00:14:26,709
it by an ID, so the browser's out, and each
option is sort of the values of this data

183
00:14:26,709 --> 00:14:29,529
list.
And what we bind to in this case is an input

184
00:14:29,529 --> 00:14:34,779
element, so we reference it by the list attribute
of ID and so we're finding this data list

185
00:14:34,779 --> 00:14:39,730
-- these values to this input element. So
it's a great way to do things like auto complete.

186
00:14:39,730 --> 00:14:44,480
So I have an example of that in here. I have
the list of browsers. When I click on this

187
00:14:44,480 --> 00:14:48,760
I get the values from that data list. We bound
that data to this input.

188
00:14:48,760 --> 00:14:55,760
If I do things like -- if I start typing,
just as you expect I have auto complete behavior.

189
00:14:56,570 --> 00:15:01,170
That's super handy. That's the HTML5 way to
do one-way data binding. You actually saw

190
00:15:01,170 --> 00:15:07,709
it in that blue column example, you saw me
use this data attribute trick as well to render

191
00:15:07,709 --> 00:15:11,850
out the heights of those columns as they were
changing when I clicked on them. And both

192
00:15:11,850 --> 00:15:15,310
of these methods for data binding are actually
all supported on all the bottom browsers,

193
00:15:15,310 --> 00:15:18,730
which is really, really sweet. But if you're
doing something simple like I just showed

194
00:15:18,730 --> 00:15:23,410
you, you can do one-way data binding just
with HTML, just on the Web.

195
00:15:23,410 --> 00:15:27,480
How many people think HTML can access a file
system?

196
00:15:27,480 --> 00:15:33,470
It's hard to see up here, we have some believers.
We have a lot of naysayers.

197
00:15:33,470 --> 00:15:38,610
It's cool. This one is totally confirmed.
It's confirmed because I got really excited

198
00:15:38,610 --> 00:15:41,060
about this one. I got so excited that I wrote
a book.

199
00:15:41,060 --> 00:15:44,649
[Laughter]
>>Eric Bidelman: Shameless plug, I know.

200
00:15:44,649 --> 00:15:49,550
What we have now in HTML5 is a file system
API. This is something that you can do very

201
00:15:49,550 --> 00:15:55,899
easily in a native app. You can read and write
folders and persist data. That's very common.

202
00:15:55,899 --> 00:15:59,430
We should be able to do this on the Web as
well and we can do that with the file system

203
00:15:59,430 --> 00:16:03,670
API.
So there's a new property on the window method

204
00:16:03,670 --> 00:16:08,950
called request file system, and this is vendor
prefixes alluded to by this underline here.

205
00:16:08,950 --> 00:16:13,040
You can open the file system and read and
write files and folders. That's really huge.

206
00:16:13,040 --> 00:16:18,420
The security behind this is exactly like the
other offline storage API. So it's on a per-origin

207
00:16:18,420 --> 00:16:23,209
basis. You can't read and write to somebody
else's Web app and you certainly can't come

208
00:16:23,209 --> 00:16:27,390
out of the browser and write to somebody's
My Pictures folder or the system's My Documents

209
00:16:27,390 --> 00:16:32,730
folder. It's all on a per-origin for your
Web app. But it's super powerful. And the

210
00:16:32,730 --> 00:16:38,570
real benefit of this is to get around issues
that something like App Cache does. So if

211
00:16:38,570 --> 00:16:41,839
you've used App Cache, it's kind of clunky,
it's hard to use. With the file system API

212
00:16:41,839 --> 00:16:46,440
we can easily and dynamically cache individual
files and folders very quickly. Store them

213
00:16:46,440 --> 00:16:50,600
in folders, arrange them in a hierarchy, nuke
that if we need to.

214
00:16:50,600 --> 00:16:55,580
So as a quick example of caching an image
file, for instance, just a png file, we're

215
00:16:55,580 --> 00:17:01,209
going to use a friend, XMLhtpp request, pull
that guy down, and we're not pulling it as

216
00:17:01,209 --> 00:17:04,640
a streamer, but we're pulling it as an array
buffer, so we'll set the response type and

217
00:17:04,640 --> 00:17:08,819
we're just going to get a raw byte array back
from that image.

218
00:17:08,819 --> 00:17:13,370
And we get the response and we'll open the
file system using WebKit file request file

219
00:17:13,370 --> 00:17:20,370
system, give it a store, so maybe we'll store
a megabyte worth of data in this. We'll use

220
00:17:20,380 --> 00:17:26,699
the file system's root directory, just the
root entry of my file system, and we'll call

221
00:17:26,699 --> 00:17:32,970
it image.png, we'll create it if it doesn't
exist using this param here. We'll get back

222
00:17:32,970 --> 00:17:37,580
a file entry, we'll then write that response
of the XHR out to the file system and save

223
00:17:37,580 --> 00:17:42,710
that data. So this is just creating a file
writer object. We can set up events for when

224
00:17:42,710 --> 00:17:46,950
the write has ended, if there's any errors
that happened. And the important part is this

225
00:17:46,950 --> 00:17:51,880
guy right here, this writer.write. We're gonna
write out that data, the response of the XHR,

226
00:17:51,880 --> 00:17:55,410
create a new blog from the response and that's
going to be saved. The image is gonna be saved

227
00:17:55,410 --> 00:17:59,380
locally to our Web app and we can use that
as if it were a local resource to our Web

228
00:17:59,380 --> 00:18:06,380
app.
So that's the final product. You can see there's

229
00:18:06,730 --> 00:18:11,679
a lot of callbacks that are involved here.
I have at least one, two, three, four -- four

230
00:18:11,679 --> 00:18:17,110
to five levels of sort of callback -- callback
spaghetti that's happening here. Callbacks

231
00:18:17,110 --> 00:18:23,700
are hard. People don't like to deal with them.
This is a famous quote that I just said.

232
00:18:23,700 --> 00:18:24,440
[Laughter]
>>Eric Bidelman: Actually, I wanted to make

233
00:18:24,440 --> 00:18:29,240
it simpler for developers. Again, I'm really
passionate about this API. It's very powerful.

234
00:18:29,240 --> 00:18:34,140
So I wrote this library called filer.js. You
can check out the GitHub URL there. But essentially

235
00:18:34,140 --> 00:18:39,880
what it is is a library that wraps common
UNIX commands on top of the file system API

236
00:18:39,880 --> 00:18:44,400
calls. So we have things like LS and CD and
copy and the things that you know from interface

237
00:18:44,400 --> 00:18:51,350
that make it super easy to use this API.
If I want to copy a file, for instance, filer.copy,

238
00:18:51,350 --> 00:18:57,000
the file path you want to copy to and then
renaming it as well. So super handy.

239
00:18:57,000 --> 00:18:59,410
It makes the whole thing much more approachable
if you're familiar with this sort of development.

240
00:18:59,410 --> 00:19:06,410
Let's see a demo of this guy. So this is called
the file system API playground. Essentially

241
00:19:12,220 --> 00:19:16,790
what this is is a Web app that sits on top
of the file system API. So right now I don't

242
00:19:16,790 --> 00:19:21,450
have anything in this guy, but you can easily
use HTML5 Dragon drop to add some files, boom,

243
00:19:21,450 --> 00:19:27,760
I can add some text files. I can open these
files, right, so there's this sort of notion

244
00:19:27,760 --> 00:19:33,490
of using this -- this resource locally with
referencing it via URL. Can use that within

245
00:19:33,490 --> 00:19:38,370
my Web app. Can also read this file and preview
it if I wanted to using the file reader API,

246
00:19:38,370 --> 00:19:44,040
and get some metadata such as the date and
last modified times. Can use filer.js and

247
00:19:44,040 --> 00:19:49,370
API to rename the file. The best part about
this is I've actually cached these resources,

248
00:19:49,370 --> 00:19:54,049
so if I refresh this page, my Web app, right,
has those values and those resources saved

249
00:19:54,049 --> 00:19:59,710
in them, so all the changes I made are being
persisted, which is really awesome. Can create

250
00:19:59,710 --> 00:20:06,710
files and folders. Create a folder using the
API. You can drill into it. Import some data

251
00:20:07,490 --> 00:20:12,799
here. Luckily it's after lunch so, you guys
don't have to get too hungry. But this is

252
00:20:12,799 --> 00:20:15,100
really great.
I mean, this is native stuff, but it's on

253
00:20:15,100 --> 00:20:22,100
the Web. We can write and read files and folders
now using the file system API. So you're probably

254
00:20:23,990 --> 00:20:28,140
asking yourself this: This is great, but if
it's only in Chrome, like why am I going to

255
00:20:28,140 --> 00:20:34,280
use it?
Then I'm like, oh, yeah. So again, I really

256
00:20:34,280 --> 00:20:39,030
like this API, you guys, so I decided to implement
a polyfill stream library that sits on top

257
00:20:39,030 --> 00:20:43,640
of index DB that then you can use in your
Web app to have basically the file system

258
00:20:43,640 --> 00:20:48,730
API in browsers that support index DB. So
same Web app, right? Same Web app running

259
00:20:48,730 --> 00:20:55,730
in Chrome is running in FireFox. And I can
add files and folders to this guy, maybe -- it's

260
00:20:56,200 --> 00:21:03,200
a nightly build, so I don't know -- there
we go. And if I refresh this up, those files

261
00:21:03,630 --> 00:21:10,630
that I just wrote to the Web app are preserved.
So that library is called IDBfilesystem.js.

262
00:21:12,510 --> 00:21:17,540
And if you're interested in this API, the
file system API, check it out, it basically

263
00:21:17,540 --> 00:21:22,290
means that we can now use this API in a relatively
performant way in the browsers that do support

264
00:21:22,290 --> 00:21:27,360
index DB. Super Stoked about it. Hope you
guys get Stoked about it, too. Files and folders,

265
00:21:27,360 --> 00:21:34,360
the Web can do that. All right, Number 5.
This one looks suspicious. Totally is busted.

266
00:21:34,620 --> 00:21:38,309
Just making sure you guys are paying attention.
[ Laughter ]

267
00:21:38,309 --> 00:21:44,640
>>Eric Bidleman: The real Number 5 is serverless
downloads. So we got data in the file system,

268
00:21:44,640 --> 00:21:50,830
we're storing data in our Web app -- where
is my clicker?

269
00:21:50,830 --> 00:21:54,440
What happens when you want to get data back
out of your Web app, right?

270
00:21:54,440 --> 00:21:59,910
So for a long time, if you wanted to download
a file and trick the browser into downloading

271
00:21:59,910 --> 00:22:03,010
a file from the response of your server, you
would have had to do something like this:

272
00:22:03,010 --> 00:22:07,929
You would send a content disposition header
as an attachment, give it a file name, and

273
00:22:07,929 --> 00:22:11,790
essentially what this did was when the browser
hit this response, the browser would sort

274
00:22:11,790 --> 00:22:15,900
of -- it would trick it into downloading a
file and it would invoke the browser's download

275
00:22:15,900 --> 00:22:21,860
manager. What we have now is a lot of people
are writing thick clients, right? Maybe there's

276
00:22:21,860 --> 00:22:24,220
no server involved whatsoever, so how do you
do this?

277
00:22:24,220 --> 00:22:28,790
How do you send a header if you don't have
a server? It's impossible. So smart folks

278
00:22:28,790 --> 00:22:32,520
in the Web community were like, hey, we can
solve this, we've got this great idea, let's

279
00:22:32,520 --> 00:22:36,590
make an attribute, we'll call it "download".
That makes a lot of sense. And what download

280
00:22:36,590 --> 00:22:42,830
does is you can use with an anchor tag for
instance, and so what happens is -- normally

281
00:22:42,830 --> 00:22:48,320
what happens is if you -- if a user clicks
on this H ref to this logo.png, what happens

282
00:22:48,320 --> 00:22:53,309
is the browser will open that image in a new
tab and you can view the image. That's cool.

283
00:22:53,309 --> 00:22:57,120
But what happens if you have download specified,
this attribute, and you can give it the name

284
00:22:57,120 --> 00:23:00,250
of the file you want to download as, is that
it's going to trick the browser into doing

285
00:23:00,250 --> 00:23:04,200
the exact same thing as the content disposition
header, and then you can download that file

286
00:23:04,200 --> 00:23:11,070
instead of navigating to that resource. So
if none of that makes any sense to you, I

287
00:23:11,070 --> 00:23:17,950
have an epic novel creator here, and this
is just a text area that I'm typing into,

288
00:23:17,950 --> 00:23:24,950
so let me bring this up a little bit. So just
to show you that I'm typing live. I'm just

289
00:23:25,559 --> 00:23:29,559
typing in this. I'm composing my epic novel.
And then I want to have the user save what

290
00:23:29,559 --> 00:23:35,049
they've just done, so I can do that using
the download attribute. When I click this

291
00:23:35,049 --> 00:23:39,910
button, I'm going to create a txt file, a
text file in JavaScript using the block builder

292
00:23:39,910 --> 00:23:46,910
API. Create a dynamic link in JavaScript.
Attach that download attribute as my file

293
00:23:47,530 --> 00:23:52,630
.txt as its value. When I click that, the
browser is not going to open that resource,

294
00:23:52,630 --> 00:23:57,179
it's actually going to download the file that
I just created in JavaScript, and if I open

295
00:23:57,179 --> 00:24:01,190
this, it's going to be native to my system,
and as you can see, the text content that

296
00:24:01,190 --> 00:24:04,660
I just pulled out from that text area has
been saved. I've just downloaded a file in

297
00:24:04,660 --> 00:24:11,660
JavaScript, all clientside, no servers. That's
pretty sweet.

298
00:24:14,500 --> 00:24:18,950
So we have the ability to save data in the
file system, we have the ability to get it

299
00:24:18,950 --> 00:24:25,419
back out using the down attribute. What about
getting data in between apps? Now, there's

300
00:24:25,419 --> 00:24:30,530
this thing called Web intense, and I encourage
you to go to Paul Kinlan and James' session

301
00:24:30,530 --> 00:24:36,809
later in the week. But one way to officially
transfer data is rocketships, of course. But

302
00:24:36,809 --> 00:24:40,870
another way is with post message. And in order
to describe this and set this up for you guys,

303
00:24:40,870 --> 00:24:45,720
I want to take you down sort of memory lane
of post message. Post message started off

304
00:24:45,720 --> 00:24:50,370
as a way to communicate with a Webworker or
a window object, right? You could send a string.

305
00:24:50,370 --> 00:24:54,309
You could send "hello world" to a worker,
and then it could, I don't know, do something

306
00:24:54,309 --> 00:24:58,410
interesting with that. But what happened is,
hey, people are gonna -- the browsers are

307
00:24:58,410 --> 00:25:03,380
like -- developers got smart, they were like
let's just send JSON stringify data. So they'd

308
00:25:03,380 --> 00:25:09,110
stringify some JSON, and pass some commands
in and out of worker or to a window object.

309
00:25:09,110 --> 00:25:14,059
So it was totally cool, but then the browsers
were like, hey, like, we can do better, let's

310
00:25:14,059 --> 00:25:19,530
just do that for them, just not have the ability
to stringify JSON, but let's just do it under

311
00:25:19,530 --> 00:25:24,150
the hood, so what happens is the browser would
JSON stringify and JSON parse this message

312
00:25:24,150 --> 00:25:30,250
out, so that was cool. That got us one step
further. Sort of this post message evolution,

313
00:25:30,250 --> 00:25:33,720
but then the third step that came along was
the ability to send more complex data, right?

314
00:25:33,720 --> 00:25:39,110
You just saw me send a file -- create a file
in JavaScript. Why can't I send a file into

315
00:25:39,110 --> 00:25:43,179
a Web worker and do something interesting
with it, or a Web GL texter as an array buffer?

316
00:25:43,179 --> 00:25:48,340
All right, we have binary data in -- on the
Web now; we should be able to do interesting

317
00:25:48,340 --> 00:25:50,890
things with it. So eventually , the browser
is like, hey, we'll open this up, we're going

318
00:25:50,890 --> 00:25:56,480
to use this structured cloning algorithm to
pass a blob, a file into the Web worker and

319
00:25:56,480 --> 00:26:00,760
process it. Or you can send an array buffer,
so this is really, really cool, right? And

320
00:26:00,760 --> 00:26:04,650
a lot of the modern browsers support this.
You can send a massive, you know, data set

321
00:26:04,650 --> 00:26:10,090
into a Web worker. Do some computation on
it in this sort of multi-thread environment

322
00:26:10,090 --> 00:26:13,600
and then get it back out and do something
interesting. So the real problem with this,

323
00:26:13,600 --> 00:26:17,750
though, is that these are all -- all the methods
I just covered are copies, so that becomes

324
00:26:17,750 --> 00:26:22,120
very inefficient when you're copying and sending
amounts of data in and out of a Web worker.

325
00:26:22,120 --> 00:26:26,309
It's kind of pointless to have this awesome,
you know, multi-threaded Web worker doing

326
00:26:26,309 --> 00:26:30,960
its thing, but if you can't get data in and
out very quickly, then it defeats the purpose.

327
00:26:30,960 --> 00:26:36,250
So of course I wouldn't be up here if we can't
do better, and we can do better, and that

328
00:26:36,250 --> 00:26:40,030
comes via transferable objects. Transferable
objects are something that the Web GL community

329
00:26:40,030 --> 00:26:44,919
thought up because they need this ability
to do processing on large amounts of data.

330
00:26:44,919 --> 00:26:49,900
And so you can see this guy is using your
old friend, but it has different semantics,

331
00:26:49,900 --> 00:26:54,610
and that's why this method is prefixed with
WebKit post message. This is something that

332
00:26:54,610 --> 00:27:01,610
is supported in Chrome. So what happens with
the new post message is that it's a zero copy,

333
00:27:01,740 --> 00:27:06,230
so if you're familiar with like C++ or C,
think of it as a pass-by reference rather

334
00:27:06,230 --> 00:27:11,340
than a pass-by value. And so the ownership
of this data is actually transferred from

335
00:27:11,340 --> 00:27:17,549
your main app to the worker or window context
that you're posting to. And so what happens

336
00:27:17,549 --> 00:27:22,000
is that this becomes actually really, really
efficient, up to 50 times faster. I measured

337
00:27:22,000 --> 00:27:26,370
this in Chrome 17. So Chrome 17, you know,
that is sort of long gone now, but it could

338
00:27:26,370 --> 00:27:31,750
even be faster. I don't know. But the important
point of this graph are these last two columns

339
00:27:31,750 --> 00:27:36,289
here. In Chrome 17 the difference between
the regular post message, which is on the

340
00:27:36,289 --> 00:27:40,700
left, the middle one, and the right, is orders
and orders of magnitude. This is a logarithmic

341
00:27:40,700 --> 00:27:45,970
scale, keep in mind. Faster. So basically
what I did in this test was I sent a 32 megabyte

342
00:27:45,970 --> 00:27:50,260
file into a Web worker. I didn't do any processing
on that file, and then I sent it right back

343
00:27:50,260 --> 00:27:55,360
just to see how fast that was. I measured
that. And you can see the rate -- the round

344
00:27:55,360 --> 00:28:01,929
trip simulated rate of that is super, super
fast. So this is really sweet for things like

345
00:28:01,929 --> 00:28:06,850
physics simulations and again Web GL, gaming.
I have an example of this, and unfortunately

346
00:28:06,850 --> 00:28:13,850
this is not super sexy to demo, but this is
my awesome sexy demo for transferable object.

347
00:28:14,549 --> 00:28:20,570
This page has basically set up a Web worker.
I got a worker ready to be post messaged to,

348
00:28:20,570 --> 00:28:25,000
and when I hit this run button, it's going
to use that new WebKit post message to send

349
00:28:25,000 --> 00:28:30,929
data into Web worker. I think we're sending
-- we're sending a 32 megabyte array buffer,

350
00:28:30,929 --> 00:28:35,080
so this 32 megabyte file into a web worker,
and then sending that right back, seeing how

351
00:28:35,080 --> 00:28:42,080
fast that is. So I'll hit this, ready?
Boom, boom, boom, boom. 6 milliseconds. 5,000

352
00:28:45,049 --> 00:28:47,850
megabytes a second simulated rate, right?
I mean, that is kind of ridiculous, right?

353
00:28:47,850 --> 00:28:51,169
That's awesome. That's awesome for sending
large amounts of data. And that's a lot of

354
00:28:51,169 --> 00:28:58,169
data. 32 megabytes is no joke.
Pop up a full screen here. Just to show you

355
00:28:59,220 --> 00:29:04,409
the difference -- I'm not picking on any browser
in particular -- but a browser that doesn't

356
00:29:04,409 --> 00:29:09,740
support transferable object, you can actually
noticeably see the difference here. Let me

357
00:29:09,740 --> 00:29:16,740
zoom in. So when I hit this, run, boom, boom.
So, not only do the numbers speak for themselves,

358
00:29:18,700 --> 00:29:23,730
157 as opposed to 5,000 megabytes a second,
you can actually see the delay, right, visually

359
00:29:23,730 --> 00:29:29,590
the delay that it takes for this Web app to
make that round trip request. So significant

360
00:29:29,590 --> 00:29:34,159
difference using transferable objects and
performance. In my opinion this is something

361
00:29:34,159 --> 00:29:38,169
that, you know, the Web path form and workers
in window and post message should have had

362
00:29:38,169 --> 00:29:42,250
available in the first place, but this is
sort of a common thing in the Web, right?

363
00:29:42,250 --> 00:29:45,590
We're sort of incrementally improving on what
we already had, making it better and better

364
00:29:45,590 --> 00:29:49,400
and better every time. This one's only in
Chrome, again something that should be in

365
00:29:49,400 --> 00:29:55,419
every browser. Efficiency is something we
love in the Web. How many people think the

366
00:29:55,419 --> 00:30:00,549
Web can access native hardware?
Not using phone gap or something like that?

367
00:30:00,549 --> 00:30:05,220
Okay. Got some believers. I love it. You guys
know this is when it's going to be confirmed.

368
00:30:05,220 --> 00:30:10,409
It's confirmed. It's totally confirmed. What
I mean by accessing hardware is device APIs.

369
00:30:10,409 --> 00:30:15,650
There's a whole working group dedicated to
figuring this stuff out now. And what I mean

370
00:30:15,650 --> 00:30:22,179
by devices are things like geolocation and
accessing the accelerometer of this laptop,

371
00:30:22,179 --> 00:30:26,580
using web GL to access the GPU, right, the
graphics processor unit of the laptop, using

372
00:30:26,580 --> 00:30:31,390
a very high level JavaScript API. I just showed
you the file system API. We can read and write

373
00:30:31,390 --> 00:30:37,200
folders and files on the Web now. Whether
I'm online or offline, network connectivity,

374
00:30:37,200 --> 00:30:44,200
all via JavaScript, battery API, game pad
API, all super possible. Web RTC and Web audio,

375
00:30:44,380 --> 00:30:48,090
I want to briefly mention on. There's two
dedicated sessions to these two topics, because

376
00:30:48,090 --> 00:30:53,140
they're very -- they're noteworthy and very
complex and they should have a dedicated session.

377
00:30:53,140 --> 00:30:58,110
Being able to access voice and video on the
Web is sort of this coveted grail, right?

378
00:30:58,110 --> 00:31:02,490
I mean, we've wanted to access the microphone
for a long time or get camera for a long time,

379
00:31:02,490 --> 00:31:07,190
but you've needed a plug in to do this, so
this is one example of being able to sort

380
00:31:07,190 --> 00:31:12,480
of -- the first step along this path to do
that, with one attribute, this x WebKit speech

381
00:31:12,480 --> 00:31:16,600
attribute, we can annotate an input, and the
browser is going to annotate it with this

382
00:31:16,600 --> 00:31:20,620
little microphone input. Instead of typing
in this Web app, it can actually interact

383
00:31:20,620 --> 00:31:27,620
with the microphone in this Web app. "I want
some coffee". All right. It worked. Sometimes

384
00:31:28,710 --> 00:31:33,380
it doesn't. Or you get some weird rendition.
But this is really great. A different way

385
00:31:33,380 --> 00:31:37,419
to interact with my Web app. I don't have
much of an API to play with, right? It's sort

386
00:31:37,419 --> 00:31:44,419
of happening under the hood. But I'm accessing
the microphone of this laptop using one attribute.

387
00:31:45,390 --> 00:31:50,309
So what we have now is something way better.
We have camera and microphone access via Get

388
00:31:50,309 --> 00:31:55,390
User Media. Get User Media is coming out of
the Web RTC project, navigator dot -- either

389
00:31:55,390 --> 00:32:01,900
Get User Media or the prefix version. Also
Christian from FireFox tells me this is coming

390
00:32:01,900 --> 00:32:08,320
to FireFox and nightly builds, so that should
be on there as well. To the camera, the device

391
00:32:08,320 --> 00:32:12,799
and the microphone device. With this call,
I can specify that I want audio access, I

392
00:32:12,799 --> 00:32:17,169
want video access, and what I'm going to get
back is a stream object representing that

393
00:32:17,169 --> 00:32:22,309
data that I get from both devices. And then
what's really cool is again I'm using different

394
00:32:22,309 --> 00:32:26,450
parts of the platform that have already existed
for a long time. I'm using a video element.

395
00:32:26,450 --> 00:32:32,980
HTML video is one of the core features of
HTML5 when it first came out. Instead of setting

396
00:32:32,980 --> 00:32:39,980
the video source to, you know, a movie file
or an OVG file, I'm setting it to a blob URL

397
00:32:40,120 --> 00:32:44,070
created from the data I get from the camera.
So instead of a file, I'm just sending the

398
00:32:44,070 --> 00:32:48,900
camera data and the microphone data directly
into this video tag, so that's what's going

399
00:32:48,900 --> 00:32:53,710
to give us the ability to render live to video
tag. So a little demo. There's a lot of really

400
00:32:53,710 --> 00:32:57,480
cool demos people created using Get User Media
and the ability to access the camera.

401
00:32:57,480 --> 00:33:03,080
This is my demo. I do trust this app. I made
it. I wrote it. So I'm gonna -- I can't see

402
00:33:03,080 --> 00:33:07,590
at the top. I'm going to allow access. We'll
create a video element in JavaScript, and

403
00:33:07,590 --> 00:33:11,700
there we go. My first stage -- you can see
behind -- so this is great, no plug-ins, right?

404
00:33:11,700 --> 00:33:16,220
This is just JavaScript on the Web, but again
I can combine this with different parts of

405
00:33:16,220 --> 00:33:21,580
the Web platform, so I can use CSS filters
in real time to overlay this video with effects

406
00:33:21,580 --> 00:33:25,940
like gray scale. How about a blur effect in
real time?

407
00:33:25,940 --> 00:33:29,520
That's pretty -- that is pretty trippy. Version
effects, right?

408
00:33:29,520 --> 00:33:33,679
Just using CSS, applying to this video, I
can do all that and still really awesome,

409
00:33:33,679 --> 00:33:36,150
looks great. I can combine it with a canvas,
right, do a photo booth effect.

410
00:33:36,150 --> 00:33:36,600
[chuckling]
>>Eric Bidleman: All right. That's enough

411
00:33:36,600 --> 00:33:43,600
of that. One of my favorites, though, is this
one called the Web cam toy, so I'll grant

412
00:33:52,900 --> 00:33:59,679
access to this. Okay, that uses my camera.
This is not going to use CSS filters, but

413
00:33:59,679 --> 00:34:03,750
it's going to use the power of camera, the
power of Web GL, right? So with Web GL we

414
00:34:03,750 --> 00:34:08,049
can access the GPU, that native access, and
we can do things -- really awesome things

415
00:34:08,049 --> 00:34:12,720
with shaders. Shader technology is amazing.
Again, this is all JavaScript using Web GL.

416
00:34:12,720 --> 00:34:19,720
No plug-ins. Look how fast it is. Really trippy
things. Let me get to the cool stuff. There

417
00:34:27,940 --> 00:34:29,460
it is.
[chuckling]

418
00:34:29,460 --> 00:34:33,520
[ APPLAUSE ]
>>Eric Bidleman: Yeah. This one is cool.

419
00:34:33,520 --> 00:34:40,349
Super trippy. Oh, yeah, 3D. This is after
you've had a few drinks at the party tonight.

420
00:34:40,349 --> 00:34:43,389
Just amazing things. People have done thing
with augmented reality, right, holding up

421
00:34:43,389 --> 00:34:48,510
a paper -- piece of paper with a QR code on
it, the camera tracks you. So play around

422
00:34:48,510 --> 00:34:52,820
with those. When I put the slide up later,
just really awesome, amazing things. Support

423
00:34:52,820 --> 00:34:56,010
for this is actually really good. Opera just
released Opera 12; it has this. They've had

424
00:34:56,010 --> 00:35:00,109
it in the mobile version for a long time.
It's coming to FireFox nightly I'm told, and

425
00:35:00,109 --> 00:35:03,820
Chrome just released a stable version with
Get User Media, so we can do camera access,

426
00:35:03,820 --> 00:35:09,349
we can do microphone access without a plug-in
now.

427
00:35:09,349 --> 00:35:16,349
HTML5 audio has had a little bit of a slack
-- been problematic, to say the least. But

428
00:35:18,550 --> 00:35:25,550
what we can do now with the Web audio, guys,
make it -- make it sexy again. So HTML5 audio

429
00:35:25,690 --> 00:35:30,640
is great. It's just like video, right? Without
a plug-in, we can play audio on the Web, just

430
00:35:30,640 --> 00:35:35,920
populate a source attribute of an audio tag.
Play it, that's cool, we don't need a plug-in,

431
00:35:35,920 --> 00:35:40,500
but what if you want to do something like
this.

432
00:35:40,500 --> 00:35:47,210
[Music Playing]
What if you want to visualize that data in

433
00:35:47,210 --> 00:35:48,220
real time, get the frequency analysis as it
plays?

434
00:35:48,220 --> 00:35:50,490
Visualize that on two canvas tags, plus Web
GL transforms a little bit of a reflection

435
00:35:50,490 --> 00:35:57,490
on the bottom there. Can't do that with HTML5
audio. What we have now is ability to tie

436
00:36:01,109 --> 00:36:07,740
in to what's called a Web audio API, tie in
an audio tag as a source to that API, so instead

437
00:36:07,740 --> 00:36:10,380
of driving the Web audio API, via, you know,
an XHR request or something, we can just send

438
00:36:10,380 --> 00:36:11,320
data directly to it -- sorry -- via -- via
this audio tag, so it's really, really important.

439
00:36:11,320 --> 00:36:11,570
This doesn't have to just be a video. It could
be a -- excuse me, an audio tag, it could

440
00:36:11,430 --> 00:36:18,430
be a video tag, so imagine I had a HTML5 video
playing, and that is the source to the Web

441
00:36:22,050 --> 00:36:29,050
audio API, then you're visualizing sort of
effects, as movie changes and dark monsters

442
00:36:32,400 --> 00:36:36,530
pop out, you can really scare people. But
the way the search works is really easy, so

443
00:36:36,530 --> 00:36:39,880
we have the Web audio guy. I encourage you
to go to Chris Wilson's session later in the

444
00:36:39,880 --> 00:36:45,270
week about this, really amazing API. A lot
of low level access to the core audio of the

445
00:36:45,270 --> 00:36:50,350
system. High level JavaScript API on top of
it. Create an audio context. Notifications

446
00:36:50,350 --> 00:36:57,350
-- I will create HTML5 audio element, I will
populate it with MP3 as its source, set up

447
00:36:59,859 --> 00:37:04,330
a couple of controls, some auto play on it.
The important integration point between these

448
00:37:04,330 --> 00:37:09,599
two, sort of the old audio working with the
new Web audio, the capabilities of that API

449
00:37:09,599 --> 00:37:15,140
is this create element source, media element
source. That's how the audio tag is sort of

450
00:37:15,140 --> 00:37:22,140
filtered and piped into the Web audio API.
Which leads us conveniently into Number 10.

451
00:37:27,210 --> 00:37:31,980
So I get this one a lot. A lot of people ask:
"Hey, how come HTML5 can't do, you know, streaming

452
00:37:31,980 --> 00:37:33,740
audio?
Or streaming media?"

453
00:37:33,740 --> 00:37:39,580
And it actually can. It can do that through
another old friend, WebSockets. So WebSockets

454
00:37:39,580 --> 00:37:43,830
have been around for a while. It sort of suffered
from the same limitation of Webworker, where

455
00:37:43,830 --> 00:37:49,140
you can only send just basic data. It can
send string data. That's not so handy, right?

456
00:37:49,140 --> 00:37:54,210
We have things like files and array buffers
and ability to use complex data. We should

457
00:37:54,210 --> 00:37:58,540
be able to send and stream multi-media or
files to our web apps.

458
00:37:58,540 --> 00:38:04,260
So we can do that now with WebSockets. And
WebSockets has a new sort of socket, that

459
00:38:04,260 --> 00:38:07,790
binary type is the property you set on this.
And you set it to a blob or you set it to

460
00:38:07,790 --> 00:38:12,470
an array buffer, and that tells the WebSocket
that's going to be speaking binary data instead

461
00:38:12,470 --> 00:38:18,670
of just regular string data. What's awesome
about this is on my on message event, I can

462
00:38:18,670 --> 00:38:23,720
use that directly to set an image source,
for instance, from a blog URL. Instead of

463
00:38:23,720 --> 00:38:28,310
having to base 64 encode data on either end,
decode it, which is, you know, the overhead

464
00:38:28,310 --> 00:38:32,910
associated with that, we can just use the
data directly that we get back.

465
00:38:32,910 --> 00:38:39,910
So I have a couple of demos of this. The first
is a Chrome extension. So I have a little

466
00:38:42,030 --> 00:38:47,589
Chrome extension installed here and top right
corner. I'm going to click this guy. Imagine

467
00:38:47,589 --> 00:38:52,770
this is my viewer. I'm going to basically
do a sort of screen cast from the Web.

468
00:38:52,770 --> 00:38:57,030
This is my viewer, imagine this is somewhere
around the globe. I'm going to open a new

469
00:38:57,030 --> 00:39:01,820
window, pretend that's here.
So when I click this guy again, it's going

470
00:39:01,820 --> 00:39:07,839
to fire up a Websocket, binary Websocket,
and use the Chrome extension, screen capture

471
00:39:07,839 --> 00:39:14,839
API to capture the current tab. Google.com.
Sports, because sports is great.

472
00:39:15,190 --> 00:39:21,210
So on the right side, I have my presenter,
this is just capturing the current tab as

473
00:39:21,210 --> 00:39:26,640
a png as I scroll. It's sending that data
through a WebSocket to the remote party. You

474
00:39:26,640 --> 00:39:30,450
can see it's very performant. I don't have
to do any basic 64 encoding. As I'm scrolling

475
00:39:30,450 --> 00:39:35,310
on the right on the live page, that image
is just being sent across the wire in near

476
00:39:35,310 --> 00:39:39,820
real-time using the WebSocket. That's really,
really sweet, right? We can do this now thanks

477
00:39:39,820 --> 00:39:44,500
to the Chrome extension API, yes, but also
via a binary WebSocket.

478
00:39:44,500 --> 00:39:50,430
Whoa, inception.
[Laughter].

479
00:39:50,430 --> 00:39:57,140
>>Eric Bidelman: We can also do other things
with different types of media. So I just showed

480
00:39:57,140 --> 00:40:02,890
you a little teaser preview of the Web audio
API. The API allows you to analyze sound in

481
00:40:02,890 --> 00:40:08,290
real-time as it plays.
What I have here is a page that sets up a

482
00:40:08,290 --> 00:40:13,640
binary WebSocket, and it's going to use the
file reader API to essentially cut an MP3

483
00:40:13,640 --> 00:40:19,089
file up into multiple smaller chunks and then
it's going to connect to that WebSocket, send

484
00:40:19,089 --> 00:40:25,280
each of those chunks across the wire, on my
-- on my left side here, the viewer side,

485
00:40:25,280 --> 00:40:30,300
I'm going to use the Web audio API to schedule
those chunks at very precise times exactly

486
00:40:30,300 --> 00:40:33,349
when they should happen.
So essentially I reconstruct the audio on

487
00:40:33,349 --> 00:40:38,930
the other end and just sort of use the sequence
that it should be in and then visualize that

488
00:40:38,930 --> 00:40:45,060
using the Web audio API. I'm going to load
up an MP3 file here on my DJ machine, this

489
00:40:45,060 --> 00:40:49,930
guy in the right corner. Binary WebSocket,
web audio API.

490
00:40:49,930 --> 00:40:53,530
No sound?
There we go, there's sound.

491
00:40:53,530 --> 00:40:57,140
[ Music ]
>>Eric Bidelman: So again, streaming from

492
00:40:57,140 --> 00:41:04,140
one client, streaming audio data using a WebSocket,
using the Web to reconstruct it and then visualizing

493
00:41:08,339 --> 00:41:11,150
in real-time.
You can see the chunks coming in, I'm receiving

494
00:41:11,150 --> 00:41:14,150
sort of mini chunks of that MP3 file as I
reconstruct the audio and sort of the current

495
00:41:14,150 --> 00:41:21,150
time is playing. Just to prove to you this
is streaming, I refresh this, come back at

496
00:41:22,810 --> 00:41:25,300
the exact same spot. It's using two brand
new search capabilities on the Web platform

497
00:41:25,300 --> 00:41:27,690
together, something that you probably maybe
not hopefully didn't think was possible, in

498
00:41:27,690 --> 00:41:34,690
streaming audio on the Web.
No more plug-ins for this, you can do is now

499
00:41:42,640 --> 00:41:47,570
using the Web platform.
[ Music ]

500
00:41:47,570 --> 00:41:51,690
So that was really quick. I covered a lot.
I just want to point out that we did cover,

501
00:41:51,690 --> 00:41:56,140
you know, sort of everything under the sun.
The Web can do really amazing things, I hope

502
00:41:56,140 --> 00:42:02,240
you do agree. CSS, whether it's the new CSS
stuff for Web application layout and design,

503
00:42:02,240 --> 00:42:07,990
doing data binding, doing things like file
access, accessing the native hardware, using

504
00:42:07,990 --> 00:42:11,470
-- officially transferring data once you have
it in your Web app, and then doing really

505
00:42:11,470 --> 00:42:16,740
awesome things with some of the older capabilities
of HTML5 multi-media, and also some of the

506
00:42:16,740 --> 00:42:21,520
newer stuff, combine those two with the integration
points.

507
00:42:21,520 --> 00:42:23,950
Just want to point out, we have a Google+
developers page. If you guys want to know

508
00:42:23,950 --> 00:42:29,349
more about what Chrome is doing with HTML5,
and the open web, check that out. If you are

509
00:42:29,349 --> 00:42:33,550
not using Chrome Canary, or the developer
channel, Chrome really does heart HTML5. A

510
00:42:33,550 --> 00:42:37,440
lot of this stuff I just showed you again
is very new. So play with the new Chrome file

511
00:42:37,440 --> 00:42:42,660
bugs on new.crbug.com. Let us know what you
think. Give us the feedback.

512
00:42:42,660 --> 00:42:47,390
This presentation will be up on my GitHub
account at HTML5can, as soon as I exit this

513
00:42:47,390 --> 00:42:54,200
stage. You can also access these slides at
HTMLfive, with the five spelled out, can.com.

514
00:42:54,200 --> 00:42:57,400
There's my social stuff if you want to follow
or Tweet at me. I'm happy to take questions

515
00:42:57,400 --> 00:43:01,680
here and I will also be available after the
show, as well as office hours tomorrow.

516
00:43:01,680 --> 00:43:03,150
Thanks, guys, appreciate your time.
[ Applause ]

