1
00:00:00,000 --> 00:00:08,850

2
00:00:08,850 --> 00:00:10,360
RAY CROMWELL: Good afternoon.

3
00:00:10,360 --> 00:00:12,990
How you guys doing?

4
00:00:12,990 --> 00:00:15,070
I'm looking around the room and
I'm seeing a lot of people

5
00:00:15,070 --> 00:00:18,490
who I think are either
passionate about GWT or Dart,

6
00:00:18,490 --> 00:00:21,480
because you could have been
downstairs getting your Nexus

7
00:00:21,480 --> 00:00:24,260
7, your Galaxy Nexus, and
your Nexus Q, but

8
00:00:24,260 --> 00:00:25,760
you're here in my session.

9
00:00:25,760 --> 00:00:28,570
So thanks for coming.

10
00:00:28,570 --> 00:00:31,110
This session is titled
"Migrating Code from GWT to

11
00:00:31,110 --> 00:00:34,700
Dart." And if you
might notice--

12
00:00:34,700 --> 00:00:36,010
I'm tech lead for GWT.

13
00:00:36,010 --> 00:00:37,710
My name is Ray Cromwell.

14
00:00:37,710 --> 00:00:39,670
So the first thing you might be
asking-- and I get this a

15
00:00:39,670 --> 00:00:42,240
lot-- before the session even
starts, is why Dart?

16
00:00:42,240 --> 00:00:44,360
Why am I even giving a Dart
session in the first place?

17
00:00:44,360 --> 00:00:46,290
I'm tech lead on GWT.

18
00:00:46,290 --> 00:00:48,720
Well first of all, actually,
I think Dart's

19
00:00:48,720 --> 00:00:49,770
a really cool language.

20
00:00:49,770 --> 00:00:53,030
And I'm a compiler geek so I
tend to like languages and

21
00:00:53,030 --> 00:00:54,240
language-oriented stuff.

22
00:00:54,240 --> 00:00:58,100
So I volunteered to give this
session, because to me,

23
00:00:58,100 --> 00:01:00,710
learning programming languages
is not about discussing which

24
00:01:00,710 --> 00:01:05,239
language is best, whether Dart
is better than JavaScript or

25
00:01:05,239 --> 00:01:06,850
better than Java and so on.

26
00:01:06,850 --> 00:01:10,580
Because every language that you
encounter has things that

27
00:01:10,580 --> 00:01:12,680
are good about them and
things that people

28
00:01:12,680 --> 00:01:14,190
will complain about.

29
00:01:14,190 --> 00:01:17,230
And so for each type of
application, there's always

30
00:01:17,230 --> 00:01:21,760
sort of a sweet spot, and Dart
is no exception to that.

31
00:01:21,760 --> 00:01:24,660
But it is a very cool language,
and it takes some of

32
00:01:24,660 --> 00:01:28,740
the best features from
JavaScript and Java and

33
00:01:28,740 --> 00:01:29,680
combines them into one.

34
00:01:29,680 --> 00:01:31,480
And I'll get to that later.

35
00:01:31,480 --> 00:01:33,050
I also think learning
new languages is

36
00:01:33,050 --> 00:01:33,750
good for your brain.

37
00:01:33,750 --> 00:01:36,580
Just like bilingualism and
spoken languages, if you learn

38
00:01:36,580 --> 00:01:37,990
multiple programming languages,
it's going to be

39
00:01:37,990 --> 00:01:39,070
good for your career.

40
00:01:39,070 --> 00:01:40,930
It's going to make you think
in different ways.

41
00:01:40,930 --> 00:01:43,080
And hopefully exposure to Dart
will make you think about

42
00:01:43,080 --> 00:01:45,860
designing web applications in
different ways, perhaps ways

43
00:01:45,860 --> 00:01:52,140
that are more structured, if
you're not a Java programmer.

44
00:01:52,140 --> 00:01:54,650
And finally, I don't really
think that you can evaluate a

45
00:01:54,650 --> 00:01:57,200
language unless you've
developed using it.

46
00:01:57,200 --> 00:02:00,740
A lot of times, you're online
and you'll see people having

47
00:02:00,740 --> 00:02:02,080
wars over programming
languages.

48
00:02:02,080 --> 00:02:04,310
My language is better
than yours.

49
00:02:04,310 --> 00:02:06,780
They'll microcriticize various
parts of the spec.

50
00:02:06,780 --> 00:02:10,360
But really, you'll never know
what's cool about a language

51
00:02:10,360 --> 00:02:13,250
or what sucks about it unless
you actually develop with it.

52
00:02:13,250 --> 00:02:17,950
And so this presentation is
designed to help you utilize

53
00:02:17,950 --> 00:02:22,390
what you already know, which is
hopefully Java and GWT, and

54
00:02:22,390 --> 00:02:26,670
get you up to speed on Dart as
fast as possible so you can

55
00:02:26,670 --> 00:02:28,730
try that experiment
out for yourself.

56
00:02:28,730 --> 00:02:31,100
And then you can make the
decision whether or not you

57
00:02:31,100 --> 00:02:33,760
think Dart is a good language
for you or GWT is a good

58
00:02:33,760 --> 00:02:35,615
language for you, or hand-coded
JavaScript's a good

59
00:02:35,615 --> 00:02:37,210
language for you.

60
00:02:37,210 --> 00:02:40,860
And so I want to try to map
concepts that you already know

61
00:02:40,860 --> 00:02:44,690
from Java and GWT into Dart so
that you'll understand things

62
00:02:44,690 --> 00:02:45,920
faster and quicker.

63
00:02:45,920 --> 00:02:49,170
I want to try to teach you some
Dart idioms and to get

64
00:02:49,170 --> 00:02:52,590
your feet wet in terms of
porting some existing GWT

65
00:02:52,590 --> 00:02:56,250
application constructs
into Dart.

66
00:02:56,250 --> 00:02:58,320
So what is Dart?

67
00:02:58,320 --> 00:03:01,260
We say it's a structured
language for web applications.

68
00:03:01,260 --> 00:03:04,510
But it's more than that, because
on the surface, it has

69
00:03:04,510 --> 00:03:06,380
the appearance of
being Java-like.

70
00:03:06,380 --> 00:03:09,860
But underneath it's a
dynamically typed language.

71
00:03:09,860 --> 00:03:10,820
So what does that mean?

72
00:03:10,820 --> 00:03:12,900
If you think of JavaScript--

73
00:03:12,900 --> 00:03:16,470
it means that you can refer to
things on an object, fields or

74
00:03:16,470 --> 00:03:18,720
invoke methods and so on,
regardless of what the

75
00:03:18,720 --> 00:03:19,900
declared type is.

76
00:03:19,900 --> 00:03:23,200
You might say it's a customer
object, but at run time you

77
00:03:23,200 --> 00:03:25,960
can still refer to that object
as if it was a totally

78
00:03:25,960 --> 00:03:26,490
different type.

79
00:03:26,490 --> 00:03:29,800
The type doesn't restrict
you from shooting

80
00:03:29,800 --> 00:03:31,860
yourself in the foot.

81
00:03:31,860 --> 00:03:35,620
But Dart goes a little bit
further, because although you

82
00:03:35,620 --> 00:03:39,860
can do that, you can also run,
optionally, your application

83
00:03:39,860 --> 00:03:40,680
in checked mode.

84
00:03:40,680 --> 00:03:43,260
And in checked mode, the
types do have meaning.

85
00:03:43,260 --> 00:03:45,250
And you will get runtime errors
if you, for example,

86
00:03:45,250 --> 00:03:48,580
try to access something on an
object or a class that wasn't

87
00:03:48,580 --> 00:03:50,030
there in that type.

88
00:03:50,030 --> 00:03:52,330
But in general, when you're
programing in Dart, unlike in

89
00:03:52,330 --> 00:03:55,740
Java, you should treat the
types like annotation or

90
00:03:55,740 --> 00:03:59,190
documentation for both people
reading the code and for

91
00:03:59,190 --> 00:04:01,890
machines that are processing
it, like tools.

92
00:04:01,890 --> 00:04:03,450
Dart's also a class-based

93
00:04:03,450 --> 00:04:04,790
object-oriented programming language.

94
00:04:04,790 --> 00:04:06,520
It's not a prototype-based
language.

95
00:04:06,520 --> 00:04:07,820
It's not functional language.

96
00:04:07,820 --> 00:04:11,320
It's class-based
object-oriented.

97
00:04:11,320 --> 00:04:14,860
But because it has a type
system and it's

98
00:04:14,860 --> 00:04:16,850
OO, it's very toolable.

99
00:04:16,850 --> 00:04:18,550
So one of the things you'll be
able to do is you'll be able

100
00:04:18,550 --> 00:04:21,190
to go out and get things like
the Dart Editor, which is

101
00:04:21,190 --> 00:04:24,670
based on the Eclipse framework,
or the latest

102
00:04:24,670 --> 00:04:27,730
IntelliJ plugin, and you'll
actually be able to get all of

103
00:04:27,730 --> 00:04:30,620
this nice stuff that you
like in Java in Dart.

104
00:04:30,620 --> 00:04:34,140
Command method completion, field
completion, refactoring,

105
00:04:34,140 --> 00:04:35,070
go to declaration--

106
00:04:35,070 --> 00:04:35,810
all those things are there.

107
00:04:35,810 --> 00:04:38,950
Things that are actually
typically hard to do in

108
00:04:38,950 --> 00:04:43,010
dynamic languages with
IDEs, you can do

109
00:04:43,010 --> 00:04:44,980
quite easily with Dart.

110
00:04:44,980 --> 00:04:47,560
And Dart has the option of
running either natively in the

111
00:04:47,560 --> 00:04:51,520
Dart VM or in any other browser
by using a Dart-to-JS

112
00:04:51,520 --> 00:04:55,590
compiler, which compiles
the JS just like GWT.

113
00:04:55,590 --> 00:04:57,520
So let's dive right in.

114
00:04:57,520 --> 00:04:59,740
Rather than teaching the
language spec, if you haven't

115
00:04:59,740 --> 00:05:02,170
seen any of the other sessions,
I'm just going to

116
00:05:02,170 --> 00:05:06,930
start off with Java and try to
transmorgify it into Dart.

117
00:05:06,930 --> 00:05:08,690
Let's see how that works out.

118
00:05:08,690 --> 00:05:11,350
So the first thing that's
different between Dart and

119
00:05:11,350 --> 00:05:15,250
Java is basically, there's no
access modifier keywords.

120
00:05:15,250 --> 00:05:18,580
So you can basically just remove
the private and public

121
00:05:18,580 --> 00:05:21,640
declarations and the code
will continue to work.

122
00:05:21,640 --> 00:05:23,550
The next thing is that
types are optional.

123
00:05:23,550 --> 00:05:27,490
So it's not-- we don't always
recommend removing types.

124
00:05:27,490 --> 00:05:30,180
I think well-written library
code should have the types

125
00:05:30,180 --> 00:05:31,860
there so when other people are
reading your code, they'll

126
00:05:31,860 --> 00:05:33,470
actually kind of know
the intent.

127
00:05:33,470 --> 00:05:35,640
But just to show you, we
can remove that string

128
00:05:35,640 --> 00:05:39,220
declaration, that Boolean field
declaration, and we end

129
00:05:39,220 --> 00:05:41,830
up with that.

130
00:05:41,830 --> 00:05:43,700
The other thing is that--

131
00:05:43,700 --> 00:05:44,880
and I actually like
this feature.

132
00:05:44,880 --> 00:05:47,400
This is one of my favorite
features of Dart.

133
00:05:47,400 --> 00:05:50,710
In Java, you write the same code
over and over and over

134
00:05:50,710 --> 00:05:52,540
again for initializing
constructors.

135
00:05:52,540 --> 00:05:53,800
You have a constructor.

136
00:05:53,800 --> 00:05:55,220
It takes three parameters.

137
00:05:55,220 --> 00:05:56,610
What is the first thing you
do in the body of the

138
00:05:56,610 --> 00:05:57,260
constructor?

139
00:05:57,260 --> 00:06:00,940
This dot x equals y, this dot a
equals b, and so on, right?

140
00:06:00,940 --> 00:06:02,470
The same thing--

141
00:06:02,470 --> 00:06:05,640
and a lot of languages have
this problem too, but Dart

142
00:06:05,640 --> 00:06:08,460
actually has a little bit of
syntactic sugar for this.

143
00:06:08,460 --> 00:06:12,490
So if you want to auto-assign
a parameter to a field, then

144
00:06:12,490 --> 00:06:15,660
you refer to the field in the
constructor parameter

145
00:06:15,660 --> 00:06:18,160
declaration with a
this qualifier.

146
00:06:18,160 --> 00:06:22,310
So here I'm saying this.name
and that's it, in the

147
00:06:22,310 --> 00:06:23,630
constructor parameter list.

148
00:06:23,630 --> 00:06:28,310
And basically the Dart VM or the
Dart compiler knows that

149
00:06:28,310 --> 00:06:32,470
that refers to the field name,
which has a string type, and

150
00:06:32,470 --> 00:06:35,820
it's going to autogenerate
this.name equals name for you.

151
00:06:35,820 --> 00:06:40,060

152
00:06:40,060 --> 00:06:46,290
In Java, if you have a block of
code in an if statement or

153
00:06:46,290 --> 00:06:48,690
a for statement that only has
one line, you now that you can

154
00:06:48,690 --> 00:06:51,360
eliminate the curly braces
and just put a semicolon.

155
00:06:51,360 --> 00:06:54,810
In Dart, even for method
declarations, you can

156
00:06:54,810 --> 00:06:56,630
eliminate the curly braces.

157
00:06:56,630 --> 00:07:01,360
So here is a method that only
has one line of code in it.

158
00:07:01,360 --> 00:07:04,540
And so the cat constructor just
equals greater-than and

159
00:07:04,540 --> 00:07:06,050
then an expression to
the right of it.

160
00:07:06,050 --> 00:07:09,410

161
00:07:09,410 --> 00:07:11,030
So Dart doesn't have packages.

162
00:07:11,030 --> 00:07:14,450
It has something that's not
exactly like a package.

163
00:07:14,450 --> 00:07:15,430
It's called a library.

164
00:07:15,430 --> 00:07:18,080
And so here we just delete
package com.foo and we just

165
00:07:18,080 --> 00:07:21,110
use #library('foo'), which is
basically saying the code

166
00:07:21,110 --> 00:07:22,370
below it is part of
that library.

167
00:07:22,370 --> 00:07:25,560

168
00:07:25,560 --> 00:07:29,420
Now I said that Dart doesn't
have access qualifiers, like

169
00:07:29,420 --> 00:07:30,560
public and private.

170
00:07:30,560 --> 00:07:34,860
But you can hide things
within a library.

171
00:07:34,860 --> 00:07:37,350
So you can make it so that no
one outside of the library foo

172
00:07:37,350 --> 00:07:38,600
can see a particular variable.

173
00:07:38,600 --> 00:07:42,400
And the way you do that is by
putting a leading underscore

174
00:07:42,400 --> 00:07:43,260
on the field name.

175
00:07:43,260 --> 00:07:48,390
So in this example, _name and
_iCanHazMeme are only visible

176
00:07:48,390 --> 00:07:53,740
to classes within
the library foo.

177
00:07:53,740 --> 00:07:55,750
So Dart doesn't have an import
statement like Java, but it

178
00:07:55,750 --> 00:07:57,050
does have #import.

179
00:07:57,050 --> 00:08:00,730
And with #import, basically,
you import libraries.

180
00:08:00,730 --> 00:08:02,940
And this is the syntax for it.

181
00:08:02,940 --> 00:08:04,030
So we're getting there.

182
00:08:04,030 --> 00:08:06,250
We're almost fully converted.

183
00:08:06,250 --> 00:08:10,040
So Dart has final fields,
but they're initialized

184
00:08:10,040 --> 00:08:11,210
differently than Java.

185
00:08:11,210 --> 00:08:13,960
They're using the C++-style
initializer list.

186
00:08:13,960 --> 00:08:16,520
So if you have some final
fields, they have to be

187
00:08:16,520 --> 00:08:18,560
assigned during construction.

188
00:08:18,560 --> 00:08:20,440
And so the way you do it is
you put a colon after the

189
00:08:20,440 --> 00:08:23,250
constructor and then a
comma-separated list of

190
00:08:23,250 --> 00:08:24,500
assignments.

191
00:08:24,500 --> 00:08:27,730

192
00:08:27,730 --> 00:08:29,230
Dart also has static fields.

193
00:08:29,230 --> 00:08:31,680
So you can see in this example,
UBER_CAT, we want it

194
00:08:31,680 --> 00:08:35,380
be a static, final, immutable
Cat, right,

195
00:08:35,380 --> 00:08:36,630
that everyone sees.

196
00:08:36,630 --> 00:08:39,640

197
00:08:39,640 --> 00:08:43,210
And you can initialize them to
be immutable or singleton--

198
00:08:43,210 --> 00:08:45,100
think of string interning
in Java--

199
00:08:45,100 --> 00:08:50,660
by using something Dart has
called a const constructor.

200
00:08:50,660 --> 00:08:53,310
So if you put the const keyword
in front of the Cat

201
00:08:53,310 --> 00:08:56,220
constructor, essentially what
this is saying is that there's

202
00:08:56,220 --> 00:09:02,510
only ever one instance of that
Cat with that parameter name.

203
00:09:02,510 --> 00:09:09,070
So if you construct a Cat and
the name is Mr. Tibbles, then

204
00:09:09,070 --> 00:09:10,840
there's only one instance
of Mr. Tibbles.

205
00:09:10,840 --> 00:09:13,340
And the next time you try to
allocate one, you'll still get

206
00:09:13,340 --> 00:09:14,300
the same instance.

207
00:09:14,300 --> 00:09:16,120
That means you can
use a reference

208
00:09:16,120 --> 00:09:19,690
comparison, for example.

209
00:09:19,690 --> 00:09:22,090
Another biggie, and this'll
probably be the biggest shock

210
00:09:22,090 --> 00:09:24,930
if you're coming from Java or
GWT, is that there's no

211
00:09:24,930 --> 00:09:27,340
function overloading in Dart.

212
00:09:27,340 --> 00:09:30,220
And so here's a typical
example of Java--

213
00:09:30,220 --> 00:09:34,320
the Money class, where it's
storing things as a

214
00:09:34,320 --> 00:09:35,810
fixed-point integer.

215
00:09:35,810 --> 00:09:38,560
Let's say multiplied by 100,
so it's in pennies.

216
00:09:38,560 --> 00:09:40,410
And so someone might have
three constructors.

217
00:09:40,410 --> 00:09:42,930
One that takes an int, one that
takes a string, and one

218
00:09:42,930 --> 00:09:44,390
that takes a double.

219
00:09:44,390 --> 00:09:45,900
And they might have some
overloaded methods.

220
00:09:45,900 --> 00:09:48,170
So down at the bottom we
have two add methods.

221
00:09:48,170 --> 00:09:51,870
One takes another Money class,
and one takes another Money

222
00:09:51,870 --> 00:09:57,910
class but optionally charges tax
before it adds the money.

223
00:09:57,910 --> 00:10:01,390
So Dart works around this
problem by introducing named

224
00:10:01,390 --> 00:10:02,440
constructors.

225
00:10:02,440 --> 00:10:05,120
So in Dart, your constructor
does not always have to have

226
00:10:05,120 --> 00:10:07,360
the same name as your
class itself.

227
00:10:07,360 --> 00:10:09,460
In Java, your constructor
for the Cat class is

228
00:10:09,460 --> 00:10:10,830
always called Cat.

229
00:10:10,830 --> 00:10:13,250
In Dart, you have a
constructor called

230
00:10:13,250 --> 00:10:16,030
Money.fromDouble and
Money.fromString.

231
00:10:16,030 --> 00:10:20,540
So the actual qualified
constructor name is itself an

232
00:10:20,540 --> 00:10:21,170
constructor.

233
00:10:21,170 --> 00:10:24,120
So someone, if they wanted to
create Money from a double,

234
00:10:24,120 --> 00:10:26,180
they'd say new Money.fromDouble

235
00:10:26,180 --> 00:10:27,430
and then the value.

236
00:10:27,430 --> 00:10:29,680

237
00:10:29,680 --> 00:10:33,390
Likewise, for the overloaded
method case, what we can do is

238
00:10:33,390 --> 00:10:35,950
we can collapse those two
methods into a single method

239
00:10:35,950 --> 00:10:38,090
because Dart has optional
parameters.

240
00:10:38,090 --> 00:10:40,430
So all you do to make a
parameter optional is you

241
00:10:40,430 --> 00:10:42,040
enclose it in square brackets.

242
00:10:42,040 --> 00:10:46,720
So now the original Money
class, which had two

243
00:10:46,720 --> 00:10:49,820
parameters, and then another
specialized version, which had

244
00:10:49,820 --> 00:10:52,090
the emitted parameter is
collapsed into a single method

245
00:10:52,090 --> 00:10:53,340
which has the optional
parameter.

246
00:10:53,340 --> 00:10:56,870

247
00:10:56,870 --> 00:10:59,470
And you could specify default
values for the parameters.

248
00:10:59,470 --> 00:11:02,180
So typically in Java, if you
have this case where you have

249
00:11:02,180 --> 00:11:04,672
two overloads, and one of them
is just an overload because

250
00:11:04,672 --> 00:11:07,550
you want to allow the person to
emit an optional parameter,

251
00:11:07,550 --> 00:11:11,130
you'd typically have one method
call the other and pass

252
00:11:11,130 --> 00:11:12,930
in the default value.

253
00:11:12,930 --> 00:11:14,790
Here you can just specify
the value.

254
00:11:14,790 --> 00:11:16,670
So I say in the default,
if you don't specify

255
00:11:16,670 --> 00:11:19,132
chargeTax is true.

256
00:11:19,132 --> 00:11:22,580
The government's gonna
love that.

257
00:11:22,580 --> 00:11:25,310
As a bonus, all optional
parameters are named

258
00:11:25,310 --> 00:11:25,870
parameters.

259
00:11:25,870 --> 00:11:28,190
So if you have a list of like
five optional parameters, and

260
00:11:28,190 --> 00:11:31,640
maybe you don't memorize the API
but you happen to know the

261
00:11:31,640 --> 00:11:34,860
names of the parameters, you
can specify the optional

262
00:11:34,860 --> 00:11:37,770
parameter by putting a colon
in front of its name.

263
00:11:37,770 --> 00:11:39,780
So I'm passing the chargeTax
parameter by

264
00:11:39,780 --> 00:11:41,030
saying chargeTax: false.

265
00:11:41,030 --> 00:11:45,420

266
00:11:45,420 --> 00:11:47,490
Here's an interesting thing.

267
00:11:47,490 --> 00:11:50,790
A lot of people complain about
Java, of people creating tons

268
00:11:50,790 --> 00:11:53,590
of factory service locator,
factory factory classes, and

269
00:11:53,590 --> 00:11:54,600
things like that.

270
00:11:54,600 --> 00:11:57,410
And factories and dependency
injection are very, very

271
00:11:57,410 --> 00:11:58,960
common in Java.

272
00:11:58,960 --> 00:12:01,300
And I think Dart recognized
this and said, we should

273
00:12:01,300 --> 00:12:04,530
provide a solution for
this that doesn't

274
00:12:04,530 --> 00:12:05,690
add a lot of bloat.

275
00:12:05,690 --> 00:12:08,380
And so what you can do is you
can designate a constructor as

276
00:12:08,380 --> 00:12:10,070
a factory constructor.

277
00:12:10,070 --> 00:12:13,640
So here we're saying the Money
constructor that takes an

278
00:12:13,640 --> 00:12:16,690
amount is a factory
constructor.

279
00:12:16,690 --> 00:12:19,430
And what it does is it says,
if the amount is equal to

280
00:12:19,430 --> 00:12:22,990
zero, then return this static
final interned instance of

281
00:12:22,990 --> 00:12:25,930
zero, else return a new
Money object that's

282
00:12:25,930 --> 00:12:27,490
constructed on the fly.

283
00:12:27,490 --> 00:12:29,650
And typically you might do this
if you want to use zero

284
00:12:29,650 --> 00:12:33,100
as a special value to use
reference equality.

285
00:12:33,100 --> 00:12:36,060
There's only ever one Money
object representing zero

286
00:12:36,060 --> 00:12:40,220
money, but other ones actually
have differing values.

287
00:12:40,220 --> 00:12:42,720
And so what happens is, when
you new the Money object it

288
00:12:42,720 --> 00:12:45,660
actually calls this method, and
the method actually can

289
00:12:45,660 --> 00:12:48,120
return a different object,
unlike a typical Java

290
00:12:48,120 --> 00:12:48,470
constructor.

291
00:12:48,470 --> 00:12:51,130
You can't return something from
the constructor that's

292
00:12:51,130 --> 00:12:52,460
different than the
object itself.

293
00:12:52,460 --> 00:12:55,530

294
00:12:55,530 --> 00:12:57,760
And Dart also has operator
overloading.

295
00:12:57,760 --> 00:13:00,380
So we can make that Money class
a little easier to use

296
00:13:00,380 --> 00:13:03,200
by overwriting operator+
on it.

297
00:13:03,200 --> 00:13:06,260
And now you can just say
money+money instead of

298
00:13:06,260 --> 00:13:07,510
money.add(money).

299
00:13:07,510 --> 00:13:11,950

300
00:13:11,950 --> 00:13:15,350
And finally, Dart has
getters and setters.

301
00:13:15,350 --> 00:13:18,170
So this is a typical
POJO, Plain Old Job

302
00:13:18,170 --> 00:13:20,650
Object bean, in Java.

303
00:13:20,650 --> 00:13:23,120
And so we have a field called
Amount, so naturally we have

304
00:13:23,120 --> 00:13:25,690
to write an int get amount that
returns _amount, and a

305
00:13:25,690 --> 00:13:27,600
setter for it.

306
00:13:27,600 --> 00:13:30,010
And then on the bottom, you
see method calls from it.

307
00:13:30,010 --> 00:13:35,360
Whereas in Dart, what you can
do is you can put a get

308
00:13:35,360 --> 00:13:38,030
keyword in front of the function
name and a set

309
00:13:38,030 --> 00:13:39,770
keyword in front
of the setter.

310
00:13:39,770 --> 00:13:42,440
And then what happens is you can
reference the object as if

311
00:13:42,440 --> 00:13:45,070
those were field references,
not method calls.

312
00:13:45,070 --> 00:13:48,380
And Dart will actually invoke
the getter methods for you.

313
00:13:48,380 --> 00:13:51,450
So this is kind of a less
boilerplate-y way of setting

314
00:13:51,450 --> 00:13:57,360
up fields with getters and
setters or properties.

315
00:13:57,360 --> 00:14:03,520
Let's talk about the type
system differences.

316
00:14:03,520 --> 00:14:05,620
So there's really only five
built-in types you need to

317
00:14:05,620 --> 00:14:06,660
worry about.

318
00:14:06,660 --> 00:14:08,270
There are two numeric types.

319
00:14:08,270 --> 00:14:10,320
There's int and double.

320
00:14:10,320 --> 00:14:11,830
And yes, you're reading
that right.

321
00:14:11,830 --> 00:14:14,710
The integer is infinite
precision, so you never have

322
00:14:14,710 --> 00:14:18,120
to worry about overflow
in your code.

323
00:14:18,120 --> 00:14:20,406
If you want to compute--

324
00:14:20,406 --> 00:14:23,430
boy, don't try to compute
Google because

325
00:14:23,430 --> 00:14:24,050
you'll run out of memory.

326
00:14:24,050 --> 00:14:27,080
But if you want to compute a
very large number, you can use

327
00:14:27,080 --> 00:14:29,090
integers to do it.

328
00:14:29,090 --> 00:14:32,760
Doubles are 64-bit IEEE-754
goodness.

329
00:14:32,760 --> 00:14:36,260
Typically you might have a
game or a lot of math or

330
00:14:36,260 --> 00:14:38,530
physics code, and they're
great to use for that.

331
00:14:38,530 --> 00:14:39,500
Dart does have a String.

332
00:14:39,500 --> 00:14:41,200
Class It has a bool type--

333
00:14:41,200 --> 00:14:42,830
not Boolean, but bool.

334
00:14:42,830 --> 00:14:46,200
And it has two fundamental
collection types that

335
00:14:46,200 --> 00:14:49,210
everybody uses, hopefully,
which is List and Map.

336
00:14:49,210 --> 00:14:52,960
And like every other language
except for Java, they have

337
00:14:52,960 --> 00:14:54,000
first-class support.

338
00:14:54,000 --> 00:14:59,060
So there are literals
for maps and lists

339
00:14:59,060 --> 00:15:00,050
built into the language.

340
00:15:00,050 --> 00:15:02,500
So you define a List literal
with square brackets, and you

341
00:15:02,500 --> 00:15:06,160
define a map with curly braces,
much like JSON and

342
00:15:06,160 --> 00:15:08,540
JavaScript.

343
00:15:08,540 --> 00:15:10,490
There's some big differences
with strings

344
00:15:10,490 --> 00:15:12,250
between Java and Dart.

345
00:15:12,250 --> 00:15:17,580
String support interpolation
in Dart-- so you can put a

346
00:15:17,580 --> 00:15:21,470
dollar sign and then a variable
name inside of any

347
00:15:21,470 --> 00:15:25,580
string, and Dart will substitute
that with the

348
00:15:25,580 --> 00:15:29,210
variable of the same name that's
in the same scope.

349
00:15:29,210 --> 00:15:30,590
But you can go a little
bit further, too.

350
00:15:30,590 --> 00:15:31,900
You could put a curly brace.

351
00:15:31,900 --> 00:15:36,320
And for example, you can invoke
a method call on that.

352
00:15:36,320 --> 00:15:38,640
If this looks familiar to you,
it looks very much like the

353
00:15:38,640 --> 00:15:41,160
expression language that's often
in many Java frameworks,

354
00:15:41,160 --> 00:15:45,810
like JSP and JSS and things
like that, or like Apache

355
00:15:45,810 --> 00:15:48,210
property substitution.

356
00:15:48,210 --> 00:15:52,130
One of the features I love most,
actually, is heredocs,

357
00:15:52,130 --> 00:15:54,850
and Dart was very good
to add that.

358
00:15:54,850 --> 00:15:57,700
And it's basically multi-line
strings that you can include

359
00:15:57,700 --> 00:16:00,260
verbatim in the code.

360
00:16:00,260 --> 00:16:02,430
And that's really, really useful
if you want to bake in

361
00:16:02,430 --> 00:16:05,730
some HTML or some CSS into your
app, and you don't have

362
00:16:05,730 --> 00:16:09,040
to worry about going in and
escaping every new line and

363
00:16:09,040 --> 00:16:09,860
all the other kind of stuff.

364
00:16:09,860 --> 00:16:13,810
You can kind of structure
DSL-specific syntaxes right

365
00:16:13,810 --> 00:16:15,350
into your Dart source code,
just by putting

366
00:16:15,350 --> 00:16:17,370
in a multiline string.

367
00:16:17,370 --> 00:16:20,170
And if you don't want
interpolation, because maybe

368
00:16:20,170 --> 00:16:22,430
you want literal dollar signs,
just put an @ in front of the

369
00:16:22,430 --> 00:16:24,050
string, and it turns it
off for that string.

370
00:16:24,050 --> 00:16:26,610

371
00:16:26,610 --> 00:16:29,110
I don't want to say a
lot about generics.

372
00:16:29,110 --> 00:16:32,730
Dart does have generics, but
they are radically simplified

373
00:16:32,730 --> 00:16:34,590
generics, which is
a good thing.

374
00:16:34,590 --> 00:16:37,240
Because Java generics--

375
00:16:37,240 --> 00:16:39,900
I mean, if anybody's played
around in Scala, this sounds

376
00:16:39,900 --> 00:16:41,900
like somebody whining, but Java
generics are actually

377
00:16:41,900 --> 00:16:43,940
kind of complicated, and a lot
of people don't understand the

378
00:16:43,940 --> 00:16:47,120
difference between covariants,
invariants, contravariants,

379
00:16:47,120 --> 00:16:49,140
wild cards, and things
like that.

380
00:16:49,140 --> 00:16:51,420
And as a result, most people
don't even use those features.

381
00:16:51,420 --> 00:16:53,670
I mean, if you're Joshua Bloch,
you use them in the

382
00:16:53,670 --> 00:16:56,900
Java collections classes, but if
you go look at most regular

383
00:16:56,900 --> 00:16:59,040
Java programmers, they
hardly ever use most

384
00:16:59,040 --> 00:17:00,740
of these extra features.

385
00:17:00,740 --> 00:17:03,780
And so Dart basically said,
why add all this extra

386
00:17:03,780 --> 00:17:04,530
complexity?

387
00:17:04,530 --> 00:17:07,829
Most people would just use
Foo if T So Dart only has

388
00:17:07,829 --> 00:17:11,430
covariants for generics.

389
00:17:11,430 --> 00:17:13,819
But Dart does not use erasure.

390
00:17:13,819 --> 00:17:17,660
So generics in Dart are
actual reified.

391
00:17:17,660 --> 00:17:19,190
You can check the
runtime types.

392
00:17:19,190 --> 00:17:23,510
So a Foo or a list of int--
you can actually check

393
00:17:23,510 --> 00:17:25,250
it to see what it is.

394
00:17:25,250 --> 00:17:27,079
And if you try to say,
is this a foo of

395
00:17:27,079 --> 00:17:28,960
string, it will say false.

396
00:17:28,960 --> 00:17:31,920
That's not the case in Java,
where if you have a list of T,

397
00:17:31,920 --> 00:17:34,850
a list of anything, basically
it's only really a list, and

398
00:17:34,850 --> 00:17:38,020
you actually cannot check
what it is at runtime.

399
00:17:38,020 --> 00:17:39,530
But in general, I would
say, don't worry

400
00:17:39,530 --> 00:17:40,890
too much about this.

401
00:17:40,890 --> 00:17:44,700
Things just kind of work, and
you don't have to worry too

402
00:17:44,700 --> 00:17:46,090
much about it.

403
00:17:46,090 --> 00:17:48,710
Generics in Dart are simple and
they work out of the box.

404
00:17:48,710 --> 00:17:53,310
And don't get yourself worried
about what's being left out.

405
00:17:53,310 --> 00:17:56,810

406
00:17:56,810 --> 00:17:58,920
The other-- and I want to say
the third favorite feature of

407
00:17:58,920 --> 00:18:03,080
mine is finally lexically
scoped closures.

408
00:18:03,080 --> 00:18:04,440
I wish Java had them.

409
00:18:04,440 --> 00:18:06,020
I wish Java 8 will have them.

410
00:18:06,020 --> 00:18:06,690
Hopefully they will.

411
00:18:06,690 --> 00:18:09,340
But yes.

412
00:18:09,340 --> 00:18:11,810
Bye-bye, anonymous classes,
and hello function types.

413
00:18:11,810 --> 00:18:14,630
So here is an example of
an apply function.

414
00:18:14,630 --> 00:18:16,760
It takes a list of integers and
applies the function to

415
00:18:16,760 --> 00:18:18,620
each thing in the list and
returns a new list.

416
00:18:18,620 --> 00:18:21,670
And so at the bottom I just
show a simple example.

417
00:18:21,670 --> 00:18:26,780
Apply an inline literal list of
1, 2, 3, 4, 5, a function

418
00:18:26,780 --> 00:18:29,280
which basically doubles
its input.

419
00:18:29,280 --> 00:18:35,840
So what you do to declare a
closure is you basically put

420
00:18:35,840 --> 00:18:39,135
the parameters in parentheses
with optional types, and then

421
00:18:39,135 --> 00:18:42,590
you put =>, and then the
expression to be evaluated,

422
00:18:42,590 --> 00:18:43,270
the function body.

423
00:18:43,270 --> 00:18:45,280
You can use curly braces
there too if you want.

424
00:18:45,280 --> 00:18:50,020

425
00:18:50,020 --> 00:18:51,990
And you can make things a
little bit more readable

426
00:18:51,990 --> 00:18:53,270
because Dart has typedefs.

427
00:18:53,270 --> 00:18:56,220
So often, these function
declarations, if they're

428
00:18:56,220 --> 00:18:58,440
really complicated and take a
lot of parameters-- maybe have

429
00:18:58,440 --> 00:19:00,550
a function which takes functions
to functions, and

430
00:19:00,550 --> 00:19:02,250
things like that--

431
00:19:02,250 --> 00:19:04,060
you want to break them down
into separate steps.

432
00:19:04,060 --> 00:19:05,700
And with typedefs,
you can do that.

433
00:19:05,700 --> 00:19:11,070
So here I'm basically saying
that there is a function that

434
00:19:11,070 --> 00:19:14,705
takes an int and returns an int,
and I'm going to give it

435
00:19:14,705 --> 00:19:16,660
the name Transformer.

436
00:19:16,660 --> 00:19:19,860
And then my apply function
now, rather than saying--

437
00:19:19,860 --> 00:19:24,850
if you look at the previous
slide, it's int f(int arg))

438
00:19:24,850 --> 00:19:26,630
Now this says Transformer bay.

439
00:19:26,630 --> 00:19:29,370

440
00:19:29,370 --> 00:19:31,820
Maybe some of you get the
reference to that.

441
00:19:31,820 --> 00:19:33,750
And so then at the bottom, I
have another one where I say

442
00:19:33,750 --> 00:19:35,000
Transformer prime
= (x) => 2 * x.

443
00:19:35,000 --> 00:19:38,140

444
00:19:38,140 --> 00:19:40,750
And so it looks a little
more readable.

445
00:19:40,750 --> 00:19:44,220
You can document the typedef
and things like that.

446
00:19:44,220 --> 00:19:49,025
OK so that kind of covers the
language syntax case.

447
00:19:49,025 --> 00:19:51,940
Now I'm going to cover just some
of the API differences.

448
00:19:51,940 --> 00:19:55,140
So Dart has two collection
classes, as I mentioned

449
00:19:55,140 --> 00:19:57,620
before, and they
are generified.

450
00:19:57,620 --> 00:19:59,930
That's List and Map.

451
00:19:59,930 --> 00:20:02,670
And so in Dart, you can create
them in two ways.

452
00:20:02,670 --> 00:20:06,670
You can new them, with the new
operator, or you can construct

453
00:20:06,670 --> 00:20:09,840
them inline with literals,
which a lot of people do.

454
00:20:09,840 --> 00:20:13,810
That's a very common
thing to do.

455
00:20:13,810 --> 00:20:15,970
And you don't actually have to
worry about the underlying

456
00:20:15,970 --> 00:20:16,900
concrete types.

457
00:20:16,900 --> 00:20:19,470
So Map and List will be abstract
classes and there

458
00:20:19,470 --> 00:20:21,370
might be multiple
implementations of Map and

459
00:20:21,370 --> 00:20:22,960
List, but Dart will
pick a default

460
00:20:22,960 --> 00:20:23,770
implementation for you.

461
00:20:23,770 --> 00:20:26,170
In Java, you have to think,
am I going to use HashMap?

462
00:20:26,170 --> 00:20:27,940
Am I going to use
LinkedHashMap?

463
00:20:27,940 --> 00:20:30,260
And things like that.

464
00:20:30,260 --> 00:20:31,110
And then iteration--

465
00:20:31,110 --> 00:20:32,410
you have multiple
choices, right?

466
00:20:32,410 --> 00:20:35,170
So you can use what's called
external iteration, where you

467
00:20:35,170 --> 00:20:37,900
basically have your own for
loop, you ask for the length

468
00:20:37,900 --> 00:20:40,530
of the list, and you iterate
over it and you index into it

469
00:20:40,530 --> 00:20:42,670
like an array, like List[i].

470
00:20:42,670 --> 00:20:45,470
No operator overloading to
access list members.

471
00:20:45,470 --> 00:20:48,760
You don't have to
say List.get(i).

472
00:20:48,760 --> 00:20:51,930
Or you could use the
For In operators.

473
00:20:51,930 --> 00:20:53,180
You could say for (value
in list) {doSomething}.

474
00:20:53,180 --> 00:20:55,350

475
00:20:55,350 --> 00:20:59,900
Or you can use an internal
iterator, which is basically,

476
00:20:59,900 --> 00:21:02,970
you pass a closure to the
forEach method, and it will

477
00:21:02,970 --> 00:21:05,410
loop over the collection
internally and call your

478
00:21:05,410 --> 00:21:07,640
function for each member
of the list.

479
00:21:07,640 --> 00:21:10,580
And then there's equivalent
methods for Map.

480
00:21:10,580 --> 00:21:13,750
It's just that they take two
parameters for the forEach

481
00:21:13,750 --> 00:21:16,550
method, key and value, or you
have to get the set of keys

482
00:21:16,550 --> 00:21:20,110
and the set of values
to iterate over.

483
00:21:20,110 --> 00:21:20,320
All right.

484
00:21:20,320 --> 00:21:23,275
So now let's actually move on
to converting the actual GWT

485
00:21:23,275 --> 00:21:25,240
code over to Dart.

486
00:21:25,240 --> 00:21:28,690
And so let's first convert
a really simple example.

487
00:21:28,690 --> 00:21:30,600
Here's a "Hello World" in GWT.

488
00:21:30,600 --> 00:21:32,740
You have the onModuleLoad
function, and I'm going to

489
00:21:32,740 --> 00:21:35,000
call window.alert("Hello
World").

490
00:21:35,000 --> 00:21:38,430
What would this look
like in Dart?

491
00:21:38,430 --> 00:21:39,790
Really, really compact.

492
00:21:39,790 --> 00:21:43,140
So first thing is we import the
Dart HTML library so we

493
00:21:43,140 --> 00:21:46,700
can get the window function,
the alert function.

494
00:21:46,700 --> 00:21:50,410
Secondly, Dart's EntryPoint,
is the main function.

495
00:21:50,410 --> 00:21:51,580
So--

496
00:21:51,580 --> 00:21:53,280
whoops--

497
00:21:53,280 --> 00:21:53,910
what?

498
00:21:53,910 --> 00:21:56,230
There we go.

499
00:21:56,230 --> 00:21:58,860
Let me restart.

500
00:21:58,860 --> 00:22:02,590
I don't know why
that happened.

501
00:22:02,590 --> 00:22:03,840
Let's go back.

502
00:22:03,840 --> 00:22:12,090

503
00:22:12,090 --> 00:22:13,580
I have a lot of slides.

504
00:22:13,580 --> 00:22:16,020
OK.

505
00:22:16,020 --> 00:22:17,610
There we go.

506
00:22:17,610 --> 00:22:18,400
This one.

507
00:22:18,400 --> 00:22:21,230
And so if you look at this, you
have to declare a class.

508
00:22:21,230 --> 00:22:22,100
You have to implement
EntryPoint.

509
00:22:22,100 --> 00:22:24,070
You have to have an onModuleLoad
function with

510
00:22:24,070 --> 00:22:25,490
access qualifiers.

511
00:22:25,490 --> 00:22:27,400
And then you call
window.alert.

512
00:22:27,400 --> 00:22:29,510
Here you just declare a main
function and that basically

513
00:22:29,510 --> 00:22:32,270
runs whatever code
is specified.

514
00:22:32,270 --> 00:22:35,490
But a lot of times people are
going to structure a little

515
00:22:35,490 --> 00:22:37,590
more, because you don't want
everything running in main.

516
00:22:37,590 --> 00:22:40,620
So people might decide
to declare a class.

517
00:22:40,620 --> 00:22:43,480
So here I have a class called
Hello, and my equivalent of

518
00:22:43,480 --> 00:22:45,745
onModuleLoad is the
go function.

519
00:22:45,745 --> 00:22:48,290
And from main, I just
create that Hello

520
00:22:48,290 --> 00:22:49,558
instance and invoke go.

521
00:22:49,558 --> 00:22:52,630

522
00:22:52,630 --> 00:22:56,360
So this is a really important
point right now.

523
00:22:56,360 --> 00:22:59,300
So you know, Dart is
bleeding edge.

524
00:22:59,300 --> 00:23:02,130
And we're working hard on
it, and we're working

525
00:23:02,130 --> 00:23:02,980
as fast as we can.

526
00:23:02,980 --> 00:23:06,440
But we don't yet have a widget
library in the SDK that you

527
00:23:06,440 --> 00:23:07,360
can download today.

528
00:23:07,360 --> 00:23:08,810
One will be available soon.

529
00:23:08,810 --> 00:23:11,140
If you've seen some of the other
demos, like the Swarm

530
00:23:11,140 --> 00:23:12,890
app, there's some really
slick stuff going on.

531
00:23:12,890 --> 00:23:16,240
And that knowledge will
translate into an awesome

532
00:23:16,240 --> 00:23:17,340
widget library.

533
00:23:17,340 --> 00:23:19,780
But for now, we just have
DOM programming.

534
00:23:19,780 --> 00:23:24,360
And so I'm going to compare GWT
DOM program versus Dart

535
00:23:24,360 --> 00:23:24,800
DOM programming.

536
00:23:24,800 --> 00:23:28,200
So here is an example.

537
00:23:28,200 --> 00:23:31,490
I might have a div tag with
ID "button" in the HTML.

538
00:23:31,490 --> 00:23:34,100
So I'm going to add an
EventListener, a click

539
00:23:34,100 --> 00:23:36,910
EventListener, to
that div tag.

540
00:23:36,910 --> 00:23:38,990
And so here's the GWT
code that you have

541
00:23:38,990 --> 00:23:40,020
to write to do that.

542
00:23:40,020 --> 00:23:42,850
So you have to look it up by
going Document.get, which gets

543
00:23:42,850 --> 00:23:43,480
the document element.

544
00:23:43,480 --> 00:23:45,470
Then getElementByID
and the button.

545
00:23:45,470 --> 00:23:47,790
Then you have to sink the event
type event you want to

546
00:23:47,790 --> 00:23:50,790
listen to, so you use
DOM.sinkEvents.

547
00:23:50,790 --> 00:23:53,050
Then you have to set the
EventListener callback,

548
00:23:53,050 --> 00:23:56,610
DOM.setEventListener, and have
an anonymous inner class

549
00:23:56,610 --> 00:24:00,150
callback with a function
declared in it, which then has

550
00:24:00,150 --> 00:24:02,210
window.alert.

551
00:24:02,210 --> 00:24:05,320
So what would that look
like in Dart?

552
00:24:05,320 --> 00:24:10,040
You just say Query
("#ID").on.click.add and then

553
00:24:10,040 --> 00:24:11,655
a closure for the
EventHandler.

554
00:24:11,655 --> 00:24:12,770
Now there's a couple
of interesting

555
00:24:12,770 --> 00:24:13,870
things going on here.

556
00:24:13,870 --> 00:24:18,080
First of all, Dart has global
functions, and so not every

557
00:24:18,080 --> 00:24:19,830
method has to be part
of a class.

558
00:24:19,830 --> 00:24:24,105
So there's a global top-level
query function, and basically

559
00:24:24,105 --> 00:24:26,360
it kind of acts like the
dollar-sign function in

560
00:24:26,360 --> 00:24:27,720
jQuery, if you want to think
of it like that.

561
00:24:27,720 --> 00:24:31,530
So I'm looking up the button
with ID "button." And I'm

562
00:24:31,530 --> 00:24:32,870
going to get back an element.

563
00:24:32,870 --> 00:24:36,310
Now the element going to have a
magic field in it called on.

564
00:24:36,310 --> 00:24:39,410
And on is going to have a bunch
of setter properties--

565
00:24:39,410 --> 00:24:41,310
like I showed you setters
earlier--

566
00:24:41,310 --> 00:24:42,310
for each type of event.

567
00:24:42,310 --> 00:24:45,100
So here we've got one
called click--

568
00:24:45,100 --> 00:24:45,580
a setter.

569
00:24:45,580 --> 00:24:48,510
We've got one called mouseOver
and things like that.

570
00:24:48,510 --> 00:24:51,040
And each one of those is going
to have an add method on it.

571
00:24:51,040 --> 00:24:54,030
And so now, I'm just saying--

572
00:24:54,030 --> 00:24:58,790
for the element that I got back,
on click, give me back

573
00:24:58,790 --> 00:25:02,710
this click thing, which can then
allow me to add a closure

574
00:25:02,710 --> 00:25:04,600
to it, which will be called.

575
00:25:04,600 --> 00:25:07,090
And so that's basically how you
would write the same code.

576
00:25:07,090 --> 00:25:08,375
You look at it again--

577
00:25:08,375 --> 00:25:11,530

578
00:25:11,530 --> 00:25:12,780
it looks a lot more readable.

579
00:25:12,780 --> 00:25:16,570

580
00:25:16,570 --> 00:25:19,970
So that's basically converting
a Hello World and some simple

581
00:25:19,970 --> 00:25:21,160
DOM programming.

582
00:25:21,160 --> 00:25:23,980
This is kind of where
Dart is today.

583
00:25:23,980 --> 00:25:26,270
As I said, there's high-level
libraries that are on the way

584
00:25:26,270 --> 00:25:28,040
real soon now.

585
00:25:28,040 --> 00:25:30,510
But for now, it's really an
HTML5 experience, which is not

586
00:25:30,510 --> 00:25:31,980
always the worst thing.

587
00:25:31,980 --> 00:25:36,400
But here's the sort of
high-level mapping of what API

588
00:25:36,400 --> 00:25:38,200
in GWT corresponds to what
you have to do in Dart.

589
00:25:38,200 --> 00:25:40,790
So if you're using
com.google.gwt.dom, you're

590
00:25:40,790 --> 00:25:43,320
going to import the
dart:html library.

591
00:25:43,320 --> 00:25:46,790
If you're using UIBinder and
SafeHTMLTemplates and

592
00:25:46,790 --> 00:25:49,880
[INAUDIBLE] messages from GWT,
you're probably just going to

593
00:25:49,880 --> 00:25:53,080
use Dart string interpolation
to do the same thing.

594
00:25:53,080 --> 00:25:56,295
If you're doing server
communication, like GWT RPC or

595
00:25:56,295 --> 00:25:58,810
Request Factory, in Dart, right
now, today, you're going

596
00:25:58,810 --> 00:26:01,130
to use XMLHttpRequest.

597
00:26:01,130 --> 00:26:03,970
For widgets, of course,
GWT has widgets.

598
00:26:03,970 --> 00:26:05,530
For Dart, real soon now
there's going to

599
00:26:05,530 --> 00:26:06,910
be some cool stuff.

600
00:26:06,910 --> 00:26:13,300
And in multi-process, for using
WebWorkers, GWT has some

601
00:26:13,300 --> 00:26:16,450
third-party hacks that add
WebWorker support to GWT.

602
00:26:16,450 --> 00:26:20,670
Dart actually has WebWorkers
built in to the language as a

603
00:26:20,670 --> 00:26:23,890
first-class construct.

604
00:26:23,890 --> 00:26:25,470
They're called isolates.

605
00:26:25,470 --> 00:26:29,710
And so doing multi-process stuff
within Dart really has

606
00:26:29,710 --> 00:26:30,240
no equal anywhere.

607
00:26:30,240 --> 00:26:34,130
They make it really
easy to use.

608
00:26:34,130 --> 00:26:36,480
So let's try to get a little
more deeper and port something

609
00:26:36,480 --> 00:26:37,040
more complex.

610
00:26:37,040 --> 00:26:38,360
Let's try to port a widget.

611
00:26:38,360 --> 00:26:41,252

612
00:26:41,252 --> 00:26:43,905
Now widgets are written in many
different ways in GWT.

613
00:26:43,905 --> 00:26:46,726
I'm just going to focus on the
modern way people do widgets

614
00:26:46,726 --> 00:26:49,280
with GWT, which is
with UIBinder.

615
00:26:49,280 --> 00:26:52,810
And so the idea here is just
how can I take a GWT widget

616
00:26:52,810 --> 00:26:56,320
that I've written that uses
UIBinder to define its HTML

617
00:26:56,320 --> 00:26:59,825
structure and port that
over to Dart?

618
00:26:59,825 --> 00:27:02,450
And the general idea here is
just to take the UIBinder

619
00:27:02,450 --> 00:27:06,440
template and enclose it in
a multi-line string.

620
00:27:06,440 --> 00:27:11,090
Convert any of the ui:field
attributes to just be ID

621
00:27:11,090 --> 00:27:12,770
attributes on the elements.

622
00:27:12,770 --> 00:27:16,030
Then build a Dart class to
represent normally what GWT

623
00:27:16,030 --> 00:27:18,940
would generate to bind that
template, which is basically

624
00:27:18,940 --> 00:27:21,605
looking up the IDs and assigning
them to fields in

625
00:27:21,605 --> 00:27:23,070
your object.

626
00:27:23,070 --> 00:27:25,410
And then you'll have to
basically move the raw HTML

627
00:27:25,410 --> 00:27:30,330
resources, like CssResource, to
be external CSS by using a

628
00:27:30,330 --> 00:27:33,040
link tag to include the CSS.

629
00:27:33,040 --> 00:27:37,330
It's not a perfect solution, but
it's not horribly bad to

630
00:27:37,330 --> 00:27:38,440
port code like this.

631
00:27:38,440 --> 00:27:41,810
So here's an example.

632
00:27:41,810 --> 00:27:43,170
This is how it looks in Java.

633
00:27:43,170 --> 00:27:45,455
I have a UIBinder template
with a div tag.

634
00:27:45,455 --> 00:27:49,580
It says, Hello, <span ui:
field = 'nameSpan' /> .

635
00:27:49,580 --> 00:27:53,710
And then here I have a little
bit of code which basically

636
00:27:53,710 --> 00:27:57,930
calls setElement(UIBin
der.CreateandBindUi(this)).

637
00:27:57,930 --> 00:27:59,230
Now if you're GWT programmer,
you know

638
00:27:59,230 --> 00:28:00,920
this works some magic.

639
00:28:00,920 --> 00:28:04,690
And what happens is, is it
basically generates some code

640
00:28:04,690 --> 00:28:09,600
behind the scenes that will take
that UIBinder template,

641
00:28:09,600 --> 00:28:13,820
create a div tag, and inject
that HTML source, as an inner

642
00:28:13,820 --> 00:28:15,240
HTML, into it.

643
00:28:15,240 --> 00:28:16,840
And put it into the document.

644
00:28:16,840 --> 00:28:19,190
And then the next thing it will
do is it will go through

645
00:28:19,190 --> 00:28:21,060
and it will look up
that field, that

646
00:28:21,060 --> 00:28:23,730
UI field, the nameSpan.

647
00:28:23,730 --> 00:28:25,980
And when it finds that element,
it will store it in

648
00:28:25,980 --> 00:28:27,020
the field on your class.

649
00:28:27,020 --> 00:28:30,970
You can see here, this
nameSpan attribute.

650
00:28:30,970 --> 00:28:33,420
So this element will be looked
up in the DOM with

651
00:28:33,420 --> 00:28:36,940
getElementById and then
put there for you.

652
00:28:36,940 --> 00:28:38,810
So kind of like a dependency
injection.

653
00:28:38,810 --> 00:28:40,490
So we want to get
that into Dart.

654
00:28:40,490 --> 00:28:42,240
So how can we emulate that?

655
00:28:42,240 --> 00:28:45,340
So the first thing is, we remove
the top and bottom XML

656
00:28:45,340 --> 00:28:46,410
tags and replace them
with triple-quote.

657
00:28:46,410 --> 00:28:50,890
And so now we've just put it
into a multi-line string.

658
00:28:50,890 --> 00:28:56,530
And we replace the ui:field
with just id='nameSpan'.

659
00:28:56,530 --> 00:29:01,100
And then secondly, the next step
that we'd do is we would

660
00:29:01,100 --> 00:29:02,430
write a function--

661
00:29:02,430 --> 00:29:04,620
that you can see right here--

662
00:29:04,620 --> 00:29:11,440
which will first create a new
HTML element with the

663
00:29:11,440 --> 00:29:13,810
template, which we
defined up here.

664
00:29:13,810 --> 00:29:18,100
And what this new Element.html
does is it actually kind of

665
00:29:18,100 --> 00:29:21,570
creates a div and injects the
string as the innerHTML of it.

666
00:29:21,570 --> 00:29:24,390
So what you get back, basically,
is essentially what

667
00:29:24,390 --> 00:29:27,170
UIBinder was doing as a div
element with the HTML in it.

668
00:29:27,170 --> 00:29:32,250
And then once we get that, we
input it into the DOM, the

669
00:29:32,250 --> 00:29:35,620
next thing we're going to do is
run element.query on it and

670
00:29:35,620 --> 00:29:39,440
look up id nameSpan and then
assign it to the field

671
00:29:39,440 --> 00:29:40,620
nameSpan here.

672
00:29:40,620 --> 00:29:44,290
So GWT kind of automates that
part of it, which is

673
00:29:44,290 --> 00:29:46,310
automatically looking up the
element for you and then

674
00:29:46,310 --> 00:29:46,970
signing it.

675
00:29:46,970 --> 00:29:49,950
So you actually have to write
that code yourself here, but

676
00:29:49,950 --> 00:29:51,950
it's not too bad.

677
00:29:51,950 --> 00:29:54,720
But you could make it
expandable, extensible.

678
00:29:54,720 --> 00:29:59,170
So here I have one where we have
two nameSpan tags in my

679
00:29:59,170 --> 00:30:03,245
template and I would have
two fields, like a

680
00:30:03,245 --> 00:30:04,590
nameSpan1 and a nameSpan2.

681
00:30:04,590 --> 00:30:08,150
Instead of having fields on my
object, I use a map, a map

682
00:30:08,150 --> 00:30:11,950
from the id to the element.

683
00:30:11,950 --> 00:30:15,370
And then what I do is I extend
my setElementByTemplate

684
00:30:15,370 --> 00:30:18,690
function to take the template,
which was from up here, and

685
00:30:18,690 --> 00:30:23,610
take a list of ids to look
up, which were up here.

686
00:30:23,610 --> 00:30:25,340
And then what this is going to
do is it's going to inject

687
00:30:25,340 --> 00:30:29,080
this and then document.query
look up each one of those and

688
00:30:29,080 --> 00:30:30,480
inject them into
the map for me.

689
00:30:30,480 --> 00:30:33,330
And that's what this basically
does here.

690
00:30:33,330 --> 00:30:38,490
It loops over for each ID and
then it injects into the map,

691
00:30:38,490 --> 00:30:41,760
calling element.query
with the id.

692
00:30:41,760 --> 00:30:44,735
And so that's a way to sort
of make it extensible.

693
00:30:44,735 --> 00:30:47,700
So you could have an arbitrary
number of elements that are

694
00:30:47,700 --> 00:30:51,390
looked up and automatically
injected for you, so you can

695
00:30:51,390 --> 00:30:55,170
cache them and look
them up later.

696
00:30:55,170 --> 00:30:57,050
What about instantiated widgets,
though, right?

697
00:30:57,050 --> 00:30:59,790
So I just showed you
HTML tags that

698
00:30:59,790 --> 00:31:01,030
are in UIBinder templates.

699
00:31:01,030 --> 00:31:02,340
But you know that GWT
does a lot more.

700
00:31:02,340 --> 00:31:06,290
So for example, you might use
HTMLPanel, or Menu item, or

701
00:31:06,290 --> 00:31:08,090
Tree item, and things
like that.

702
00:31:08,090 --> 00:31:12,460
Well, if it's a basic leaf
widget in GWT, like an input,

703
00:31:12,460 --> 00:31:16,280
or a checkbox, or a text area,
or something, you can just

704
00:31:16,280 --> 00:31:19,030
replace those with the
HTML5 equivalents.

705
00:31:19,030 --> 00:31:21,710
In fact for GWT, even, we
recommend actually not using

706
00:31:21,710 --> 00:31:25,650
heavyweight widgets for stuff
that's just basic HTML5.

707
00:31:25,650 --> 00:31:28,270
It's just too much overhead.

708
00:31:28,270 --> 00:31:31,030
But if you have something like a
composite type that's really

709
00:31:31,030 --> 00:31:35,170
complex, like a menu
or a tree--

710
00:31:35,170 --> 00:31:37,430
yes, right now, you're going
to actually need to code

711
00:31:37,430 --> 00:31:38,470
replacements.

712
00:31:38,470 --> 00:31:40,090
The good news is you're only
going to do it once, but yeah,

713
00:31:40,090 --> 00:31:41,630
you're going to have to write
your own tree for now.

714
00:31:41,630 --> 00:31:45,430
And I expect that as Dart gets a
larger and larger community,

715
00:31:45,430 --> 00:31:49,590
even if Dart provides its own
widget library, probably other

716
00:31:49,590 --> 00:31:50,490
people are going to
write their own

717
00:31:50,490 --> 00:31:51,340
widget libraries too.

718
00:31:51,340 --> 00:31:55,360
Someone will have a fancy tree
or a fancy carousel widget or

719
00:31:55,360 --> 00:31:57,740
something that is not included
in the library.

720
00:31:57,740 --> 00:32:04,500
So for now, it's an HTML
experience, but things will

721
00:32:04,500 --> 00:32:05,100
get better.

722
00:32:05,100 --> 00:32:09,410
But if you think it's too hard
to port widgets, then there's

723
00:32:09,410 --> 00:32:12,960
an alternate pattern that
you can use to get your

724
00:32:12,960 --> 00:32:13,730
feet wet with Dart.

725
00:32:13,730 --> 00:32:19,710
Let's say you have an existing
GWT application and you want

726
00:32:19,710 --> 00:32:20,830
to kind of try out Dart.

727
00:32:20,830 --> 00:32:21,980
Maybe you want to write
a new page.

728
00:32:21,980 --> 00:32:24,780
You want to add a new page to
your application, like a

729
00:32:24,780 --> 00:32:28,610
settings screen or like a
feedback page or something.

730
00:32:28,610 --> 00:32:31,240
And you want to write that part
in Dart, but the entire

731
00:32:31,240 --> 00:32:32,550
rest of the part, you
want to keep in GWT.

732
00:32:32,550 --> 00:32:34,210
So you want to keep your
application running at all

733
00:32:34,210 --> 00:32:38,070
times and not throw everything
away and start from scratch.

734
00:32:38,070 --> 00:32:40,630
The good news is that if you use
the Activities and Places

735
00:32:40,630 --> 00:32:43,550
model that's been in GWT for a
while, or if you've always

736
00:32:43,550 --> 00:32:48,060
been using history tag routing,
then you could do

737
00:32:48,060 --> 00:32:49,240
this quite easily.

738
00:32:49,240 --> 00:32:51,220
And the way you could
do it is this.

739
00:32:51,220 --> 00:32:55,150
You have your GWT application
look for history state changes

740
00:32:55,150 --> 00:32:56,380
in the hashtag.

741
00:32:56,380 --> 00:32:59,370
And if the history change is
one of the things that your

742
00:32:59,370 --> 00:33:03,440
app understands, then route the
event to the existing GWT

743
00:33:03,440 --> 00:33:05,510
code that's going to
put up that page.

744
00:33:05,510 --> 00:33:08,300
But if it's something you don't
understand, then send a

745
00:33:08,300 --> 00:33:12,390
message or let it fall through
to a Dart application that's

746
00:33:12,390 --> 00:33:13,540
running in the same page.

747
00:33:13,540 --> 00:33:15,770
So you've source-scripted in the
GWT module and you've also

748
00:33:15,770 --> 00:33:17,810
source-scripted in your Dart
app, and they're both looking

749
00:33:17,810 --> 00:33:19,060
at the history.

750
00:33:19,060 --> 00:33:21,800
And if they agree not to step
on each other's toes, this

751
00:33:21,800 --> 00:33:22,580
could work very well.

752
00:33:22,580 --> 00:33:24,540
The Dart code could look at
it and go, well, I don't

753
00:33:24,540 --> 00:33:28,100
understand that history tag, so
GWT can probably take care

754
00:33:28,100 --> 00:33:28,700
of that one.

755
00:33:28,700 --> 00:33:31,060
But I see one that's destined
for me, like the feedback

756
00:33:31,060 --> 00:33:35,110
page, the new feedback page, so
I'm basically going to take

757
00:33:35,110 --> 00:33:38,650
over the main content
area of the page and

758
00:33:38,650 --> 00:33:40,810
replace it with my UI.

759
00:33:40,810 --> 00:33:41,580
Right?

760
00:33:41,580 --> 00:33:48,210
And so that gives you kind of a
very high-level integration

761
00:33:48,210 --> 00:33:51,100
point for putting Dart pages
into your existing GWT apps.

762
00:33:51,100 --> 00:33:53,800

763
00:33:53,800 --> 00:33:56,200
You could migrate page
at a time that way.

764
00:33:56,200 --> 00:33:58,720
Here's a picture, like you
might have a banking

765
00:33:58,720 --> 00:34:00,510
application.

766
00:34:00,510 --> 00:34:03,090
And so maybe you have an
existing bill payment service,

767
00:34:03,090 --> 00:34:06,180
and #billpay on the URL will
send you to the bill pay

768
00:34:06,180 --> 00:34:08,355
activity in the GWT app.

769
00:34:08,355 --> 00:34:11,010
But you're adding a new page,
which is banking, like maybe

770
00:34:11,010 --> 00:34:12,199
bank transfers.

771
00:34:12,199 --> 00:34:14,080
And so you've written
that one in Dart.

772
00:34:14,080 --> 00:34:17,970
So what you do is you just have
the Dart part of the app

773
00:34:17,970 --> 00:34:20,900
that's sitting in the page look
for #banking in the URL.

774
00:34:20,900 --> 00:34:24,199
And that's the signal for it
to actually take over the

775
00:34:24,199 --> 00:34:28,750
content area and install
its view.

776
00:34:28,750 --> 00:34:30,800
But if you do this, the very
next thing you're going to run

777
00:34:30,800 --> 00:34:33,040
into is, how do you share
application state?

778
00:34:33,040 --> 00:34:36,570
I mean, maybe the GWT app just
did something and now the Dart

779
00:34:36,570 --> 00:34:39,139
app actually has to get
what was changed.

780
00:34:39,139 --> 00:34:42,650
And so there are a number
of options for this.

781
00:34:42,650 --> 00:34:45,460
One option is, use
browser storage.

782
00:34:45,460 --> 00:34:50,060
So you could use IndexDB,
SessionStorage, or cookies and

783
00:34:50,060 --> 00:34:54,639
have GWT commit transient
session-oriented data, let's

784
00:34:54,639 --> 00:34:58,360
say the current account or
profile representing the user.

785
00:34:58,360 --> 00:35:01,260
Have it committed to IndexDB
storage in the browser.

786
00:35:01,260 --> 00:35:03,740
And then when Dart goes to kick
off its view, like you

787
00:35:03,740 --> 00:35:08,950
navigate to the banking page,
then it's going to read from

788
00:35:08,950 --> 00:35:11,980
the database and get things
related to the user, like his

789
00:35:11,980 --> 00:35:14,720
name, his current account,
authentication tokens to let

790
00:35:14,720 --> 00:35:17,090
him make transfers, and
things like that.

791
00:35:17,090 --> 00:35:19,610
The other option is, you could
put serialized data objects

792
00:35:19,610 --> 00:35:20,790
into the DOM.

793
00:35:20,790 --> 00:35:25,720
So if you want Dart to pick up
something that GWT has to send

794
00:35:25,720 --> 00:35:27,950
to it, one option is just create
an element, like a div

795
00:35:27,950 --> 00:35:31,240
element, use display none, and
put some data in there.

796
00:35:31,240 --> 00:35:34,660
And then give it an
id, like an id =

797
00:35:34,660 --> 00:35:35,780
data object or something.

798
00:35:35,780 --> 00:35:37,810
And then just have Dart
look it up and parse

799
00:35:37,810 --> 00:35:38,890
the JSON out of it.

800
00:35:38,890 --> 00:35:40,950
That's another option.

801
00:35:40,950 --> 00:35:43,150
Probably the cleanest mechanism

802
00:35:43,150 --> 00:35:44,370
is just to use messaging.

803
00:35:44,370 --> 00:35:47,480
So in the new HTML5 browsers.
you have window.postMessage().

804
00:35:47,480 --> 00:35:49,070
So you can use this
for communication

805
00:35:49,070 --> 00:35:50,170
between GWT and Dart.

806
00:35:50,170 --> 00:35:52,630
Have Dart listen on window
object for messages and just

807
00:35:52,630 --> 00:35:55,580
have GWT post messages, so you
can transfer data back and

808
00:35:55,580 --> 00:36:01,130
forth between the two running
apps that way.

809
00:36:01,130 --> 00:36:05,230
So one thing, as a GWT
programmer, you're probably

810
00:36:05,230 --> 00:36:08,820
wondering about is something
like JSNI.

811
00:36:08,820 --> 00:36:11,190
And we got a lot of mileage
out of that with GWT.

812
00:36:11,190 --> 00:36:14,880
Early on in GWT's adoption,
there were a lot of JavaScript

813
00:36:14,880 --> 00:36:15,690
libraries out there.

814
00:36:15,690 --> 00:36:17,690
We didn't have really
killer widgets.

815
00:36:17,690 --> 00:36:19,780
GWT widgets really looked
terrible out of the box.

816
00:36:19,780 --> 00:36:22,540
And so people we're going and
picking up jQuery or picking

817
00:36:22,540 --> 00:36:24,080
up Ext JS and things like
that and they were

818
00:36:24,080 --> 00:36:25,630
wrapping them with GWT.

819
00:36:25,630 --> 00:36:28,150
And that really held people over
until we could actually

820
00:36:28,150 --> 00:36:29,960
deliver better widgets
in later versions.

821
00:36:29,960 --> 00:36:32,450
And so you might be thinking,
well I'll do that for Dart.

822
00:36:32,450 --> 00:36:36,110
I'll use Dart and I'll wrap some
cool widgets until the

823
00:36:36,110 --> 00:36:38,270
Dart team delivers the
better widget set.

824
00:36:38,270 --> 00:36:41,910
Unfortunately, Dart does
not have JSNI.

825
00:36:41,910 --> 00:36:43,900
And there's a very good
reason for that.

826
00:36:43,900 --> 00:36:46,880
And so you might think of
Dart as it is today as

827
00:36:46,880 --> 00:36:48,800
a Dart-to-JS compiler.

828
00:36:48,800 --> 00:36:52,760
But Dart as it's envisioned is
actually a virtual machine

829
00:36:52,760 --> 00:36:56,720
that runs just like V8 does,
but it runs Dart code.

830
00:36:56,720 --> 00:36:58,810
And so because it's another
virtual machine in the

831
00:36:58,810 --> 00:37:00,320
browser, it's separate
from V8.

832
00:37:00,320 --> 00:37:01,500
It has a separate heap.

833
00:37:01,500 --> 00:37:03,920
So you can't just pass an object
reference from one to

834
00:37:03,920 --> 00:37:06,160
the other, because they live
in different memory spaces.

835
00:37:06,160 --> 00:37:08,030
Probably even different
process sandboxes.

836
00:37:08,030 --> 00:37:12,000
So that wouldn't be very
efficient, even if you could

837
00:37:12,000 --> 00:37:14,530
pull it off.

838
00:37:14,530 --> 00:37:19,870
But there still is a need for
you to make calls from Dart to

839
00:37:19,870 --> 00:37:20,970
JavaScript and vice versa.

840
00:37:20,970 --> 00:37:22,360
There's no question
about that.

841
00:37:22,360 --> 00:37:23,420
There is a need to do that.

842
00:37:23,420 --> 00:37:25,700
Like, you might want to interact
with the Maps API

843
00:37:25,700 --> 00:37:29,120
from Google, and there's
no Dart Maps API yet.

844
00:37:29,120 --> 00:37:31,720
And so there has to be
a way to do this.

845
00:37:31,720 --> 00:37:34,870
And fortunately, there
is a way to do it.

846
00:37:34,870 --> 00:37:37,150
There's an unofficial way--

847
00:37:37,150 --> 00:37:39,390
quite a few, actually, which
I'm going to show you.

848
00:37:39,390 --> 00:37:41,910
And I'm going to make you a
promise that we're actually

849
00:37:41,910 --> 00:37:44,840
working on it, and actually, a
real nice solution will be

850
00:37:44,840 --> 00:37:46,460
coming later down the pipe.

851
00:37:46,460 --> 00:37:49,910
So what are the ways
we can do this?

852
00:37:49,910 --> 00:37:51,875
Well one way is this
postMessage() communication,

853
00:37:51,875 --> 00:37:53,480
like I just discussed.

854
00:37:53,480 --> 00:37:57,410
So what you could do is you
could have JavaScript listen

855
00:37:57,410 --> 00:38:01,250
for window.onmessage, and
anything that basically comes

856
00:38:01,250 --> 00:38:04,090
in through a message, you
just run eval on it.

857
00:38:04,090 --> 00:38:07,310
And then likewise, in
the Dart world--

858
00:38:07,310 --> 00:38:09,290
this is Dart code here--

859
00:38:09,290 --> 00:38:11,970
you do postMessage, and in
there you put JavaScript.

860
00:38:11,970 --> 00:38:14,920
And then so the JavaScript event
handler gets triggered

861
00:38:14,920 --> 00:38:15,920
and it just runs eval.

862
00:38:15,920 --> 00:38:20,120
So I've made a call from Dart
to JavaScript in that way.

863
00:38:20,120 --> 00:38:22,080
It's not pretty, but it works.

864
00:38:22,080 --> 00:38:26,130
Another solution that people do,
because you have a little

865
00:38:26,130 --> 00:38:28,680
bit more control, is script
tag injections.

866
00:38:28,680 --> 00:38:32,310
So in Dart code, you could just
create a script tag, set

867
00:38:32,310 --> 00:38:36,330
its text attribute to be the
JavaScript text, and insert it

868
00:38:36,330 --> 00:38:39,080
into the body of the browser
document, and it

869
00:38:39,080 --> 00:38:41,820
will just be evaluated.

870
00:38:41,820 --> 00:38:45,040
But that's only uni-directional
communication,

871
00:38:45,040 --> 00:38:50,170
and you can't build an API if
you can't get any values back

872
00:38:50,170 --> 00:38:53,310
after you evaluate the code.

873
00:38:53,310 --> 00:38:55,850
You could have bi-directional
messaging.

874
00:38:55,850 --> 00:38:57,940
So I could send the message to
JavaScript, and it'll say,

875
00:38:57,940 --> 00:39:00,090
call this method on Google
Maps for me.

876
00:39:00,090 --> 00:39:03,560
Google Maps dot
setCurrentLongitude = 10.

877
00:39:03,560 --> 00:39:07,180
But the problem is, I can't get
any return value from that

878
00:39:07,180 --> 00:39:08,280
function back.

879
00:39:08,280 --> 00:39:10,930
You could make the JavaScript
then post the message back to

880
00:39:10,930 --> 00:39:13,420
Dart and have Dart listen for a
message, which then has the

881
00:39:13,420 --> 00:39:14,570
return value in it.

882
00:39:14,570 --> 00:39:16,680
And in that case, it would
look very much like

883
00:39:16,680 --> 00:39:22,120
asynchronous JSON-RPC back and
forth between the server.

884
00:39:22,120 --> 00:39:26,160
But the API that could be built
around that would look

885
00:39:26,160 --> 00:39:26,860
pretty nasty.

886
00:39:26,860 --> 00:39:29,400
For example, every getter and
setter would have to take a

887
00:39:29,400 --> 00:39:33,400
closure that would be called
back into with the return

888
00:39:33,400 --> 00:39:35,310
value when it was ready.

889
00:39:35,310 --> 00:39:37,160
You have got to remember,
the browser isn't always

890
00:39:37,160 --> 00:39:37,700
synchronous.

891
00:39:37,700 --> 00:39:40,120
So if you ask the browser to do
something, it could do it

892
00:39:40,120 --> 00:39:42,500
immediately, or actually,
it could do it

893
00:39:42,500 --> 00:39:44,480
at next event loop.

894
00:39:44,480 --> 00:39:48,190
And so you have to basically
pass it a callback because it

895
00:39:48,190 --> 00:39:50,450
could be executed
at a later time.

896
00:39:50,450 --> 00:39:55,830
And so this would lead to a
really poor API experience.

897
00:39:55,830 --> 00:39:59,400
But it turns out, there's
actually an API in a browser.

898
00:39:59,400 --> 00:40:02,790
It's one of the very few
synchronous XHRs or another

899
00:40:02,790 --> 00:40:07,950
that actually is synchronous,
meaning it actually blocks

900
00:40:07,950 --> 00:40:10,270
until it finishes executing.

901
00:40:10,270 --> 00:40:12,580
And it's called dispatchEvent().

902
00:40:12,580 --> 00:40:15,440
And what it allows you to do is
to fire off an event, like

903
00:40:15,440 --> 00:40:18,680
onClick or something like that,
and it will be handled

904
00:40:18,680 --> 00:40:19,320
immediately.

905
00:40:19,320 --> 00:40:23,000
Not the next time the browser
goes to the event loop, or

906
00:40:23,000 --> 00:40:26,020
after all the set timeouts
run, but right now.

907
00:40:26,020 --> 00:40:30,870
And so that gives us a hack or
sort of a doorway to get true

908
00:40:30,870 --> 00:40:33,220
synchronous bi-directional
messaging between Dart and

909
00:40:33,220 --> 00:40:34,140
JavaScript.

910
00:40:34,140 --> 00:40:37,980
And the essential way you'll
do it is this.

911
00:40:37,980 --> 00:40:43,120
You're going to invent a
new custom event name.

912
00:40:43,120 --> 00:40:44,250
And you can do that
in JavaScript.

913
00:40:44,250 --> 00:40:45,180
You can make your own events.

914
00:40:45,180 --> 00:40:47,720
You don't have to just use
onClick or mouseover.

915
00:40:47,720 --> 00:40:52,440
And I'll call it 'dartjsni',
just for GWT'S sake.

916
00:40:52,440 --> 00:40:54,050
And then what you're going to do
is you're going to register

917
00:40:54,050 --> 00:40:57,950
an event listener in Dart via
window.addEventListener and

918
00:40:57,950 --> 00:41:03,190
look for this 'dartjsni' event
to happen, and do something

919
00:41:03,190 --> 00:41:04,260
when it does happen.

920
00:41:04,260 --> 00:41:06,360
And then you're going to
construct a serialization

921
00:41:06,360 --> 00:41:07,740
format for RPC calls.

922
00:41:07,740 --> 00:41:09,830
Maybe you just take the method
name and all the arguments

923
00:41:09,830 --> 00:41:11,530
that you want to call and you
serialize them in a JSON

924
00:41:11,530 --> 00:41:13,300
object or something.

925
00:41:13,300 --> 00:41:16,680
And you have the callback
that's looking for that

926
00:41:16,680 --> 00:41:20,240
'dartjsni' event deserialize
it and evaluate it.

927
00:41:20,240 --> 00:41:22,540
Then you're going to invent
another event name-- let's

928
00:41:22,540 --> 00:41:24,260
call it 'returnjsni'--

929
00:41:24,260 --> 00:41:26,520
and it's going to take the
return value, serialize it,

930
00:41:26,520 --> 00:41:28,960
and then fire via
window.dispatchEvent this

931
00:41:28,960 --> 00:41:32,060
'returnjsni' event.

932
00:41:32,060 --> 00:41:34,980
And then in the Dart code,
you're going to be looking for

933
00:41:34,980 --> 00:41:40,110
window.OnDartjsni event handler,
and that's going to

934
00:41:40,110 --> 00:41:42,430
be the return value.

935
00:41:42,430 --> 00:41:44,730
And what makes this all work
is that when both sides use

936
00:41:44,730 --> 00:41:48,330
dispatchEvent(), there
is no asynchronicity.

937
00:41:48,330 --> 00:41:50,350
You fire the event and it
immediately evokes the

938
00:41:50,350 --> 00:41:51,660
callback on the JavaScript
side.

939
00:41:51,660 --> 00:41:54,100
The JavaScript side does the
evaluation and invokes

940
00:41:54,100 --> 00:41:56,550
dispatchEvent for 'returnjsni'
and it immediately runs the

941
00:41:56,550 --> 00:42:02,040
Dart event handler, all in
one synchronous loop.

942
00:42:02,040 --> 00:42:03,190
This is just a picture of it.

943
00:42:03,190 --> 00:42:05,240
It's probably not very
useful for you.

944
00:42:05,240 --> 00:42:06,985
But I tried to draw
how it would work.

945
00:42:06,985 --> 00:42:10,270

946
00:42:10,270 --> 00:42:12,320
I'm just going to skip
that picture for now.

947
00:42:12,320 --> 00:42:16,640
So you could make the
JSNI mappings even

948
00:42:16,640 --> 00:42:17,720
more natural, right?

949
00:42:17,720 --> 00:42:21,200
Like what if you just wanted
to have a Dart object, and

950
00:42:21,200 --> 00:42:24,580
when you refer on that Dart
object to any field or any

951
00:42:24,580 --> 00:42:27,830
method, it actually is kind of
a mirror or a proxy directly

952
00:42:27,830 --> 00:42:28,250
into JavaScript.

953
00:42:28,250 --> 00:42:30,600
It kind of represents a
JavaScript object on the other

954
00:42:30,600 --> 00:42:32,300
side of the fence.

955
00:42:32,300 --> 00:42:35,870
And so Dart has two features
that actually almost make this

956
00:42:35,870 --> 00:42:39,130
look completely natural and
almost like the JavaScript's

957
00:42:39,130 --> 00:42:39,820
not even involved.

958
00:42:39,820 --> 00:42:42,000
The first is operator
overloading.

959
00:42:42,000 --> 00:42:45,610
So you can implement
the operator[]--

960
00:42:45,610 --> 00:42:47,960
and here I have a class
called JsProxy--

961
00:42:47,960 --> 00:42:49,840
and it takes a field name.

962
00:42:49,840 --> 00:42:52,480
And then what you do is you
make that synchronous call

963
00:42:52,480 --> 00:42:54,720
over using that Dart
JSNI method I just

964
00:42:54,720 --> 00:42:56,140
described how you'd do.

965
00:42:56,140 --> 00:43:00,420
And you index the field name on
the object reference that

966
00:43:00,420 --> 00:43:04,690
you're holding on to, that this
proxy object represents.

967
00:43:04,690 --> 00:43:06,960
Dart has another feature I
haven't described yet.

968
00:43:06,960 --> 00:43:10,170
Because it's a dynamic language,
what I said earlier

969
00:43:10,170 --> 00:43:14,020
was is that you can try to
access or invoke anything on

970
00:43:14,020 --> 00:43:16,260
an object, even though it's the
wrong type, and it will

971
00:43:16,260 --> 00:43:17,850
still try it.

972
00:43:17,850 --> 00:43:20,240
And if it fails, it doesn't
fail completely.

973
00:43:20,240 --> 00:43:22,630
What it does is it invokes
noSuchMethod.

974
00:43:22,630 --> 00:43:24,700
So it's a magical method.

975
00:43:24,700 --> 00:43:27,070
You could put it on a Dart class
to override it, and it

976
00:43:27,070 --> 00:43:29,470
will be called for any method
that it can't find, that

977
00:43:29,470 --> 00:43:30,970
someone tried to invoke.

978
00:43:30,970 --> 00:43:35,040
And so in this way, you could
make a JsProxy class that can

979
00:43:35,040 --> 00:43:40,640
invoke any JavaScript method
that exists in the JSVM by

980
00:43:40,640 --> 00:43:42,190
defining a noSuchMethod.

981
00:43:42,190 --> 00:43:43,960
It takes the name of the method
someone's trying to

982
00:43:43,960 --> 00:43:45,660
invoke and a list of the
arguments, and then you just

983
00:43:45,660 --> 00:43:48,660
make a synchronous call using
what I just described in the

984
00:43:48,660 --> 00:43:49,670
previous slide.

985
00:43:49,670 --> 00:43:53,972
And it will return the value as
if that method existed on

986
00:43:53,972 --> 00:43:57,220
the JsProxy object by going to
JavaScript and asking it to

987
00:43:57,220 --> 00:43:59,130
evaluate it.

988
00:43:59,130 --> 00:44:01,450
So that's another interesting
idiom or

989
00:44:01,450 --> 00:44:04,900
example you could use.

990
00:44:04,900 --> 00:44:08,330
And if you wanted to invoke GWT
code directly from Dart or

991
00:44:08,330 --> 00:44:11,810
vice versa, I would advocate
using a library I wrote called

992
00:44:11,810 --> 00:44:12,990
GWT Exporter.

993
00:44:12,990 --> 00:44:16,150
And what that allows you to do
is to put @Export annotations

994
00:44:16,150 --> 00:44:18,190
on your classes and
Java methods.

995
00:44:18,190 --> 00:44:23,510
And what it does is it manually
declares JavaScript

996
00:44:23,510 --> 00:44:27,360
exports in the top-level window
object of the page.

997
00:44:27,360 --> 00:44:29,700
And then once you've got those
things exposed to JavaScript,

998
00:44:29,700 --> 00:44:32,760
then you can use the Dart JSNI
method technique I showed you

999
00:44:32,760 --> 00:44:35,810
to just call directly
into GWT.

1000
00:44:35,810 --> 00:44:38,560
Likewise, if you wanted to do
it the other way around, you

1001
00:44:38,560 --> 00:44:42,930
could export Dart functions into
JavaScript by writing a

1002
00:44:42,930 --> 00:44:46,895
JavaScript function which, when
invoked, uses the Dart

1003
00:44:46,895 --> 00:44:49,690
JSNI mechanism to send a message
over to Dart and say,

1004
00:44:49,690 --> 00:44:52,770
I'm invoking this method
on this Dart class.

1005
00:44:52,770 --> 00:44:57,610
However what I've just shown
you, it's really complicated

1006
00:44:57,610 --> 00:44:58,580
and it's kind of a hack.

1007
00:44:58,580 --> 00:45:01,070
And I would not advocate using
it, except for specialized

1008
00:45:01,070 --> 00:45:04,850
scenarios like trying to create
a really nice mapping

1009
00:45:04,850 --> 00:45:06,610
for, like, the Google Maps
library or some other

1010
00:45:06,610 --> 00:45:09,400
JavaScript library, where it
would be painful to have an

1011
00:45:09,400 --> 00:45:11,580
asynchronous approach.

1012
00:45:11,580 --> 00:45:13,680
Otherwise, I would suggest,
just use postMessage.

1013
00:45:13,680 --> 00:45:17,710
It's the easiest thing and
the least likely to fail.

1014
00:45:17,710 --> 00:45:20,410
And for the record, we actually
don't know how much

1015
00:45:20,410 --> 00:45:21,730
longer dispatch will
be around.

1016
00:45:21,730 --> 00:45:24,470
It could very well be that the
HTML5 committee could say

1017
00:45:24,470 --> 00:45:26,030
tomorrow, we're removing that.

1018
00:45:26,030 --> 00:45:28,610

1019
00:45:28,610 --> 00:45:33,310
So in summary I just wanted to
say that Dart is a cool new

1020
00:45:33,310 --> 00:45:35,040
dynamic language.

1021
00:45:35,040 --> 00:45:37,770
It takes some of the best things
from JavaScript, which

1022
00:45:37,770 --> 00:45:40,820
is the ability to start up
quickly without a compile

1023
00:45:40,820 --> 00:45:44,440
pass, to have the program
run even though

1024
00:45:44,440 --> 00:45:45,310
the types are wrong.

1025
00:45:45,310 --> 00:45:47,270
So you can iterate on
something, even

1026
00:45:47,270 --> 00:45:49,360
if you've got errors.

1027
00:45:49,360 --> 00:45:53,620
But also to allow the language
to be tooled and tested with

1028
00:45:53,620 --> 00:45:56,550
compile-time static
tool chains.

1029
00:45:56,550 --> 00:46:00,060
It offers a lightweight DOM
programming library for now,

1030
00:46:00,060 --> 00:46:02,650
but later on, it will have
a very rich library.

1031
00:46:02,650 --> 00:46:04,150
That's the whole point of
having a structured

1032
00:46:04,150 --> 00:46:05,120
programming language.

1033
00:46:05,120 --> 00:46:08,120
They invented all of this new
syntax for a type system.

1034
00:46:08,120 --> 00:46:09,610
They're going to build
a really rich

1035
00:46:09,610 --> 00:46:11,220
library to support it.

1036
00:46:11,220 --> 00:46:15,690
It's not going to be very raw
and basic like JavaScript.

1037
00:46:15,690 --> 00:46:17,590
Try converting some simple
GWT libraries.

1038
00:46:17,590 --> 00:46:18,230
Get your feet wet.

1039
00:46:18,230 --> 00:46:20,680
Pick the simplest thing in your
project and say, what

1040
00:46:20,680 --> 00:46:21,570
would this look like in Dart?

1041
00:46:21,570 --> 00:46:22,270
Just play around with it.

1042
00:46:22,270 --> 00:46:23,310
Have some fun.

1043
00:46:23,310 --> 00:46:24,570
Or integrate--

1044
00:46:24,570 --> 00:46:27,370
try to add a new page your app
by basically writing it in

1045
00:46:27,370 --> 00:46:30,950
Dart and using the hashtag
history routing to integrate

1046
00:46:30,950 --> 00:46:33,140
it into the page.

1047
00:46:33,140 --> 00:46:35,710
I would advocate, even if you're
not going to use Dart,

1048
00:46:35,710 --> 00:46:38,070
to look at the GWT Activities
and Places model if you're not

1049
00:46:38,070 --> 00:46:38,780
using it already.

1050
00:46:38,780 --> 00:46:41,310
Because it will help
you in the future.

1051
00:46:41,310 --> 00:46:45,800
And finally, if you're really
adventurous, try hacking a

1052
00:46:45,800 --> 00:46:48,730
Dart JSNI library.

1053
00:46:48,730 --> 00:46:51,590
You could probably release it,
and if you do it quick enough,

1054
00:46:51,590 --> 00:46:54,390
everyone might use it.

1055
00:46:54,390 --> 00:46:56,230
So that's my presentation.

1056
00:46:56,230 --> 00:46:58,340
Hope you guys got something
out of it.

1057
00:46:58,340 --> 00:47:00,660
And I'm open to taking
some questions.

1058
00:47:00,660 --> 00:47:08,830
[APPLAUSE]

1059
00:47:08,830 --> 00:47:09,050
AUDIENCE: Yeah.

1060
00:47:09,050 --> 00:47:12,480
You mentioned
internationalization and

1061
00:47:12,480 --> 00:47:13,760
string interpolation.

1062
00:47:13,760 --> 00:47:15,650
RAY CROMWELL: Yes.

1063
00:47:15,650 --> 00:47:19,293
AUDIENCE: I wonder, do you have
an example of that, like

1064
00:47:19,293 --> 00:47:21,170
how it works in Dart?

1065
00:47:21,170 --> 00:47:23,980
I'm using it in GWT, but to
migrate some stuff, I'm going

1066
00:47:23,980 --> 00:47:25,360
to need to move it do Dart.

1067
00:47:25,360 --> 00:47:27,260
RAY CROMWELL: Yeah, that's
a good question for me.

1068
00:47:27,260 --> 00:47:30,530
[INAUDIBLE], do you happen
to know the idiom for

1069
00:47:30,530 --> 00:47:31,878
doing that in Dart?

1070
00:47:31,878 --> 00:47:34,120
AUDIENCE: [INAUDIBLE]

1071
00:47:34,120 --> 00:47:35,660
RAY CROMWELL: What I was
thinking of, when I wrote

1072
00:47:35,660 --> 00:47:39,010
that, was basically using the
string interpolation to define

1073
00:47:39,010 --> 00:47:43,710
the templates like you would do
it in a Messages class in

1074
00:47:43,710 --> 00:47:48,420
GWT and basically create the
equivalent of a Dart

1075
00:47:48,420 --> 00:47:51,200
ResourceBundle but using
JSON structures.

1076
00:47:51,200 --> 00:47:54,000
And then write in a little
utility library to basically

1077
00:47:54,000 --> 00:47:56,710
perform the equivalent of what
gets code generated in GWT,

1078
00:47:56,710 --> 00:48:00,540
which is to take the template
and basically apply the JSON

1079
00:48:00,540 --> 00:48:02,596
to it to fill out
the template.

1080
00:48:02,596 --> 00:48:03,610
Yeah, sorry.

1081
00:48:03,610 --> 00:48:05,645
I probably should have fleshed
that out more.

1082
00:48:05,645 --> 00:48:08,260
I probably ran out of time,
doing my slides.

1083
00:48:08,260 --> 00:48:09,195
AUDIENCE: That's fine.

1084
00:48:09,195 --> 00:48:13,060
And I'm looking for something a
little bit more formal with

1085
00:48:13,060 --> 00:48:14,800
the Places and Activities.

1086
00:48:14,800 --> 00:48:16,720
Is there something like
that planned for Dart?

1087
00:48:16,720 --> 00:48:21,170
Or is it just like window.on
listening

1088
00:48:21,170 --> 00:48:22,630
for that native event?

1089
00:48:22,630 --> 00:48:24,690
RAY CROMWELL: Yeah I don't
know the answer to that.

1090
00:48:24,690 --> 00:48:28,440
But I believe the Dart team is
working on rich object models.

1091
00:48:28,440 --> 00:48:30,730
And they're probably looking
at MBC or MBP.

1092
00:48:30,730 --> 00:48:32,334
Do you happen to know, Vijay?

1093
00:48:32,334 --> 00:48:53,110
VIJAY:MENON: [INAUDIBLE]

1094
00:48:53,110 --> 00:48:55,220
RAY CROMWELL: So just in case no
one heard that, they built

1095
00:48:55,220 --> 00:48:57,670
a really nice application
called Swarm.

1096
00:48:57,670 --> 00:48:59,510
And what they're doing is
they're taking the lessons

1097
00:48:59,510 --> 00:49:02,470
learned from building that rich
UI and the way they've

1098
00:49:02,470 --> 00:49:05,840
organized it and basically
trying to extract the

1099
00:49:05,840 --> 00:49:08,320
libraries and the patterns out
of it that they're going to

1100
00:49:08,320 --> 00:49:09,010
use for Dart.

1101
00:49:09,010 --> 00:49:11,730
And so I don't think that
they have anything

1102
00:49:11,730 --> 00:49:12,920
today that's concrete.

1103
00:49:12,920 --> 00:49:18,730
But I do believe that-- because
Seth Ladd is heavily

1104
00:49:18,730 --> 00:49:23,830
involved in interacting with
the community who's

1105
00:49:23,830 --> 00:49:24,710
dealing with Dart.

1106
00:49:24,710 --> 00:49:28,040
And Seth is a really big fan
of MBC and MBP stuff.

1107
00:49:28,040 --> 00:49:31,050
So there probably will be
something that great.

1108
00:49:31,050 --> 00:49:33,190
But sorry, I don't
know the answer.

1109
00:49:33,190 --> 00:49:33,880
AUDIENCE: That's OK.

1110
00:49:33,880 --> 00:49:35,480
Last question, I promise.

1111
00:49:35,480 --> 00:49:38,930
When I last looked at Dart,
it said "Alpha" on it.

1112
00:49:38,930 --> 00:49:42,110
Do we know when it's going
to be promoted?

1113
00:49:42,110 --> 00:49:44,570
RAY CROMWELL: Is Lars
or Vijay here?

1114
00:49:44,570 --> 00:49:46,120
Vijay, do you want
to take that?

1115
00:49:46,120 --> 00:49:47,370
VIJAY MENON: [INAUDIBLE]

1116
00:49:47,370 --> 00:49:49,440

1117
00:49:49,440 --> 00:49:50,000
RAY CROMWELL: I'll
just repeat you.

1118
00:49:50,000 --> 00:49:53,395
VIJAY MENON: You can get an
official answer from Lars.

1119
00:49:53,395 --> 00:49:54,645
[INAUDIBLE]

1120
00:49:54,645 --> 00:49:56,790

1121
00:49:56,790 --> 00:49:57,760
RAY CROMWELL: Ah.

1122
00:49:57,760 --> 00:50:00,090
VIJAY MENON: My understanding
is that later this year,

1123
00:50:00,090 --> 00:50:03,357
there'll be more of an official
release, but I'm not

1124
00:50:03,357 --> 00:50:05,340
exactly sure we've said
what the date is

1125
00:50:05,340 --> 00:50:06,150
going to be on that.

1126
00:50:06,150 --> 00:50:07,700
AUDIENCE: OK.

1127
00:50:07,700 --> 00:50:08,600
RAY CROMWELL: So later this
year, there will be an

1128
00:50:08,600 --> 00:50:09,160
official answer.

1129
00:50:09,160 --> 00:50:11,400
But if you go talk to Lars,
just track him down--

1130
00:50:11,400 --> 00:50:14,290
he's kind of a very tall
guy with glasses--

1131
00:50:14,290 --> 00:50:16,000
he could probably give you
a more concrete answer.

1132
00:50:16,000 --> 00:50:17,730
But I do believe, at least
from my own personal

1133
00:50:17,730 --> 00:50:20,720
experience, the language spec
seems to be settling down very

1134
00:50:20,720 --> 00:50:21,215
nicely now.

1135
00:50:21,215 --> 00:50:23,170
And so it's probably
going to exit the

1136
00:50:23,170 --> 00:50:25,450
Alpha phase very soon.

1137
00:50:25,450 --> 00:50:25,710
AUDIENCE: Great.

1138
00:50:25,710 --> 00:50:25,940
Thank you.

1139
00:50:25,940 --> 00:50:27,130
RAY CROMWELL: But that shouldn't
dissuade you from

1140
00:50:27,130 --> 00:50:28,200
trying it, right?

1141
00:50:28,200 --> 00:50:30,180
Have some fun with it.

1142
00:50:30,180 --> 00:50:30,860
VIJAY MENON: OK.

1143
00:50:30,860 --> 00:50:31,360
Sorry.

1144
00:50:31,360 --> 00:50:33,890
Just to add in-- we do have
teams in Google who are

1145
00:50:33,890 --> 00:50:34,800
starting to use Dart.

1146
00:50:34,800 --> 00:50:37,910
So even though we're still
working on it, it's pretty

1147
00:50:37,910 --> 00:50:39,380
usable today.

1148
00:50:39,380 --> 00:50:40,740
They wouldn't be using
it if it wasn't.

1149
00:50:40,740 --> 00:50:43,480

1150
00:50:43,480 --> 00:50:43,965
AUDIENCE: Hi there.

1151
00:50:43,965 --> 00:50:46,630
Are there any legs to the rumor
that GWT is looking for

1152
00:50:46,630 --> 00:50:48,910
new intermediate language, and
that intermediate language

1153
00:50:48,910 --> 00:50:52,850
might be Dart?

1154
00:50:52,850 --> 00:50:53,810
RAY CROMWELL: Yeah, there's
nothing official.

1155
00:50:53,810 --> 00:50:55,120
There's been some
talk about that.

1156
00:50:55,120 --> 00:50:57,550
I know I've thought about it
personally, of building a Dart

1157
00:50:57,550 --> 00:50:58,530
back end for GWT.

1158
00:50:58,530 --> 00:51:04,440
So if and when Chrome actually
has the Dart VM built into it,

1159
00:51:04,440 --> 00:51:06,430
it might be the case that
either one of two

1160
00:51:06,430 --> 00:51:07,190
things might happen.

1161
00:51:07,190 --> 00:51:10,300
Either someone might build a
back-end for GWT that emits

1162
00:51:10,300 --> 00:51:12,890
Dart code, compiles the Dart,
just to take advantage of the

1163
00:51:12,890 --> 00:51:15,490
speed and start-up time
improvements that the Dart VM

1164
00:51:15,490 --> 00:51:16,810
will have over V8.

1165
00:51:16,810 --> 00:51:18,680
The other option, actually, and
I think this is probably

1166
00:51:18,680 --> 00:51:21,080
more likely, is that someone
will build a tool that

1167
00:51:21,080 --> 00:51:25,500
actually will help migrate Java
code to Dart in case you

1168
00:51:25,500 --> 00:51:28,430
want to basically port
some code over.

1169
00:51:28,430 --> 00:51:30,750
There are some difficulties in
compiling GWT code to Dart

1170
00:51:30,750 --> 00:51:32,080
because of JavaScript.

1171
00:51:32,080 --> 00:51:36,320
So you can imagine, any large
GWT application at sort of the

1172
00:51:36,320 --> 00:51:39,360
leaves of the program, deepest
down, is going to have JSNI

1173
00:51:39,360 --> 00:51:40,910
method calls to deal
with the browser.

1174
00:51:40,910 --> 00:51:44,210
And so those would have to be
replaced with the Dart library

1175
00:51:44,210 --> 00:51:44,880
equivalents.

1176
00:51:44,880 --> 00:51:48,740
So if someone's calling, like,
dom.getElementById, rather

1177
00:51:48,740 --> 00:51:52,350
than making a JSNI call there,
which would have to use this

1178
00:51:52,350 --> 00:51:54,640
hack, it would have to replace
it with the equivalent

1179
00:51:54,640 --> 00:51:58,260
dart:html library and call
the actual Dart method.

1180
00:51:58,260 --> 00:52:00,330
And it's certainly possible to
do that, but it would actually

1181
00:52:00,330 --> 00:52:03,280
be a lot of mapping work.

1182
00:52:03,280 --> 00:52:04,020
But yeah.

1183
00:52:04,020 --> 00:52:05,080
We've talked about it.

1184
00:52:05,080 --> 00:52:07,210
If I have nothing
official to say.

1185
00:52:07,210 --> 00:52:09,820
AUDIENCE: Thank you.

1186
00:52:09,820 --> 00:52:11,450
AUDIENCE: Do you think
there's going to--

1187
00:52:11,450 --> 00:52:13,020
when they finally get
to release, will

1188
00:52:13,020 --> 00:52:14,250
they have the widgets?

1189
00:52:14,250 --> 00:52:18,960
And will they be similar to
what GWT has already?

1190
00:52:18,960 --> 00:52:19,970
RAY CROMWELL: They
probably will be.

1191
00:52:19,970 --> 00:52:21,900
So I don't know, actually, the
timeline on the widgets.

1192
00:52:21,900 --> 00:52:24,840
But I know what their philosophy
and intention is.

1193
00:52:24,840 --> 00:52:26,680
And so their philosophy and
intention is actually to

1194
00:52:26,680 --> 00:52:29,260
deliver widgets that probably
go far beyond what GWT has.

1195
00:52:29,260 --> 00:52:33,500
So GWT, when it started,
basically they wanted it to be

1196
00:52:33,500 --> 00:52:34,460
more like JavaScript.

1197
00:52:34,460 --> 00:52:36,115
We didn't want to be very
opinionated about what the

1198
00:52:36,115 --> 00:52:38,740
widgets looked like, so the
first GWT widgets were very

1199
00:52:38,740 --> 00:52:40,100
ugly out of the box.

1200
00:52:40,100 --> 00:52:41,820
They didn't provide very
much styling at all.

1201
00:52:41,820 --> 00:52:43,830
Later, we got some sense
knocked into us, and we

1202
00:52:43,830 --> 00:52:45,720
realized most programmers
can't take the time to

1203
00:52:45,720 --> 00:52:46,930
actually style all
their widgets.

1204
00:52:46,930 --> 00:52:48,930
We should provide some default
that actually looks

1205
00:52:48,930 --> 00:52:49,720
reasonable.

1206
00:52:49,720 --> 00:52:50,620
And we did that.

1207
00:52:50,620 --> 00:52:52,910
But still, it's nothing compared
to what Sencha has,

1208
00:52:52,910 --> 00:52:53,480
for example.

1209
00:52:53,480 --> 00:52:54,210
Right?

1210
00:52:54,210 --> 00:52:56,340
And so that was probably
a mistake

1211
00:52:56,340 --> 00:52:58,920
early in the GWT design.

1212
00:52:58,920 --> 00:53:02,060
The Dart team, I think, is
eyeing the fact that people

1213
00:53:02,060 --> 00:53:04,690
want to design apps and they
want to design them to be

1214
00:53:04,690 --> 00:53:06,810
productive, and they want
to wow their consumers.

1215
00:53:06,810 --> 00:53:08,600
And so you need not just
a widget library.

1216
00:53:08,600 --> 00:53:10,890
You need a very sexy widget
library out of the box.

1217
00:53:10,890 --> 00:53:14,450
And so they're actually aiming
to make something that's very

1218
00:53:14,450 --> 00:53:15,660
lickable, something that
you're going to

1219
00:53:15,660 --> 00:53:16,780
love out of the box.

1220
00:53:16,780 --> 00:53:18,050
And it's going to be
very opinionated.

1221
00:53:18,050 --> 00:53:20,970
So the slider widget is going
to look the way the Dart

1222
00:53:20,970 --> 00:53:23,450
user-interface designer
wants it to look.

1223
00:53:23,450 --> 00:53:25,290
And it might not look the way
you want it to look, but it's

1224
00:53:25,290 --> 00:53:26,920
probably going to look
really sweet.

1225
00:53:26,920 --> 00:53:29,210
And so that's basically what
they're looking at.

1226
00:53:29,210 --> 00:53:32,384
Am I summarizing correctly,
Vijay?

1227
00:53:32,384 --> 00:53:33,350
OK.

1228
00:53:33,350 --> 00:53:35,210
I'm actually not part of the
Dart team, so I don't want to

1229
00:53:35,210 --> 00:53:35,956
speak too much about it.

1230
00:53:35,956 --> 00:53:38,050
But I overheard some
conversations.

1231
00:53:38,050 --> 00:53:38,315
OK?

1232
00:53:38,315 --> 00:53:39,140
You have another?

1233
00:53:39,140 --> 00:53:42,990
AUDIENCE: Also, I've got a lot
of applications on App Engine.

1234
00:53:42,990 --> 00:53:48,850
And is there a pattern or
something that I can use to

1235
00:53:48,850 --> 00:53:50,492
migrate it to that?

1236
00:53:50,492 --> 00:53:51,710
RAY CROMWELL: You're talking
about App Engine?

1237
00:53:51,710 --> 00:53:54,410
AUDIENCE: App Engine using
RequestFactory.

1238
00:53:54,410 --> 00:53:55,850
RAY CROMWELL: Oh, yeah.

1239
00:53:55,850 --> 00:53:58,380
I actually was going to
discuss this in the

1240
00:53:58,380 --> 00:54:00,690
presentation, but I realized
later I had too many slides

1241
00:54:00,690 --> 00:54:01,540
and I ran out of time.

1242
00:54:01,540 --> 00:54:05,110
But if you're using
RequestFactory, actually--

1243
00:54:05,110 --> 00:54:05,870
I should take this offline.

1244
00:54:05,870 --> 00:54:06,780
There's an extra bonus.

1245
00:54:06,780 --> 00:54:09,580
Because RequestFactory's
JSON-based, it's very possible

1246
00:54:09,580 --> 00:54:13,270
to make Dart client code work
with JSON RequestFactory stuff

1247
00:54:13,270 --> 00:54:14,260
on the server.

1248
00:54:14,260 --> 00:54:15,640
It's not true for GWT-RPC.

1249
00:54:15,640 --> 00:54:18,680
GWT-RPC is very tightly tied
in to the Java type system.

1250
00:54:18,680 --> 00:54:19,860
RequestFactory isn't.

1251
00:54:19,860 --> 00:54:22,790
So actually, it's possible
to make a Dart code call

1252
00:54:22,790 --> 00:54:25,170
server-side Java RequestFactory
code.

1253
00:54:25,170 --> 00:54:29,090
And so maybe I can catch you
offline and discuss that.

1254
00:54:29,090 --> 00:54:31,815
AUDIENCE: Thank you.

1255
00:54:31,815 --> 00:54:32,250
AUDIENCE: OK.

1256
00:54:32,250 --> 00:54:35,870
So my question would be about
GWT-RPC, so you already

1257
00:54:35,870 --> 00:54:36,740
answered it.

1258
00:54:36,740 --> 00:54:43,060
So there's some way to
invoke GWT-RPC calls?

1259
00:54:43,060 --> 00:54:44,170
RAY CROMWELL: Yes.

1260
00:54:44,170 --> 00:54:47,070
That would be kind of difficult
to pull off.

1261
00:54:47,070 --> 00:54:49,810
I could see you constructing
something that would invoke

1262
00:54:49,810 --> 00:54:53,460
it, but I would see it being
hard to actually deal with the

1263
00:54:53,460 --> 00:54:54,620
return value.

1264
00:54:54,620 --> 00:55:00,690
So there are Android clients
that actually invoke GWT-RPC

1265
00:55:00,690 --> 00:55:03,680
because Android also is Java, so
they can deal with the fact

1266
00:55:03,680 --> 00:55:05,740
that when the return value comes
back and it says, like,

1267
00:55:05,740 --> 00:55:09,480
it's an array list of doubles or
something, the classes for

1268
00:55:09,480 --> 00:55:11,800
decoding an array list of
doubles are already present in

1269
00:55:11,800 --> 00:55:13,630
the runtime of Dalvik, right?

1270
00:55:13,630 --> 00:55:16,720
With Dart, if you invoke some
server-side call and you get

1271
00:55:16,720 --> 00:55:20,600
back an array of things that are
Java types, right, there's

1272
00:55:20,600 --> 00:55:22,900
not necessarily something to
map to decode those and

1273
00:55:22,900 --> 00:55:25,130
demarshal them into
on the Dart side.

1274
00:55:25,130 --> 00:55:26,210
So it's a little
more difficult.

1275
00:55:26,210 --> 00:55:28,740
But invoking I could see.

1276
00:55:28,740 --> 00:55:31,180
As long as your API actually
uses mostly primitive things,

1277
00:55:31,180 --> 00:55:34,160
like longs, and integers, and
strings, and so on, or maybe

1278
00:55:34,160 --> 00:55:36,840
POJOs, I think you could
pull it off.

1279
00:55:36,840 --> 00:55:39,085
But if you catch me outside, I
might have some suggestions.

1280
00:55:39,085 --> 00:55:39,400
AUDIENCE: OK.

1281
00:55:39,400 --> 00:55:39,851
Cool.

1282
00:55:39,851 --> 00:55:42,110
Thanks.

1283
00:55:42,110 --> 00:55:43,154
RAY CROMWELL: OK.

1284
00:55:43,154 --> 00:55:44,810
AUDIENCE: Hello?

1285
00:55:44,810 --> 00:55:45,560
At [INAUDIBLE]

1286
00:55:45,560 --> 00:55:46,630
Google our [INAUDIBLE]

1287
00:55:46,630 --> 00:55:49,900
we have many talks about Google
Web Toolkit and we have

1288
00:55:49,900 --> 00:55:53,870
a separate section in
developers' handbooks about

1289
00:55:53,870 --> 00:55:55,210
Google Web Toolkit.

1290
00:55:55,210 --> 00:55:58,580
And now it seems [INAUDIBLE]

1291
00:55:58,580 --> 00:56:02,280
session, which mentioned
Google Web Toolkit.

1292
00:56:02,280 --> 00:56:06,795
So I want to ask,
is GWT is dead?

1293
00:56:06,795 --> 00:56:08,130
RAY CROMWELL: No.

1294
00:56:08,130 --> 00:56:09,960
I been asked this
question a lot.

1295
00:56:09,960 --> 00:56:15,700
And if you look at Google, for
example, a lot of Google's top

1296
00:56:15,700 --> 00:56:17,280
properties, actually,
like AdWords--

1297
00:56:17,280 --> 00:56:21,240
97% of their revenue comes
from the AdWords team.

1298
00:56:21,240 --> 00:56:24,050
And AdWords uses GWT for their
campaign management tool.

1299
00:56:24,050 --> 00:56:26,820
And so it's impractical for us
to say that GWT was dead,

1300
00:56:26,820 --> 00:56:28,010
first of all.

1301
00:56:28,010 --> 00:56:31,010
Second of all, Google
is about choice.

1302
00:56:31,010 --> 00:56:32,070
The company's about choice.

1303
00:56:32,070 --> 00:56:32,960
You know, App Engine,
for example.

1304
00:56:32,960 --> 00:56:34,630
We offer Java.

1305
00:56:34,630 --> 00:56:36,830
We offer Go.

1306
00:56:36,830 --> 00:56:37,860
We offer Python.

1307
00:56:37,860 --> 00:56:39,920
Well, we released Go
recently, right?

1308
00:56:39,920 --> 00:56:42,010
Does that mean that Guido van
Rossum is out of a job and

1309
00:56:42,010 --> 00:56:42,810
Python is dead?

1310
00:56:42,810 --> 00:56:43,370
No.

1311
00:56:43,370 --> 00:56:45,530
It just means that there's
another option for developers.

1312
00:56:45,530 --> 00:56:48,350
And so what I would say for GWT
is that we're not going to

1313
00:56:48,350 --> 00:56:49,730
take GWT away from you.

1314
00:56:49,730 --> 00:56:52,140
And we're still going to support
JavaScript development

1315
00:56:52,140 --> 00:56:56,480
for V8, and we're still going
to support GWT development.

1316
00:56:56,480 --> 00:56:59,220
But we're also offering this new
option that might entice

1317
00:56:59,220 --> 00:57:01,550
some people, maybe some people
who don't like JavaScript.

1318
00:57:01,550 --> 00:57:03,650
Or maybe they're people who like
JavaScript, but they want

1319
00:57:03,650 --> 00:57:04,810
better tools for JavaScript.

1320
00:57:04,810 --> 00:57:07,170
They want a really nice
IDE for something

1321
00:57:07,170 --> 00:57:08,010
that's a dynamic language.

1322
00:57:08,010 --> 00:57:09,170
There's Dart for you.

1323
00:57:09,170 --> 00:57:12,540
Or maybe they like Java, but
maybe they're getting tired of

1324
00:57:12,540 --> 00:57:13,590
doing enterprise apps.

1325
00:57:13,590 --> 00:57:17,450
So nothing's changing
with GWT.

1326
00:57:17,450 --> 00:57:20,590
In fact, if you attend my
session on Friday, there is

1327
00:57:20,590 --> 00:57:23,360
actually some nice news that's
going to be announced with

1328
00:57:23,360 --> 00:57:26,406
respect to GWT's future.

1329
00:57:26,406 --> 00:57:28,760
AUDIENCE: OK.

1330
00:57:28,760 --> 00:57:31,410
RAY CROMWELL: Anything else?

1331
00:57:31,410 --> 00:57:31,740
OK.

1332
00:57:31,740 --> 00:57:33,230
Thanks for coming, and--

1333
00:57:33,230 --> 00:57:37,110
[APPLAUSE]

1334
00:57:37,110 --> 00:57:38,080
RAY CROMWELL: You're welcome.

1335
00:57:38,080 --> 00:57:41,000
Be safe on your way down rushing
to get your devices.

1336
00:57:41,000 --> 00:57:42,250
Don't trip and fall.

1337
00:57:42,250 --> 00:57:45,263

