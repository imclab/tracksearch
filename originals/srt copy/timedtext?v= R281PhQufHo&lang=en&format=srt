1
00:00:00,000 --> 00:00:05,030

2
00:00:05,030 --> 00:00:05,480
COLT MCANLIS: Hey, everybody.

3
00:00:05,480 --> 00:00:06,120
Thanks for coming.

4
00:00:06,120 --> 00:00:07,420
My name is Colt McAnlis.

5
00:00:07,420 --> 00:00:10,620
And I'm a developer advocate at
Google focusing on Native

6
00:00:10,620 --> 00:00:12,300
Client and gaming.

7
00:00:12,300 --> 00:00:13,640
And what we're going to
talk about today is

8
00:00:13,640 --> 00:00:14,940
getting your port on.

9
00:00:14,940 --> 00:00:17,240
Specifically, porting your
game to Native Client

10
00:00:17,240 --> 00:00:19,280
as of Pepper 18.

11
00:00:19,280 --> 00:00:21,820
So a quick show of hands,
who's already

12
00:00:21,820 --> 00:00:22,750
touched Native Client?

13
00:00:22,750 --> 00:00:24,776
Have you compiled the
application before?

14
00:00:24,776 --> 00:00:25,180
OK.

15
00:00:25,180 --> 00:00:25,740
Cool.

16
00:00:25,740 --> 00:00:26,480
Put your hands down.

17
00:00:26,480 --> 00:00:28,370
For those you, how many people
have no idea what

18
00:00:28,370 --> 00:00:29,170
Native Client is?

19
00:00:29,170 --> 00:00:31,220
Or they've heard about it and
want to learn more, and that's

20
00:00:31,220 --> 00:00:32,670
why you're here?

21
00:00:32,670 --> 00:00:32,900
OK.

22
00:00:32,900 --> 00:00:33,300
Cool.

23
00:00:33,300 --> 00:00:33,890
That's good.

24
00:00:33,890 --> 00:00:35,280
That allows me to kind
of gauge how

25
00:00:35,280 --> 00:00:36,650
deep I dive into stuff.

26
00:00:36,650 --> 00:00:41,150
So Pepper 18 is the active SDK
build, as of right now.

27
00:00:41,150 --> 00:00:45,150
If you go to gonacl.com, you'll
be able to get our SDK

28
00:00:45,150 --> 00:00:46,980
and see all the documentation
that we're talking about

29
00:00:46,980 --> 00:00:51,100
today, as well as some other
amazing opportunities there.

30
00:00:51,100 --> 00:00:53,360
So let's get started.

31
00:00:53,360 --> 00:00:54,290
So it works.

32
00:00:54,290 --> 00:00:57,250
Native Client allows
you to run C and C

33
00:00:57,250 --> 00:00:58,410
code in a web page.

34
00:00:58,410 --> 00:00:59,990
Now this has been around
as a feature set

35
00:00:59,990 --> 00:01:01,190
for a long time now.

36
00:01:01,190 --> 00:01:03,140
But the most important thing,
and probably the coolest one

37
00:01:03,140 --> 00:01:06,610
about Native Client, is that
no plug-in is required.

38
00:01:06,610 --> 00:01:08,340
Now this is the kicker, right?

39
00:01:08,340 --> 00:01:11,040
I've got some statistical
information sitting in a vault

40
00:01:11,040 --> 00:01:13,940
somewhere that shows that, for
some games, they lose up to

41
00:01:13,940 --> 00:01:17,780
90% of the users that wanted
to play the game as soon as

42
00:01:17,780 --> 00:01:19,740
they are prompted to
install a plug-in.

43
00:01:19,740 --> 00:01:20,360
90%.

44
00:01:20,360 --> 00:01:23,050
Now if you're an indie in this
crowd, and you've got a

45
00:01:23,050 --> 00:01:25,720
mortgage and a wife and a
mother-in-law who thinks

46
00:01:25,720 --> 00:01:28,290
you're a bum because you're
a game developer and not a

47
00:01:28,290 --> 00:01:31,700
stockbroker, or something, 90%
of those developers wanted to

48
00:01:31,700 --> 00:01:32,500
give you money.

49
00:01:32,500 --> 00:01:33,800
And they couldn't because
you asked them

50
00:01:33,800 --> 00:01:34,850
to install a plug-in.

51
00:01:34,850 --> 00:01:36,830
So the goal here is
if no plug-in is

52
00:01:36,830 --> 00:01:38,650
required, that's fantastic.

53
00:01:38,650 --> 00:01:41,540
And if you're one of the
programmers who has worked in

54
00:01:41,540 --> 00:01:43,970
the games industry for the past
30 years, chances are

55
00:01:43,970 --> 00:01:47,470
you've got 30 years of C code
sitting around and 30 years of

56
00:01:47,470 --> 00:01:51,120
experience in C code sitting
around that can now migrate to

57
00:01:51,120 --> 00:01:53,180
the web, which is
amazing, right?

58
00:01:53,180 --> 00:01:55,470
Developers spend billions of
dollars cultivating this

59
00:01:55,470 --> 00:01:56,310
technology.

60
00:01:56,310 --> 00:01:58,290
And to get to the web right
now, they have to throw it

61
00:01:58,290 --> 00:02:00,270
away and rewrite it in some
other scripting language.

62
00:02:00,270 --> 00:02:03,320
But if you can use the direct
code, this is fantastic.

63
00:02:03,320 --> 00:02:05,890
It allows you to leverage your
existing technology to move

64
00:02:05,890 --> 00:02:08,110
into this new marketplace.

65
00:02:08,110 --> 00:02:12,550
So here's the gist. It all
starts with your C code.

66
00:02:12,550 --> 00:02:15,870
Native Client provides, in the
SDK, a version of a GCC and a

67
00:02:15,870 --> 00:02:20,800
G compiler that produces safe,
portable x86 code.

68
00:02:20,800 --> 00:02:22,960
This is provided in the
form of NEXEs, or

69
00:02:22,960 --> 00:02:24,580
Native Client exe.

70
00:02:24,580 --> 00:02:26,980
In addition to this, we'll
produce one for 32-bit and

71
00:02:26,980 --> 00:02:30,690
64-bit architectures, as well
as an NMF file, or a Native

72
00:02:30,690 --> 00:02:32,240
Client manifest file.

73
00:02:32,240 --> 00:02:35,990
The manifest effectively lists
which architecture goes to

74
00:02:35,990 --> 00:02:38,240
what file path for
what executable.

75
00:02:38,240 --> 00:02:40,320
So it says if you're running
a 32-bit, point to this

76
00:02:40,320 --> 00:02:40,595
executable.

77
00:02:40,595 --> 00:02:43,760
If you're running 64-bit,
run to that executable.

78
00:02:43,760 --> 00:02:47,380
You embed this information in an
HTML file using this small,

79
00:02:47,380 --> 00:02:48,290
little tag right here.

80
00:02:48,290 --> 00:02:49,610
So you make an embed element.

81
00:02:49,610 --> 00:02:50,270
You name it.

82
00:02:50,270 --> 00:02:50,880
You give it a height.

83
00:02:50,880 --> 00:02:53,060
You define your manifest.
You point to the

84
00:02:53,060 --> 00:02:54,020
manifest, not to the NEXEs.

85
00:02:54,020 --> 00:02:56,200
Because, remember, the
manifest defines

86
00:02:56,200 --> 00:02:57,460
what NEXE to use.

87
00:02:57,460 --> 00:02:59,970
And then you set an application
type right there.

88
00:02:59,970 --> 00:03:01,570
Once you do this, you've gone
through this process.

89
00:03:01,570 --> 00:03:02,580
You've compiled it.

90
00:03:02,580 --> 00:03:04,060
You've embedded it in a page.

91
00:03:04,060 --> 00:03:05,700
And then you load the
page up and boom!

92
00:03:05,700 --> 00:03:09,500
You see some amazing graphics on
the screen, stuff that you

93
00:03:09,500 --> 00:03:10,870
traditionally don't
see in a web game.

94
00:03:10,870 --> 00:03:14,660
This is actually a screen shot
from an Xbox 360 title running

95
00:03:14,660 --> 00:03:17,200
in Native Client that was ported
in about three months.

96
00:03:17,200 --> 00:03:20,010
That's amazing technology to see
post processing and full

97
00:03:20,010 --> 00:03:23,190
screen blend and skin animation
and color tint and

98
00:03:23,190 --> 00:03:25,040
all this just great stuff
there that you

99
00:03:25,040 --> 00:03:27,760
have access to now.

100
00:03:27,760 --> 00:03:28,880
So let's talk about the
first steps, your

101
00:03:28,880 --> 00:03:31,370
GCC and your G compiler.

102
00:03:31,370 --> 00:03:34,930
So to use these-- if anyone
here is a Linux developer,

103
00:03:34,930 --> 00:03:37,640
then you're very intimately
familiar with GCC and G If

104
00:03:37,640 --> 00:03:39,870
you're a Windows developer,
this is kind of new ground

105
00:03:39,870 --> 00:03:42,300
that's kind of awkward and
uncomfortable for you.

106
00:03:42,300 --> 00:03:45,740
But first off, to get your code
compiling in GCC and G ,

107
00:03:45,740 --> 00:03:48,360
you have to make sure that it's
ISO and IEC complaint,

108
00:03:48,360 --> 00:03:50,590
which effectively means that it
matches these protocols and

109
00:03:50,590 --> 00:03:51,090
these standards.

110
00:03:51,090 --> 00:03:54,550
Now it's probably not best to go
look at these standards and

111
00:03:54,550 --> 00:03:55,580
figure out the mapping.

112
00:03:55,580 --> 00:03:57,790
It's probably actually best to
try to compile your code in

113
00:03:57,790 --> 00:04:00,070
GCC, figure out what it
complains about, and then

114
00:04:00,070 --> 00:04:02,390
iterate that way.

115
00:04:02,390 --> 00:04:05,710
Predominately, this standard
defines POSIX style coding and

116
00:04:05,710 --> 00:04:06,100
functioning.

117
00:04:06,100 --> 00:04:09,260
So it uses syntaxes like p
threads as opposed to begin

118
00:04:09,260 --> 00:04:12,480
and end thread, as well as
conditional variables rather

119
00:04:12,480 --> 00:04:14,580
than retexes and other
things like that.

120
00:04:14,580 --> 00:04:16,670
In addition, this compliance
standard-- and this is the

121
00:04:16,670 --> 00:04:17,630
important one--

122
00:04:17,630 --> 00:04:20,720
does not define any
OS specific calls.

123
00:04:20,720 --> 00:04:24,920
So you can't access the
registry from GCC.

124
00:04:24,920 --> 00:04:25,880
That doesn't make sense.

125
00:04:25,880 --> 00:04:28,340
You can't open up a direct
video stream

126
00:04:28,340 --> 00:04:29,190
using direct media.

127
00:04:29,190 --> 00:04:30,520
That doesn't make sense
either, right?

128
00:04:30,520 --> 00:04:32,910
So you need to make sure that
your code is platform

129
00:04:32,910 --> 00:04:36,300
independent and uses these
POSIX-style calls.

130
00:04:36,300 --> 00:04:39,620
The GCC and G compilers also
do the amazing thing-- and

131
00:04:39,620 --> 00:04:41,350
this is sort of the linchpin--

132
00:04:41,350 --> 00:04:43,700
it removes any unsafe code.

133
00:04:43,700 --> 00:04:45,120
This is the whole point
of Native Client.

134
00:04:45,120 --> 00:04:49,640
The whole point is to execute
safe, portable assembly

135
00:04:49,640 --> 00:04:51,510
language code in
a web browser.

136
00:04:51,510 --> 00:04:54,090
Security is of the utmost
importance here, more than

137
00:04:54,090 --> 00:04:55,730
performance, more than
anything else.

138
00:04:55,730 --> 00:04:57,270
Although we are amazingly
performant.

139
00:04:57,270 --> 00:04:59,340
And I can give you those numbers
offline, if you're

140
00:04:59,340 --> 00:05:00,450
looking for it.

141
00:05:00,450 --> 00:05:03,190
But it removes all this unsafe
stuff and creates this nice

142
00:05:03,190 --> 00:05:05,940
little package that can run,
execute, in multiple places.

143
00:05:05,940 --> 00:05:08,690

144
00:05:08,690 --> 00:05:11,450
And so once you get this code--
and you're saying, OK,

145
00:05:11,450 --> 00:05:12,080
this is cool.

146
00:05:12,080 --> 00:05:13,790
I have the ability to
execute this code--

147
00:05:13,790 --> 00:05:16,000
how does it actually interact
with the system?

148
00:05:16,000 --> 00:05:18,910
So to understand how Native
Client gets access to these

149
00:05:18,910 --> 00:05:21,320
system-level resources, I have
to take a step back, and

150
00:05:21,320 --> 00:05:24,360
actually talk about how Chrome,
the web browser, gets

151
00:05:24,360 --> 00:05:26,340
access to these system-level
resources.

152
00:05:26,340 --> 00:05:29,920
So a long time ago, a company
made a plug-in architecture

153
00:05:29,920 --> 00:05:32,440
called NPAPI.

154
00:05:32,440 --> 00:05:35,500
Effectively, this plug-in
architecture allowed plug-ins

155
00:05:35,500 --> 00:05:38,090
to be developed for a browser
that then had access to lower

156
00:05:38,090 --> 00:05:40,060
level systems in various
ways, so that users

157
00:05:40,060 --> 00:05:41,380
can install the plug-in.

158
00:05:41,380 --> 00:05:43,990
And if the plug-in dll targeted
these header files,

159
00:05:43,990 --> 00:05:45,820
it had access to these things.

160
00:05:45,820 --> 00:05:49,340
Well, the problem was that
at its heyday, this NPAPI

161
00:05:49,340 --> 00:05:52,710
architecture was actually the
number one problem of malware

162
00:05:52,710 --> 00:05:54,200
and bugs in the environment.

163
00:05:54,200 --> 00:05:57,360
So Chrome went ahead and said,
we're going to support NPAPI.

164
00:05:57,360 --> 00:05:59,640
But we want to create a safer
version, so that we don't have

165
00:05:59,640 --> 00:06:01,450
to worry about all these
pop-ups, and

166
00:06:01,450 --> 00:06:02,810
spyware, and malware.

167
00:06:02,810 --> 00:06:06,540
So we created what we call the
Pepper API, or PPAPI, which is

168
00:06:06,540 --> 00:06:10,280
a plug-in architecture that
allows you to target file IO,

169
00:06:10,280 --> 00:06:12,510
rendering, audio, and even
have the ability to

170
00:06:12,510 --> 00:06:15,970
communicate back to the page
that's hosting the plug-in

171
00:06:15,970 --> 00:06:18,180
through JavaScript post
message results.

172
00:06:18,180 --> 00:06:20,650
So understanding this, that
there's effectively a Pepper

173
00:06:20,650 --> 00:06:24,640
API that allows plug-ins to
access these inner workings

174
00:06:24,640 --> 00:06:28,230
through Chrome, Native Client
is effectively a module that

175
00:06:28,230 --> 00:06:29,150
communicates with this.

176
00:06:29,150 --> 00:06:32,170
So your NEXE file, when you
compile it, you'll target

177
00:06:32,170 --> 00:06:34,690
these specific headers to do
things like file IO, audio,

178
00:06:34,690 --> 00:06:36,090
rendering, and JavaScript.

179
00:06:36,090 --> 00:06:38,650
This is how your program gets
access to the lower level

180
00:06:38,650 --> 00:06:40,830
architecture.

181
00:06:40,830 --> 00:06:43,150
Now it's worth noting this, too,
is that the Pepper thread

182
00:06:43,150 --> 00:06:46,140
is actually running on the
main thread of Chrome.

183
00:06:46,140 --> 00:06:47,370
So your Native Client module is

184
00:06:47,370 --> 00:06:49,060
sitting there doing execution.

185
00:06:49,060 --> 00:06:51,180
Also on this main thread,
though, are some other

186
00:06:51,180 --> 00:06:53,360
important buddies that you
need to be aware of.

187
00:06:53,360 --> 00:06:54,570
First off is WebKit.

188
00:06:54,570 --> 00:06:56,200
WebKit executes on
the same thread.

189
00:06:56,200 --> 00:06:58,670
This is the layout
organizational DOM rendering

190
00:06:58,670 --> 00:06:59,630
style engine.

191
00:06:59,630 --> 00:07:00,910
It is out there open source.

192
00:07:00,910 --> 00:07:04,260
Also V8, which is Chrome's
virtual machine for handling

193
00:07:04,260 --> 00:07:07,160
JavaScript, as well as some
other fun stuff like Web RTC,

194
00:07:07,160 --> 00:07:09,260
audio processing, video, and
all this other stuff.

195
00:07:09,260 --> 00:07:12,010
The important takeaway you
should see here is that your

196
00:07:12,010 --> 00:07:15,090
Native Client module has the
ability to effectively stall

197
00:07:15,090 --> 00:07:17,580
out this main thread not
doing correctly.

198
00:07:17,580 --> 00:07:21,180
So if you go in and put a spin
loop on your main thread,

199
00:07:21,180 --> 00:07:23,290
you're effectively going to
halt the entire web page,

200
00:07:23,290 --> 00:07:26,240
because the WebKit doesn't get
the input processing, and V8

201
00:07:26,240 --> 00:07:27,440
doesn't get JavaScript
processing.

202
00:07:27,440 --> 00:07:30,680
So it's going to stall the tab
and effectively crash out.

203
00:07:30,680 --> 00:07:34,000
Because of this, you're not
supposed to call any blocking

204
00:07:34,000 --> 00:07:35,730
functions on the main thread.

205
00:07:35,730 --> 00:07:38,350
This is a bad idea, so none of
your code should be calling

206
00:07:38,350 --> 00:07:40,600
blocking functions on
the main thread.

207
00:07:40,600 --> 00:07:43,930
And because of that, the
Pepper API's are all

208
00:07:43,930 --> 00:07:45,180
asynchronous.

209
00:07:45,180 --> 00:07:47,660
None of them are blocking
at all.

210
00:07:47,660 --> 00:07:50,250
This means that you can call the
Pepper API from the main

211
00:07:50,250 --> 00:07:51,690
thread, and then some
time in the future

212
00:07:51,690 --> 00:07:53,830
you'll get that result.

213
00:07:53,830 --> 00:07:55,240
Generally, that's
about one frame.

214
00:07:55,240 --> 00:07:57,230
So if you looked at that
previous diagram, you can see

215
00:07:57,230 --> 00:07:59,600
that we've got WebKit, we've
got V8, and then we've got

216
00:07:59,600 --> 00:08:00,610
NaCl and some other stuff.

217
00:08:00,610 --> 00:08:03,396
So if NaCl says, hey, I want
to go load this file, it's

218
00:08:03,396 --> 00:08:05,390
going to kick off a request. And
then we have to generally

219
00:08:05,390 --> 00:08:07,980
wait until WebKit, V8 gets
processed and the plug-in

220
00:08:07,980 --> 00:08:10,440
frame gets processed before
those results can be given

221
00:08:10,440 --> 00:08:15,270
back to the main thread of your
Native Client module.

222
00:08:15,270 --> 00:08:18,820
Also, one of the restrictions
of Pepper is that all the

223
00:08:18,820 --> 00:08:20,900
Pepper API's must be called
from the main

224
00:08:20,900 --> 00:08:21,570
thread right now.

225
00:08:21,570 --> 00:08:23,920
This is a current restriction
that our team is actively

226
00:08:23,920 --> 00:08:25,480
working on to fix.

227
00:08:25,480 --> 00:08:27,370
But this has some potential
downsides that you

228
00:08:27,370 --> 00:08:29,990
need to be aware of.

229
00:08:29,990 --> 00:08:31,300
Before we dive into
that, let's talk

230
00:08:31,300 --> 00:08:32,340
about how this works.

231
00:08:32,340 --> 00:08:35,460
So on the top here we've got a
function that shows how to do

232
00:08:35,460 --> 00:08:36,400
file layout.

233
00:08:36,400 --> 00:08:37,120
So we've got a function.

234
00:08:37,120 --> 00:08:39,490
We're asserting that this is
coming from the main thread.

235
00:08:39,490 --> 00:08:41,610
We get some information
from the user.

236
00:08:41,610 --> 00:08:43,679
And we actually call
FileIO.Open.

237
00:08:43,679 --> 00:08:46,840
With FileIO.Open you actually
provide a completion callback.

238
00:08:46,840 --> 00:08:49,990
The completion callback will
occur once this file open

239
00:08:49,990 --> 00:08:52,380
request has occurred at the
lower level, the Pepper API

240
00:08:52,380 --> 00:08:55,120
level, and the results of that
will be pushed back to you.

241
00:08:55,120 --> 00:08:56,880
That's the second function
here you can see

242
00:08:56,880 --> 00:08:59,620
open, f open callback.

243
00:08:59,620 --> 00:09:01,870
This will get called on your
main thread once everything

244
00:09:01,870 --> 00:09:05,240
has been done in the lower
bowels of Chrome and the

245
00:09:05,240 --> 00:09:06,200
Pepper API's.

246
00:09:06,200 --> 00:09:07,750
And then you can, yay,
do some stuff.

247
00:09:07,750 --> 00:09:08,640
Show a cat.

248
00:09:08,640 --> 00:09:09,350
Issue a read.

249
00:09:09,350 --> 00:09:11,770
Whatever you need to
do at that point.

250
00:09:11,770 --> 00:09:13,870
So this is sort of a problem.

251
00:09:13,870 --> 00:09:16,630
Because this works in a very
different way than all of your

252
00:09:16,630 --> 00:09:18,440
architectures.

253
00:09:18,440 --> 00:09:20,170
This is not how your game
engine is designed.

254
00:09:20,170 --> 00:09:21,440
I can guarantee this
is not how your

255
00:09:21,440 --> 00:09:22,330
game engine is designed.

256
00:09:22,330 --> 00:09:25,780
Even if you have asynchronous
loading in your game, sooner

257
00:09:25,780 --> 00:09:27,040
or later you're going
to expect f read

258
00:09:27,040 --> 00:09:28,020
as a blocking function.

259
00:09:28,020 --> 00:09:29,520
You've got everything
working around that.

260
00:09:29,520 --> 00:09:32,160
More importantly, you probably
have f read calls coming from

261
00:09:32,160 --> 00:09:35,260
the main thread, which, in
general, is a problem.

262
00:09:35,260 --> 00:09:40,900
So the point next is how do
you design around this?

263
00:09:40,900 --> 00:09:41,750
How do you beat this?

264
00:09:41,750 --> 00:09:42,870
How do you say--

265
00:09:42,870 --> 00:09:43,840
how do I touch my code?

266
00:09:43,840 --> 00:09:47,370
Well, one idea is to modify
all of your f reads to use

267
00:09:47,370 --> 00:09:49,220
this blocking callback system.

268
00:09:49,220 --> 00:09:50,310
Or how do you do these
other things?

269
00:09:50,310 --> 00:09:51,830
Make sure the thread
doesn't stall.

270
00:09:51,830 --> 00:09:52,250
Forget all that.

271
00:09:52,250 --> 00:09:54,470
I'm going to give you the
shortcut I'm going to drop

272
00:09:54,470 --> 00:09:55,450
some wisdom on you.

273
00:09:55,450 --> 00:09:57,030
I'm going to point my knowledge
cannon in your

274
00:09:57,030 --> 00:09:59,810
direction, and give you
a blast of info.

275
00:09:59,810 --> 00:10:02,930
The best idea is to actually
spin up a thread and run your

276
00:10:02,930 --> 00:10:05,570
main game logic on
that thread.

277
00:10:05,570 --> 00:10:09,820
And leave the original main
thread as the Pepper thread.

278
00:10:09,820 --> 00:10:12,070
Basically, what this allows you
to do is you wrap all of

279
00:10:12,070 --> 00:10:15,350
your platform functions to issue
communication back and

280
00:10:15,350 --> 00:10:17,050
forth to the main thread.

281
00:10:17,050 --> 00:10:19,090
Let's take a look at what
that looks like here.

282
00:10:19,090 --> 00:10:21,840
So your game has the Pepper
thread or the main thread.

283
00:10:21,840 --> 00:10:23,310
That spawns off your
logic thread.

284
00:10:23,310 --> 00:10:26,190
Now the logic thread is
effectively going to run the

285
00:10:26,190 --> 00:10:28,500
main loop, while true--

286
00:10:28,500 --> 00:10:32,300
update, render, network, update,
network, render.

287
00:10:32,300 --> 00:10:33,110
Do all that stuff.

288
00:10:33,110 --> 00:10:34,490
And it's going to just continue
doing that on the

289
00:10:34,490 --> 00:10:35,890
logic thread.

290
00:10:35,890 --> 00:10:38,280
The Pepper thread is the
only access to FileIO,

291
00:10:38,280 --> 00:10:39,260
JavaScript, and audio.

292
00:10:39,260 --> 00:10:42,030
Your logic thread should not
have direct access to that.

293
00:10:42,030 --> 00:10:44,880
Instead, the logic thread will
call specific commands, which

294
00:10:44,880 --> 00:10:47,570
pushes a function to the
Pepper thread and

295
00:10:47,570 --> 00:10:48,970
then it will block.

296
00:10:48,970 --> 00:10:51,190
The Pepper thread will then
receive that function,

297
00:10:51,190 --> 00:10:54,790
communicate off to the lower
level IO, do its fun stuff,

298
00:10:54,790 --> 00:10:58,260
return that data to the Pepper
thread, and the Pepper thread

299
00:10:58,260 --> 00:11:00,130
will then return that
data to your logic

300
00:11:00,130 --> 00:11:01,590
thread in the fashion.

301
00:11:01,590 --> 00:11:05,220
What this means is that you can
overload f read, f write,

302
00:11:05,220 --> 00:11:08,030
blocking functions like that,
to effectively do the same

303
00:11:08,030 --> 00:11:09,300
thing that you would
expect them to

304
00:11:09,300 --> 00:11:10,910
already do in your game.

305
00:11:10,910 --> 00:11:13,910
You just effectively create this
abstraction layer around

306
00:11:13,910 --> 00:11:15,720
them, so that it actually
communicates with the Pepper

307
00:11:15,720 --> 00:11:18,100
thread in a proper manner
without actually having to

308
00:11:18,100 --> 00:11:19,445
touch all the lines
of code that

309
00:11:19,445 --> 00:11:21,810
you've already got written.

310
00:11:21,810 --> 00:11:23,430
Here's an example of how
to look at this.

311
00:11:23,430 --> 00:11:26,000
So this top function here
is request and wait.

312
00:11:26,000 --> 00:11:28,090
So what this will do is assert
that, first off, you're not

313
00:11:28,090 --> 00:11:28,900
running on the main thread.

314
00:11:28,900 --> 00:11:30,240
You're running on
a worker thread.

315
00:11:30,240 --> 00:11:33,870
And Native Client and Pepper
actually provide a nice little

316
00:11:33,870 --> 00:11:37,840
API that will auto call your
function on the main thread on

317
00:11:37,840 --> 00:11:39,570
your behalf, so that you don't
have to write all the

318
00:11:39,570 --> 00:11:42,490
intricate threading, and
messaging, and queuing logic

319
00:11:42,490 --> 00:11:43,610
to get it to call there.

320
00:11:43,610 --> 00:11:46,840
So simply, you call
module.get.core.

321
00:11:46,840 --> 00:11:47,990
Call on main thread.

322
00:11:47,990 --> 00:11:50,570
And you effectively pass
it a callback function.

323
00:11:50,570 --> 00:11:53,820
And this will ensure that your
callback function will get

324
00:11:53,820 --> 00:11:55,030
pushed into the proper queues.

325
00:11:55,030 --> 00:11:56,715
And it will be called in the
main thread the next time a

326
00:11:56,715 --> 00:11:58,100
frame process happens.

327
00:11:58,100 --> 00:12:00,690
Now what's nice about this is
that this allows you, on the

328
00:12:00,690 --> 00:12:03,680
calling thread, to then set a
conditional data variable and

329
00:12:03,680 --> 00:12:04,770
sit around and wait.

330
00:12:04,770 --> 00:12:07,010
So with this function here, you
actually issue a function

331
00:12:07,010 --> 00:12:10,000
command, wait until it has been
called and executed on

332
00:12:10,000 --> 00:12:12,930
the main thread and control
has been returned.

333
00:12:12,930 --> 00:12:14,960
And you can see on the bottom
here, this is the return from

334
00:12:14,960 --> 00:12:16,920
main thread function.

335
00:12:16,920 --> 00:12:19,360
Effectively what this does is,
first off, asserts that you're

336
00:12:19,360 --> 00:12:20,780
on the main thread, because
you want to make sure your

337
00:12:20,780 --> 00:12:21,050
code's clean.

338
00:12:21,050 --> 00:12:22,800
You want to make sure you're
doing the right thing.

339
00:12:22,800 --> 00:12:24,420
And then it will actually get
the information that has been

340
00:12:24,420 --> 00:12:26,930
passed to it as a callback
parameter, set some result,

341
00:12:26,930 --> 00:12:29,170
and then signal the conditional
signal.

342
00:12:29,170 --> 00:12:31,270
That signal right there, that
event, that p thread

343
00:12:31,270 --> 00:12:34,910
conditional, will allow the
worker thread, the logic

344
00:12:34,910 --> 00:12:37,040
thread, that actually issued the
command to then wake up,

345
00:12:37,040 --> 00:12:38,820
continue doing what it was
doing, and move on.

346
00:12:38,820 --> 00:12:39,750
This is fantastic.

347
00:12:39,750 --> 00:12:41,950
With these two little functions
right here, you can

348
00:12:41,950 --> 00:12:44,930
implement a structure around it
that allow you to overload

349
00:12:44,930 --> 00:12:47,630
f read and f write and those
other functions to be blocking

350
00:12:47,630 --> 00:12:50,320
functions from the
logic thread.

351
00:12:50,320 --> 00:12:51,790
So this is effectively
what happens.

352
00:12:51,790 --> 00:12:54,280
You end up in a situation where
you start calling data.

353
00:12:54,280 --> 00:12:54,720
It blocks.

354
00:12:54,720 --> 00:12:55,280
Comes back.

355
00:12:55,280 --> 00:12:56,970
Calls data, blocks,
comes back.

356
00:12:56,970 --> 00:12:59,980
And this is fine for a lot of
functions that you expect to

357
00:12:59,980 --> 00:13:00,480
work this way.

358
00:13:00,480 --> 00:13:02,550
Your architecture will
transition over seamlessly.

359
00:13:02,550 --> 00:13:04,390
And you won't have to
worry about it.

360
00:13:04,390 --> 00:13:08,610
The problem turns into function
APIs that don't

361
00:13:08,610 --> 00:13:10,550
benefit from working
in this fashion.

362
00:13:10,550 --> 00:13:11,900
For example, rendering.

363
00:13:11,900 --> 00:13:13,920
Rendering works very
differently.

364
00:13:13,920 --> 00:13:15,910
Rendering expects that I
shouldn't have to block for

365
00:13:15,910 --> 00:13:19,080
lots and lots of frames to
submit each instance.

366
00:13:19,080 --> 00:13:21,310
In that situation, what you want
to do is for these types

367
00:13:21,310 --> 00:13:24,710
of calls that are best for
fire and forget, that you

368
00:13:24,710 --> 00:13:26,030
don't actually wait
for a response.

369
00:13:26,030 --> 00:13:27,800
These things don't need
any information back

370
00:13:27,800 --> 00:13:28,820
from the main thread.

371
00:13:28,820 --> 00:13:31,200
As such, you should just fire
them off very quickly and

372
00:13:31,200 --> 00:13:33,310
allow the logic thread
to move on.

373
00:13:33,310 --> 00:13:35,730
So you can see here you get
three fires really quick.

374
00:13:35,730 --> 00:13:37,490
And then the Pepper thread
spends its time doing the

375
00:13:37,490 --> 00:13:40,430
proper resource handling to the
underlying architecture

376
00:13:40,430 --> 00:13:42,090
without you having to block.

377
00:13:42,090 --> 00:13:44,700
Now for rendering, there's
actually a different process

378
00:13:44,700 --> 00:13:46,220
involved here that you can
actually think about in a

379
00:13:46,220 --> 00:13:47,680
different way.

380
00:13:47,680 --> 00:13:52,010
A very modern graphics engine
mechanic is actually the

381
00:13:52,010 --> 00:13:55,280
concept of buffering up all of
your draw commands, submitting

382
00:13:55,280 --> 00:13:58,860
them off to the Pepper thread at
a various form, so that it

383
00:13:58,860 --> 00:14:00,570
kind of gets the entire frame.

384
00:14:00,570 --> 00:14:03,160
And then it starts queuing
through it properly.

385
00:14:03,160 --> 00:14:05,460
So what happens is your logic
thread will go and do the

386
00:14:05,460 --> 00:14:07,050
rendering, actually
create the calls.

387
00:14:07,050 --> 00:14:09,230
But instead of actually doing
the rendering and calling the

388
00:14:09,230 --> 00:14:12,100
APIs, what happens is you
overload the API to create a

389
00:14:12,100 --> 00:14:15,750
small, little representation,
like a quad word or some form

390
00:14:15,750 --> 00:14:17,950
of it that gets pushed
into an FIFO.

391
00:14:17,950 --> 00:14:20,500
And that FIFO is then consumed
by the Pepper thread, and

392
00:14:20,500 --> 00:14:23,140
issued off to the appropriate
engines below that.

393
00:14:23,140 --> 00:14:25,180
Now this is important, that what
you're effectively doing

394
00:14:25,180 --> 00:14:27,700
here is you're creating a
waterfall processing method,

395
00:14:27,700 --> 00:14:30,960
or a producer consumer FIFO
between your logic thread and

396
00:14:30,960 --> 00:14:33,380
your Pepper thread, where the
logic thread will do logic

397
00:14:33,380 --> 00:14:37,020
frame n, kick off the rendering
results for that.

398
00:14:37,020 --> 00:14:40,670
And render thread will then do
render frame n while the logic

399
00:14:40,670 --> 00:14:42,470
thread moves on to
the next frame.

400
00:14:42,470 --> 00:14:45,390
This, again, is a very
common paradigm for

401
00:14:45,390 --> 00:14:46,430
next generation consoles--

402
00:14:46,430 --> 00:14:48,240
Xbox 360, PS3.

403
00:14:48,240 --> 00:14:49,530
This is what you're doing
in a lot of your

404
00:14:49,530 --> 00:14:50,690
systems right here.

405
00:14:50,690 --> 00:14:52,510
Traditionally they call the
Pepper thread the render

406
00:14:52,510 --> 00:14:53,520
thread at that point.

407
00:14:53,520 --> 00:14:55,430
And there's some variation
of what data is

408
00:14:55,430 --> 00:14:56,760
pushed between the two.

409
00:14:56,760 --> 00:15:00,250
In this particular method, you
want no logic occurring on the

410
00:15:00,250 --> 00:15:03,910
Pepper thread other than just
rendering your data.

411
00:15:03,910 --> 00:15:06,190
So that's the ecosystem
that you're in.

412
00:15:06,190 --> 00:15:07,590
That's sort of what you're
dealing with.

413
00:15:07,590 --> 00:15:10,245
Basically, what you need to do
is spin off a logic threat and

414
00:15:10,245 --> 00:15:13,000
then modify your code such that
you handle two different

415
00:15:13,000 --> 00:15:13,960
types of calls.

416
00:15:13,960 --> 00:15:15,930
You've got the calls that
require feedback from the

417
00:15:15,930 --> 00:15:16,570
Pepper thread.

418
00:15:16,570 --> 00:15:18,130
And then those you need to
block and wait for that

419
00:15:18,130 --> 00:15:19,400
information to return.

420
00:15:19,400 --> 00:15:21,110
And then you've got the
fire and forget calls.

421
00:15:21,110 --> 00:15:23,490
And those are the calls that
you just either issue

422
00:15:23,490 --> 00:15:25,150
immediately and then
keep moving on.

423
00:15:25,150 --> 00:15:27,710
Or you bundle up into some
sort of frame or boundary

424
00:15:27,710 --> 00:15:29,930
mechanic and submit in one
batch, and then let the Pepper

425
00:15:29,930 --> 00:15:32,670
thread do its thing while you're
logic thread moves on.

426
00:15:32,670 --> 00:15:34,510
So once you understand the
environment that you're in,

427
00:15:34,510 --> 00:15:36,630
because of the Pepper API
restrictions, which are

428
00:15:36,630 --> 00:15:39,320
temporary, by the way, now you
can actually start porting the

429
00:15:39,320 --> 00:15:40,440
rest of your code.

430
00:15:40,440 --> 00:15:41,620
And this involves understanding

431
00:15:41,620 --> 00:15:42,630
at a number of levels.

432
00:15:42,630 --> 00:15:44,690
So let's dive in.

433
00:15:44,690 --> 00:15:46,200
The first is FileIO.

434
00:15:46,200 --> 00:15:48,630
So if you've never developed a
web game, let me clue you in

435
00:15:48,630 --> 00:15:49,970
on some specific information.

436
00:15:49,970 --> 00:15:54,300
You're going to put your HTML
datas and your NEXE datas and

437
00:15:54,300 --> 00:15:57,030
your NMF datas on some
server somewhere.

438
00:15:57,030 --> 00:16:00,940
And when the user loads your
page that embeds this module,

439
00:16:00,940 --> 00:16:03,410
it's going to be received by the
client and auto-cached by

440
00:16:03,410 --> 00:16:04,960
Chrome on your behalf.

441
00:16:04,960 --> 00:16:06,720
This is just going to happen
automatically.

442
00:16:06,720 --> 00:16:09,180
And it will grab the HTML data,
the NEXE data, and the

443
00:16:09,180 --> 00:16:11,340
NMF data and cache it for
you because it's defined

444
00:16:11,340 --> 00:16:12,460
in the embed tag.

445
00:16:12,460 --> 00:16:13,470
And this is great.

446
00:16:13,470 --> 00:16:14,850
This means that Chrome
is handling your

447
00:16:14,850 --> 00:16:16,150
caching on your behalf.

448
00:16:16,150 --> 00:16:17,300
You don't have to do
anything else.

449
00:16:17,300 --> 00:16:19,590
You just sit back, hands
behind your head,

450
00:16:19,590 --> 00:16:20,250
allow it all to happen.

451
00:16:20,250 --> 00:16:21,600
It's good to go.

452
00:16:21,600 --> 00:16:22,840
The problem is that
there's other data

453
00:16:22,840 --> 00:16:23,580
that your game needs.

454
00:16:23,580 --> 00:16:26,180
There are zip files, for
instance, ZIP0 and ZIP1.

455
00:16:26,180 --> 00:16:28,690
These will not be pulled down
automatically for you when the

456
00:16:28,690 --> 00:16:29,880
user loads your page.

457
00:16:29,880 --> 00:16:33,830
Instead, for these, you have to
use a GetURL API inside of

458
00:16:33,830 --> 00:16:37,910
Pepper or an XHR request
inside of JavaScript.

459
00:16:37,910 --> 00:16:40,310
And that will pull down
these binary assets.

460
00:16:40,310 --> 00:16:43,120
Now the cool thing is that
with this call, with the

461
00:16:43,120 --> 00:16:45,910
GetURL call, it will also
cache itself in

462
00:16:45,910 --> 00:16:46,860
Chrome on your behalf.

463
00:16:46,860 --> 00:16:48,460
So you can actually fetch
these zip files.

464
00:16:48,460 --> 00:16:49,360
Chrome will cache it.

465
00:16:49,360 --> 00:16:51,450
And then the next time the
user asks for it, it will

466
00:16:51,450 --> 00:16:52,430
already be in the cache.

467
00:16:52,430 --> 00:16:53,870
And they can get it from there,
as opposed to going

468
00:16:53,870 --> 00:16:57,810
back to the server, which
is a longer round trip.

469
00:16:57,810 --> 00:17:00,190
One of the interesting things
about this, though, is that

470
00:17:00,190 --> 00:17:03,430
when your data is in the cache,
it can also be evicted

471
00:17:03,430 --> 00:17:05,180
from the cache at
any single time.

472
00:17:05,180 --> 00:17:07,780
The user can go and load a
website which uses more data.

473
00:17:07,780 --> 00:17:10,190
Or they can clear the
cache themselves.

474
00:17:10,190 --> 00:17:13,150
But basically, they can purge
all of this asset storing that

475
00:17:13,150 --> 00:17:16,540
you're doing on their behalf, so
that the experience in your

476
00:17:16,540 --> 00:17:18,230
game is not as optimal
as it should be.

477
00:17:18,230 --> 00:17:19,630
And this is a bad thing.

478
00:17:19,630 --> 00:17:21,790
To answer this, there's actually
a cool little API

479
00:17:21,790 --> 00:17:23,960
inside of Pepper called
the File Store API.

480
00:17:23,960 --> 00:17:27,319
The File Store API will allow
you to grab data inside of the

481
00:17:27,319 --> 00:17:32,140
client's memory and store it
to a persistent sandboxed

482
00:17:32,140 --> 00:17:33,960
obfuscated file store.

483
00:17:33,960 --> 00:17:37,690
Now, this data will exist on
disk until one of two things

484
00:17:37,690 --> 00:17:39,240
happens or both will happen.

485
00:17:39,240 --> 00:17:42,810
The user navigates to this
sandbox system somehow through

486
00:17:42,810 --> 00:17:44,950
their API and their operating
system and

487
00:17:44,950 --> 00:17:47,010
manually deletes the data.

488
00:17:47,010 --> 00:17:50,010
Or your program deletes
the data.

489
00:17:50,010 --> 00:17:52,140
So effectively this allows you
to take control over the

490
00:17:52,140 --> 00:17:53,770
caching mechanisms that
are used during

491
00:17:53,770 --> 00:17:54,950
this transfer process.

492
00:17:54,950 --> 00:17:57,710
So definitely make sure
you're using that.

493
00:17:57,710 --> 00:17:59,130
You can click the link at
the bottom here for more

494
00:17:59,130 --> 00:17:59,550
information.

495
00:17:59,550 --> 00:18:01,300
That actually directs
to gonacl.com.

496
00:18:01,300 --> 00:18:03,260
We have a specific article
on how to do all this.

497
00:18:03,260 --> 00:18:05,820

498
00:18:05,820 --> 00:18:07,060
FileIO and shutdown.

499
00:18:07,060 --> 00:18:10,700
Console developers in here, you
will help me lament over

500
00:18:10,700 --> 00:18:14,460
the process of trying to write
to a memory stick that has

501
00:18:14,460 --> 00:18:16,190
been pushed into a console.

502
00:18:16,190 --> 00:18:18,280
And as you're writing, the
user rips the stick out

503
00:18:18,280 --> 00:18:19,290
because they think it's done.

504
00:18:19,290 --> 00:18:20,340
And now, all of a sudden,
you have--

505
00:18:20,340 --> 00:18:21,910
effectively the world
explodes.

506
00:18:21,910 --> 00:18:23,590
The data written to
disk is corrupted.

507
00:18:23,590 --> 00:18:25,290
The information being
transferred is corrupted.

508
00:18:25,290 --> 00:18:28,460
And the user is mad at you
because you didn't know they

509
00:18:28,460 --> 00:18:29,725
were going to rip
the stick out.

510
00:18:29,725 --> 00:18:30,000
Who knows?

511
00:18:30,000 --> 00:18:33,420
Well, anyhow, in a web page
you have the same problem.

512
00:18:33,420 --> 00:18:35,630
When you're trying to write data
to your persistent file

513
00:18:35,630 --> 00:18:37,720
store, the user can tab away.

514
00:18:37,720 --> 00:18:39,390
They can close the data.

515
00:18:39,390 --> 00:18:40,450
A crash can occur.

516
00:18:40,450 --> 00:18:41,790
Something can happen
that effectively

517
00:18:41,790 --> 00:18:43,060
does the same process.

518
00:18:43,060 --> 00:18:45,470
It effectively deteriorates
the data.

519
00:18:45,470 --> 00:18:46,860
Stops the write.

520
00:18:46,860 --> 00:18:48,780
Causes problems of all sorts.

521
00:18:48,780 --> 00:18:51,410
So if you've actually opened
this file and tried to write

522
00:18:51,410 --> 00:18:54,230
to it, when you try to load it
the next time around, the

523
00:18:54,230 --> 00:18:55,550
information is going
to be corrupt.

524
00:18:55,550 --> 00:18:57,110
Basically, you're going
to lose it.

525
00:18:57,110 --> 00:19:00,820
The better methodology here is
for any writes to file, what

526
00:19:00,820 --> 00:19:03,130
you actually want to do is write
to a separate file or a

527
00:19:03,130 --> 00:19:06,120
duplicate file and communicate
all of your data there.

528
00:19:06,120 --> 00:19:10,020
And then once all of your
writing has been finalized, at

529
00:19:10,020 --> 00:19:14,050
the end of your process, you
actually then move, rename,

530
00:19:14,050 --> 00:19:17,880
some process, over to the
intended position.

531
00:19:17,880 --> 00:19:21,050
And this means-- what occurs
here is that if the chance

532
00:19:21,050 --> 00:19:24,205
that the user corrupts the data
during the write to the

533
00:19:24,205 --> 00:19:26,550
persistent file store, that it
doesn't actually corrupt the

534
00:19:26,550 --> 00:19:27,755
original data on disks.

535
00:19:27,755 --> 00:19:30,320
So when the user loads the game
next time, all they've

536
00:19:30,320 --> 00:19:34,260
lost is the delta between the
last time they've saved, as

537
00:19:34,260 --> 00:19:39,300
opposed to your entire saved
file, which is a good thing.

538
00:19:39,300 --> 00:19:41,970
Now for those of you who are
doing FileIO, there is a

539
00:19:41,970 --> 00:19:45,220
really cool mode that's recent,
that's actually a

540
00:19:45,220 --> 00:19:46,880
dangerous FileIO.

541
00:19:46,880 --> 00:19:49,160
And there's some terminology
about why you want to call it

542
00:19:49,160 --> 00:19:49,860
dangerous or not.

543
00:19:49,860 --> 00:19:51,630
But this is really helpful
to those of you who are

544
00:19:51,630 --> 00:19:52,540
developers.

545
00:19:52,540 --> 00:19:55,700
So in developer mode, you can
actually write directly to

546
00:19:55,700 --> 00:19:59,220
disk outside of the obfuscated
sandbox.

547
00:19:59,220 --> 00:20:00,950
This is really helpful.

548
00:20:00,950 --> 00:20:03,200
Effectively, when you launch
Chrome, you can send an

549
00:20:03,200 --> 00:20:06,260
environment variable, NaCl
Dangerous Enable File Access.

550
00:20:06,260 --> 00:20:07,620
And then you run Chrome
with no sandbox.

551
00:20:07,620 --> 00:20:10,550
This effectively turns off some
of the security handles

552
00:20:10,550 --> 00:20:12,380
that you have available
to you.

553
00:20:12,380 --> 00:20:14,990
And then in the code, in your
C code, you actually do a

554
00:20:14,990 --> 00:20:18,530
direct f open and start
writing to it.

555
00:20:18,530 --> 00:20:21,300
And what this will do is
actually create a file in the

556
00:20:21,300 --> 00:20:24,240
application location
of where NaCl is.

557
00:20:24,240 --> 00:20:26,770
So for instance, path to Chrome
slash build number.

558
00:20:26,770 --> 00:20:29,010
That's where NaCl.exe exists.

559
00:20:29,010 --> 00:20:31,270
So with this set up here,
this actually creates a

560
00:20:31,270 --> 00:20:34,900
tracelog.txt in my application
folder for Chrome 19, which is

561
00:20:34,900 --> 00:20:36,090
currently in Canary.

562
00:20:36,090 --> 00:20:37,500
This is amazing.

563
00:20:37,500 --> 00:20:39,690
So for those of you developers
who are trying to do inline

564
00:20:39,690 --> 00:20:45,170
profiling or trying to dump
crash disks or crash logs to

565
00:20:45,170 --> 00:20:47,740
disk in these sorts of fashions,
having to wait for

566
00:20:47,740 --> 00:20:50,420
the asynchronous file system
is just not doable.

567
00:20:50,420 --> 00:20:52,540
Instead, you actually want
to control writing

568
00:20:52,540 --> 00:20:53,500
directly to a disk.

569
00:20:53,500 --> 00:20:55,000
And this gives you
that ability.

570
00:20:55,000 --> 00:20:56,180
This is really important.

571
00:20:56,180 --> 00:20:57,750
It allows you to move
forward with getting

572
00:20:57,750 --> 00:20:58,570
all this stuff done.

573
00:20:58,570 --> 00:21:00,040
And you can click that
link there for more.

574
00:21:00,040 --> 00:21:03,500
It's got more information on
it and how you use it.

575
00:21:03,500 --> 00:21:04,610
Rendering.

576
00:21:04,610 --> 00:21:09,540
So first off, Native Client
uses OpenGL ES 2.0 as a

577
00:21:09,540 --> 00:21:10,450
rendering API.

578
00:21:10,450 --> 00:21:14,260
So this is the same API that's
used on mobile devices today.

579
00:21:14,260 --> 00:21:17,190
Porting your game to use
this is step one.

580
00:21:17,190 --> 00:21:19,070
So if you're using DirectX, you
need to port your stuff

581
00:21:19,070 --> 00:21:20,850
over to OpenGL first, because
that will be an easy

582
00:21:20,850 --> 00:21:21,900
transition for you.

583
00:21:21,900 --> 00:21:25,280
And then from OpenGL, you need
to move to OpenGL ES 2.0.

584
00:21:25,280 --> 00:21:27,040
You can do this using a project

585
00:21:27,040 --> 00:21:28,820
called ANGLE on Windows.

586
00:21:28,820 --> 00:21:30,140
If you click that link,
there's a source code

587
00:21:30,140 --> 00:21:31,730
repository there where
the entire

588
00:21:31,730 --> 00:21:32,760
source code is available.

589
00:21:32,760 --> 00:21:38,170
Effectively, ANGLE is a dll
suite that provides OpenGL ES

590
00:21:38,170 --> 00:21:41,930
2.0 headers that you can then
target that will translate to

591
00:21:41,930 --> 00:21:43,150
DirectX calls internally.

592
00:21:43,150 --> 00:21:45,670
So you can effectively test how
your code is working and

593
00:21:45,670 --> 00:21:46,650
do this all on Windows.

594
00:21:46,650 --> 00:21:49,960
To note, there's no OpenGL ES
2.0 runtime on Windows.

595
00:21:49,960 --> 00:21:52,720
It doesn't exist. So if you're
going to try to test this on

596
00:21:52,720 --> 00:21:56,560
Windows, you're going to
need to use ANGLE.

597
00:21:56,560 --> 00:21:58,350
Specifically, you need
to know that OpenGL

598
00:21:58,350 --> 00:22:00,220
ES 2.0 is not OpenGL.

599
00:22:00,220 --> 00:22:01,980
There's a stricter set
of compiler rules.

600
00:22:01,980 --> 00:22:03,910
And this is because we need to
make sure that security is

601
00:22:03,910 --> 00:22:06,010
step one for the end user.

602
00:22:06,010 --> 00:22:07,600
The developer, your experience
that you're trying to

603
00:22:07,600 --> 00:22:09,290
communicate, that's all
fine and dandy.

604
00:22:09,290 --> 00:22:12,200
Keeping the user safe is more
important than all of that.

605
00:22:12,200 --> 00:22:14,120
And not all the extensions
are available.

606
00:22:14,120 --> 00:22:18,000
So, for instance, if you're
expecting instancing or access

607
00:22:18,000 --> 00:22:20,810
to a specific tessellation
shader, they're just not going

608
00:22:20,810 --> 00:22:21,350
to be there.

609
00:22:21,350 --> 00:22:22,210
This is an API.

610
00:22:22,210 --> 00:22:24,680
This is handled by the Khronos
group and then rolling the

611
00:22:24,680 --> 00:22:27,950
feature sets out is sort of
tiered because we have to go

612
00:22:27,950 --> 00:22:29,080
through those bodies.

613
00:22:29,080 --> 00:22:31,410
But make sure that you
understand that OpenGL ES 2.0

614
00:22:31,410 --> 00:22:33,240
and OpenGL are not
the same thing.

615
00:22:33,240 --> 00:22:35,850
Specifically, for API nuances.

616
00:22:35,850 --> 00:22:39,050
For instance, in OpenGL you
can create a compressed

617
00:22:39,050 --> 00:22:42,170
texture and not pass any
information into it.

618
00:22:42,170 --> 00:22:44,370
So you can just say, hey, create
this blank texture, and

619
00:22:44,370 --> 00:22:45,840
I'll fill it in later.

620
00:22:45,840 --> 00:22:48,820
OpenGL ES 2.0, actually, this
is considered an error.

621
00:22:48,820 --> 00:22:50,540
If you try to do this, it
will actually crash.

622
00:22:50,540 --> 00:22:53,460
Now the problem is this is
not well documented.

623
00:22:53,460 --> 00:22:55,600
And if you go to the Native
Client forums, you'll actually

624
00:22:55,600 --> 00:22:58,460
see about 10 or 11 people,
myself included, complaining

625
00:22:58,460 --> 00:23:00,520
about this problem and asking
for a solution.

626
00:23:00,520 --> 00:23:07,330
The reality is that this is an
OpenGL E 2.0 spec that is not

627
00:23:07,330 --> 00:23:08,510
compatible with OpenGL.

628
00:23:08,510 --> 00:23:10,820
Make sure you test all of
this stuff properly.

629
00:23:10,820 --> 00:23:12,930
And definitely make sure you're
checking the API before

630
00:23:12,930 --> 00:23:14,815
you start blaming Native Client,
because a lot of the

631
00:23:14,815 --> 00:23:16,065
times the problem is there.

632
00:23:16,065 --> 00:23:18,750

633
00:23:18,750 --> 00:23:20,930
So the next thing you need to be
aware of when you're doing

634
00:23:20,930 --> 00:23:22,020
rendering is that
you're actually

635
00:23:22,020 --> 00:23:23,160
rendering from a sandbox.

636
00:23:23,160 --> 00:23:25,020
Now because of security issues,
we don't actually

637
00:23:25,020 --> 00:23:28,350
allow your code to directly
go to the driver.

638
00:23:28,350 --> 00:23:31,740
When you do a set command or a
draw command or anything, we

639
00:23:31,740 --> 00:23:33,400
don't actually go right
to the API.

640
00:23:33,400 --> 00:23:34,850
Instead, what occurs
is we have a

641
00:23:34,850 --> 00:23:36,060
separate render process.

642
00:23:36,060 --> 00:23:40,340
The render process is
responsible for handling all

643
00:23:40,340 --> 00:23:41,720
the interaction with the API.

644
00:23:41,720 --> 00:23:43,720
Nothing else goes through
this render

645
00:23:43,720 --> 00:23:45,580
process except API calls.

646
00:23:45,580 --> 00:23:48,040
Now to get from the Pepper
thread to the render process,

647
00:23:48,040 --> 00:23:50,830
though, we actually create
an RPC buffer.

648
00:23:50,830 --> 00:23:53,980
Now what happens is the Pepper
thread will push commands into

649
00:23:53,980 --> 00:23:55,010
the RPC buffer.

650
00:23:55,010 --> 00:23:57,470
And then that buffer will be
flushed at some time later to

651
00:23:57,470 --> 00:23:58,550
the render process.

652
00:23:58,550 --> 00:24:01,790
This basically creates about a
frame of latency between a

653
00:24:01,790 --> 00:24:06,180
producer-consumer FIFO that
you need to be aware of.

654
00:24:06,180 --> 00:24:08,530
What happens with this
producer-consumer FIFO,

655
00:24:08,530 --> 00:24:10,710
though, is that your RPC
buffer, sooner or

656
00:24:10,710 --> 00:24:13,190
later, will get full.

657
00:24:13,190 --> 00:24:14,500
So what happens is you
draw an object.

658
00:24:14,500 --> 00:24:15,910
You update your vertex buffer.

659
00:24:15,910 --> 00:24:18,320
You go to draw an object again,
and the buffer's full.

660
00:24:18,320 --> 00:24:19,430
So then it stalls.

661
00:24:19,430 --> 00:24:22,920
What happens here is you hit
something called a flush sink

662
00:24:22,920 --> 00:24:26,720
or sink flush, depending on
which documentation you get.

663
00:24:26,720 --> 00:24:30,030
What happens here is that the
process, even though you're

664
00:24:30,030 --> 00:24:32,610
not done with your frame,
will actually halt.

665
00:24:32,610 --> 00:24:33,760
And it will say, hey,
we're done here.

666
00:24:33,760 --> 00:24:34,460
I'm full.

667
00:24:34,460 --> 00:24:36,330
And it will actually
issue a flush sink.

668
00:24:36,330 --> 00:24:39,060
Now, what will happen here is
that it blocks the processing

669
00:24:39,060 --> 00:24:41,970
and calling thread until all
of the data inside that RPC

670
00:24:41,970 --> 00:24:44,950
buffer has been consumed
by the render process.

671
00:24:44,950 --> 00:24:46,980
What this means to you is
you'll start seeing

672
00:24:46,980 --> 00:24:49,110
30-millisecond spikes randomly
in your game,

673
00:24:49,110 --> 00:24:50,730
hitches in weird places.

674
00:24:50,730 --> 00:24:53,350
When you start debugging and
profiling down into it, you'll

675
00:24:53,350 --> 00:24:56,350
see random calls all of a sudden
taking 30 milliseconds.

676
00:24:56,350 --> 00:24:57,780
And to you this is going
to be maddening.

677
00:24:57,780 --> 00:25:00,550
You're going try to figure out
why this one draw object is

678
00:25:00,550 --> 00:25:01,410
taking 30 milliseconds.

679
00:25:01,410 --> 00:25:02,320
Is it the pixel shader?

680
00:25:02,320 --> 00:25:03,230
Is it the number of vertices?

681
00:25:03,230 --> 00:25:03,610
Yada, yada.

682
00:25:03,610 --> 00:25:06,030
You'll start moving the thing
around and noticing that it

683
00:25:06,030 --> 00:25:08,380
never happens on the same draw
call, that it happens sort of

684
00:25:08,380 --> 00:25:09,990
as a temporal problem.

685
00:25:09,990 --> 00:25:12,460
And what the real problem is
is that the RPC buffer is

686
00:25:12,460 --> 00:25:13,560
getting full.

687
00:25:13,560 --> 00:25:15,350
So make sure you note
that ahead of time.

688
00:25:15,350 --> 00:25:20,690
Now how you combat this is
kind of interesting.

689
00:25:20,690 --> 00:25:23,200
First off, swap buffers actually
kicks off a GL finish

690
00:25:23,200 --> 00:25:24,990
call on your behalf.

691
00:25:24,990 --> 00:25:27,660
GL finish will actually
force a flush to

692
00:25:27,660 --> 00:25:29,080
occur of the RPC buffer.

693
00:25:29,080 --> 00:25:30,230
So you fill in a frame.

694
00:25:30,230 --> 00:25:31,230
You hit swap buffers.

695
00:25:31,230 --> 00:25:32,430
And then you start filling
in the next frame.

696
00:25:32,430 --> 00:25:34,100
And that swap buffers will push
everything off to the

697
00:25:34,100 --> 00:25:35,760
render process on your behalf.

698
00:25:35,760 --> 00:25:40,290
The goal here is to implement
these flushes in strategic

699
00:25:40,290 --> 00:25:43,150
locations inside of your render
loop, so that you never

700
00:25:43,150 --> 00:25:44,350
hit a sink flush.

701
00:25:44,350 --> 00:25:46,780
So effectively what you're doing
is continuously pushing

702
00:25:46,780 --> 00:25:50,000
the data and forcing that RPC
buffer to flush, so that you

703
00:25:50,000 --> 00:25:52,500
never hit these 30-millisecond
waits.

704
00:25:52,500 --> 00:25:54,970
So you need to do is once
you draw some stuff,

705
00:25:54,970 --> 00:25:55,860
you insert a flush.

706
00:25:55,860 --> 00:25:57,940
You draw some more stuff, and
you insert another flush.

707
00:25:57,940 --> 00:26:01,280
Now the key here is that
figuring out where to insert

708
00:26:01,280 --> 00:26:03,040
these GL flush calls.

709
00:26:03,040 --> 00:26:04,060
That's the trick.

710
00:26:04,060 --> 00:26:06,020
To do that what you have to do
is you have to go back and

711
00:26:06,020 --> 00:26:07,110
analyze your frame.

712
00:26:07,110 --> 00:26:09,110
You got to take a look at where
the heavy spots are,

713
00:26:09,110 --> 00:26:11,450
where you're hitting your flush
sinks, and then figure

714
00:26:11,450 --> 00:26:14,730
out, hey, I need to insert a GL
flush manually before I hit

715
00:26:14,730 --> 00:26:16,800
that point to save me
30 milliseconds.

716
00:26:16,800 --> 00:26:19,740
Basically, what you're trying to
do is keep that RPC buffer

717
00:26:19,740 --> 00:26:22,350
continuously moving to keep
your frames from getting

718
00:26:22,350 --> 00:26:25,080
stalled out.

719
00:26:25,080 --> 00:26:27,910
So once you understand how all
this works and how you're

720
00:26:27,910 --> 00:26:30,330
rendering, how the rendering
occurs, and how the rendering

721
00:26:30,330 --> 00:26:33,430
happens between the Chrome and
Native Client module in the

722
00:26:33,430 --> 00:26:36,160
rendering process, you need to
take a step back and take a

723
00:26:36,160 --> 00:26:39,290
view of the bigger picture,
which is 3D and the web.

724
00:26:39,290 --> 00:26:42,180
3D API's, as well documented,
can be malicious on the web.

725
00:26:42,180 --> 00:26:45,850
As much as we would like
to admit it, the web is

726
00:26:45,850 --> 00:26:46,970
homogeneous.

727
00:26:46,970 --> 00:26:49,730
But GPUs and hardware are not.

728
00:26:49,730 --> 00:26:50,670
You've got a different
machine.

729
00:26:50,670 --> 00:26:51,850
You've got a different
machine.

730
00:26:51,850 --> 00:26:54,840
Heck, my coffee cup has a
different GPU processing in it

731
00:26:54,840 --> 00:26:58,120
than any of you, which I think
this is a 9,800, but we'll get

732
00:26:58,120 --> 00:26:59,180
back to that later.

733
00:26:59,180 --> 00:27:03,270
So the problem here is that
because of the fact that some

734
00:27:03,270 --> 00:27:06,350
of these drivers can be
malicious, WebGL actually has

735
00:27:06,350 --> 00:27:08,540
a list of blacklisted
3D drivers.

736
00:27:08,540 --> 00:27:10,740
Most of the time if a driver
has a problem, we can say,

737
00:27:10,740 --> 00:27:11,840
hey, here's the problem.

738
00:27:11,840 --> 00:27:12,860
Submit it to the vendor.

739
00:27:12,860 --> 00:27:15,470
The vendor can fix it and
push out a patch to it.

740
00:27:15,470 --> 00:27:18,860
In the situations where this
doesn't occur, we effectively

741
00:27:18,860 --> 00:27:20,600
have to say we have to blacklist
the driver because

742
00:27:20,600 --> 00:27:22,720
this is a malicious piece of
software that can cause

743
00:27:22,720 --> 00:27:25,090
problems on the end user's
machine and expose them to

744
00:27:25,090 --> 00:27:26,570
potential security risks.

745
00:27:26,570 --> 00:27:29,220
And because of that, the user
can hit a web page, and we can

746
00:27:29,220 --> 00:27:31,000
say, hey, you're not allowed
to run WebGL.

747
00:27:31,000 --> 00:27:33,420
You're not allowed
to run OpenGL

748
00:27:33,420 --> 00:27:35,560
inside of Native Client.

749
00:27:35,560 --> 00:27:37,720
And to detect this, effectively
what happens is

750
00:27:37,720 --> 00:27:39,400
you fail to create a context.

751
00:27:39,400 --> 00:27:40,370
That's the basic thing.

752
00:27:40,370 --> 00:27:43,280
The first thing you do in any
OpenGL-style system is you

753
00:27:43,280 --> 00:27:44,430
create a GL context.

754
00:27:44,430 --> 00:27:46,960
When that fails, it means
one of two things.

755
00:27:46,960 --> 00:27:49,620
Either the user doesn't have the
proper hardware to run any

756
00:27:49,620 --> 00:27:50,810
WebGL or OpenGL.

757
00:27:50,810 --> 00:27:54,160
Or the user has a set of
blacklisted drivers.

758
00:27:54,160 --> 00:27:57,760
Your job is to detect this
and respond very early.

759
00:27:57,760 --> 00:28:00,410
Because I'll tell you, nothing
is more annoying than a user

760
00:28:00,410 --> 00:28:02,660
spending an hour and a half
trying to get your game to run

761
00:28:02,660 --> 00:28:05,090
and updating drivers and
updating Chrome and doing this

762
00:28:05,090 --> 00:28:08,150
and that to finally get down to
and realize the problem is

763
00:28:08,150 --> 00:28:10,360
they needed to go update a patch
or that they just can't

764
00:28:10,360 --> 00:28:11,410
do it in general.

765
00:28:11,410 --> 00:28:13,610
Make sure you update this early
and tell the users, so

766
00:28:13,610 --> 00:28:16,090
you can save them
all that time.

767
00:28:16,090 --> 00:28:17,590
To do this is is actually
really simple.

768
00:28:17,590 --> 00:28:19,420
Here's a little snippet of
code that you can use in

769
00:28:19,420 --> 00:28:20,190
JavaScript.

770
00:28:20,190 --> 00:28:22,820
So this is way before Native
Client even loads.

771
00:28:22,820 --> 00:28:24,140
So the user loads your page.

772
00:28:24,140 --> 00:28:26,260
You're going to execute this
snippet of JavaScript to

773
00:28:26,260 --> 00:28:29,730
determine whether or not the
user is blacklisted first. OK.

774
00:28:29,730 --> 00:28:32,300
Basically what you do is you try
to create a WebGL context.

775
00:28:32,300 --> 00:28:35,400
If that WebGL context fails,
you can alert the user

776
00:28:35,400 --> 00:28:37,780
immediately, immediately that
they either have blacklisted

777
00:28:37,780 --> 00:28:39,180
hardware, or they don't
have hardware

778
00:28:39,180 --> 00:28:40,500
sufficient to run this.

779
00:28:40,500 --> 00:28:43,700
If it passes, then you know the
user has a system that can

780
00:28:43,700 --> 00:28:45,480
run your game, your 3D game.

781
00:28:45,480 --> 00:28:47,010
And you can also do some
other cool stuff here.

782
00:28:47,010 --> 00:28:49,350
Since you have the context,
you can go ahead and test

783
00:28:49,350 --> 00:28:50,460
additional extensions.

784
00:28:50,460 --> 00:28:52,150
Like does the user have
occlusion calling?

785
00:28:52,150 --> 00:28:54,570
Or does the user have
the ability to run

786
00:28:54,570 --> 00:28:56,810
4096 by 4096 textures?

787
00:28:56,810 --> 00:28:59,340
You can do all this in
JavaScript before you start

788
00:28:59,340 --> 00:29:01,780
loading all of your NEXEs and
start transferring your binary

789
00:29:01,780 --> 00:29:02,540
data from the web.

790
00:29:02,540 --> 00:29:04,190
This is really cool to do.

791
00:29:04,190 --> 00:29:07,160
The link at the bottom here,
actually, links to a specific

792
00:29:07,160 --> 00:29:08,620
example of how to do all this.

793
00:29:08,620 --> 00:29:10,880
As well as you should take a
look at the load progress

794
00:29:10,880 --> 00:29:12,370
example in the SDK.

795
00:29:12,370 --> 00:29:14,920
It has this as well as a fleet
of other tasks that you should

796
00:29:14,920 --> 00:29:18,150
be doing, as well as detecting
download process and

797
00:29:18,150 --> 00:29:19,230
displaying that to your users.

798
00:29:19,230 --> 00:29:22,770
So make sure that that's part
of your best practices.

799
00:29:22,770 --> 00:29:23,660
Working in a browser.

800
00:29:23,660 --> 00:29:26,080
So you understand the
environment you're in.

801
00:29:26,080 --> 00:29:28,210
You understand the hitches and
the hurdles that you're going

802
00:29:28,210 --> 00:29:31,110
to have to jump for FileIO and
rendering and all the problems

803
00:29:31,110 --> 00:29:32,090
associated with that.

804
00:29:32,090 --> 00:29:34,100
So now let's talk about working
inside of a browser.

805
00:29:34,100 --> 00:29:36,650
So this has less to do with your
technology and your code

806
00:29:36,650 --> 00:29:37,920
and more to do with
the ecosystem that

807
00:29:37,920 --> 00:29:39,340
you're living in.

808
00:29:39,340 --> 00:29:41,890
So first off is NaCl
white listing.

809
00:29:41,890 --> 00:29:45,610
Native Client is not enabled
inside of Chrome until an

810
00:29:45,610 --> 00:29:47,740
action occurs.

811
00:29:47,740 --> 00:29:49,130
This is for a number
of reasons,

812
00:29:49,130 --> 00:29:50,810
predominately security.

813
00:29:50,810 --> 00:29:52,770
If there's an issue in Native
Client that we're not aware

814
00:29:52,770 --> 00:29:54,770
of, we don't want malicious code
just sitting around on

815
00:29:54,770 --> 00:29:55,520
the internet.

816
00:29:55,520 --> 00:29:58,640
We want some way to make sure
that random users are not at

817
00:29:58,640 --> 00:30:01,790
the mercy of a problem
that we find.

818
00:30:01,790 --> 00:30:03,220
So Native Client is not enabled

819
00:30:03,220 --> 00:30:03,920
until one of two things.

820
00:30:03,920 --> 00:30:06,910
First off, for developers, you
can turn on Native Client by a

821
00:30:06,910 --> 00:30:08,860
flag in the about flags page.

822
00:30:08,860 --> 00:30:11,290
So this will allow you, as a
developer, to get access to

823
00:30:11,290 --> 00:30:13,830
any Native Client content
that exists on the web.

824
00:30:13,830 --> 00:30:16,210
For users, though, you don't
want them setting a flag.

825
00:30:16,210 --> 00:30:17,970
Users have to go through
a different path.

826
00:30:17,970 --> 00:30:20,340
They actually install the game
from the Chrome web store.

827
00:30:20,340 --> 00:30:23,100
And what happens here is that
the Chrome web store will

828
00:30:23,100 --> 00:30:26,510
actually list the origin that
you've specified for your NaCl

829
00:30:26,510 --> 00:30:28,890
module, so basically where
it's resting on a server.

830
00:30:28,890 --> 00:30:32,410
So I've got a website,
mainroach.blogspot.com.

831
00:30:32,410 --> 00:30:34,960
And I host my Native
Client app there.

832
00:30:34,960 --> 00:30:37,240
When I create my Chrome Web
Store instance, I say that my

833
00:30:37,240 --> 00:30:39,390
Native Client application
will be hosted for

834
00:30:39,390 --> 00:30:42,110
mainroach.blogspot.com.

835
00:30:42,110 --> 00:30:44,820
When you install that, as
a user, that origin,

836
00:30:44,820 --> 00:30:47,600
mainroach.blogspot.com will
get listed inside of your

837
00:30:47,600 --> 00:30:49,500
preferences as a white
listed location.

838
00:30:49,500 --> 00:30:51,380
Hey, it's OK to serve
Native Client

839
00:30:51,380 --> 00:30:54,370
content from this location.

840
00:30:54,370 --> 00:30:57,220
And note that the NMF and
the NEXEs must be

841
00:30:57,220 --> 00:30:58,380
loaded from that location.

842
00:30:58,380 --> 00:31:01,160
You can put zip data in
different places and aug files

843
00:31:01,160 --> 00:31:03,200
and JavaScript all on
a content network,

844
00:31:03,200 --> 00:31:04,100
wherever you want them.

845
00:31:04,100 --> 00:31:07,190
But the NEXEs and the NMFs
must exist from that

846
00:31:07,190 --> 00:31:10,110
white-listed origin.

847
00:31:10,110 --> 00:31:11,870
So once you've done that,
you have a pretty

848
00:31:11,870 --> 00:31:13,240
easy way to test this.

849
00:31:13,240 --> 00:31:15,815
So you can actually determine
beforehand whether or not the

850
00:31:15,815 --> 00:31:17,700
user actually has Native
Client enabled or

851
00:31:17,700 --> 00:31:19,020
available to install.

852
00:31:19,020 --> 00:31:20,845
So first off, you need to detect
whether or not the user

853
00:31:20,845 --> 00:31:21,660
is running Chrome.

854
00:31:21,660 --> 00:31:25,740
As of today, much to my dismay,
Chrome is the only one

855
00:31:25,740 --> 00:31:27,920
that uses and installs
Native Client.

856
00:31:27,920 --> 00:31:31,480
So first off, to determine if a
user can run Native Client,

857
00:31:31,480 --> 00:31:33,510
you need to detect if they're
using Chrome.

858
00:31:33,510 --> 00:31:37,940
Secondly the Chrome web store
has a really cool API called

859
00:31:37,940 --> 00:31:40,630
window.chrome.app.isinstalled.

860
00:31:40,630 --> 00:31:44,210
And you can define in this
whether or not the application

861
00:31:44,210 --> 00:31:45,940
defined on this page has
been installed from

862
00:31:45,940 --> 00:31:47,010
the Chrome web store.

863
00:31:47,010 --> 00:31:49,910
Now because an end user has
to install a Native Client

864
00:31:49,910 --> 00:31:52,470
application from the Chrome web
store, this is effectively

865
00:31:52,470 --> 00:31:54,510
your test to determine if
the user can run it.

866
00:31:54,510 --> 00:31:58,090
So if some user randomly browses
to your web page that

867
00:31:58,090 --> 00:32:00,660
doesn't have Native Client
installed or hasn't installed

868
00:32:00,660 --> 00:32:03,620
it from the web store, you can
detect it here and direct them

869
00:32:03,620 --> 00:32:04,580
to install it.

870
00:32:04,580 --> 00:32:07,420
You can also use something
called Inline Install, which

871
00:32:07,420 --> 00:32:09,320
is a great little nifty feature
from the Chrome web

872
00:32:09,320 --> 00:32:10,210
store, too.

873
00:32:10,210 --> 00:32:11,990
But the important thing here
is that you need to detect

874
00:32:11,990 --> 00:32:13,970
this and tell the user because,
otherwise, they're

875
00:32:13,970 --> 00:32:15,060
going to browse to
your website.

876
00:32:15,060 --> 00:32:17,020
And then they'll get a plug-in
request. And they're going to

877
00:32:17,020 --> 00:32:18,030
be like, hey, what's this?

878
00:32:18,030 --> 00:32:18,620
This is crummy.

879
00:32:18,620 --> 00:32:21,040
I'm going to give you zero star
reviews, and send you

880
00:32:21,040 --> 00:32:22,500
pictures that you don't
want to see.

881
00:32:22,500 --> 00:32:24,450
Definitely click the link at
the bottom of this slide.

882
00:32:24,450 --> 00:32:26,620
And also check out the load
progress example in the SDK

883
00:32:26,620 --> 00:32:28,770
for more on that.

884
00:32:28,770 --> 00:32:31,900
Now for developers, it's worth
pointing out that the Chrome

885
00:32:31,900 --> 00:32:35,220
caching mechanism is
both aggressive,

886
00:32:35,220 --> 00:32:37,500
amazing, and magical.

887
00:32:37,500 --> 00:32:40,270
How well it caches data and
how aggressive it is at

888
00:32:40,270 --> 00:32:42,260
keeping it around to make sure
that you're always hitting the

889
00:32:42,260 --> 00:32:44,410
cache as opposed to going
to the web is

890
00:32:44,410 --> 00:32:45,890
really a thing of beauty.

891
00:32:45,890 --> 00:32:49,820
The problem is for those of us
game developers who do test,

892
00:32:49,820 --> 00:32:52,620
launch, and iterate patterns,
this is a problem.

893
00:32:52,620 --> 00:32:55,780
Because as I change some code,
deploy it to Chrome, and then

894
00:32:55,780 --> 00:32:58,580
iterate on that content, I
want the latest version.

895
00:32:58,580 --> 00:33:00,020
I don't want the
cached version.

896
00:33:00,020 --> 00:33:03,310
To get around this, because
Chrome will bite you in this

897
00:33:03,310 --> 00:33:06,170
matter, you can actually go
to the developer tools and

898
00:33:06,170 --> 00:33:07,500
actually turn off caching.

899
00:33:07,500 --> 00:33:09,840
You can disable caching, so that
Chrome will always try to

900
00:33:09,840 --> 00:33:13,940
fetch the most recent version
and won't ever try to grab the

901
00:33:13,940 --> 00:33:14,660
data from the cache.

902
00:33:14,660 --> 00:33:16,500
Now, it's worth pointing out
that you probably don't want

903
00:33:16,500 --> 00:33:18,180
to do this on the version of
Chrome that you're running

904
00:33:18,180 --> 00:33:20,087
every day because otherwise your
browser will just slow

905
00:33:20,087 --> 00:33:21,280
down in general.

906
00:33:21,280 --> 00:33:23,190
But make sure that in your
developer version of Chrome

907
00:33:23,190 --> 00:33:26,380
that you're doing
it like this.

908
00:33:26,380 --> 00:33:28,360
Now also while you're developing
in Chrome, there's

909
00:33:28,360 --> 00:33:32,260
a whole fleet of tools that
will help you in your

910
00:33:32,260 --> 00:33:32,940
development.

911
00:33:32,940 --> 00:33:34,600
And these are called the
Chrome developer tools.

912
00:33:34,600 --> 00:33:37,200
You can click the link to the
more expansive declaration.

913
00:33:37,200 --> 00:33:39,910
But effectively, you can click
on the wrench, go down to

914
00:33:39,910 --> 00:33:41,860
tools, and go down to
developer tools.

915
00:33:41,860 --> 00:33:43,840
And this will launch a small
little bar at the bottom of

916
00:33:43,840 --> 00:33:45,810
your window that has a number
of options here--

917
00:33:45,810 --> 00:33:48,090
elements, resources, network
views, et cetera.

918
00:33:48,090 --> 00:33:49,830
One of the cool things about
this is that it actually

919
00:33:49,830 --> 00:33:51,750
provides a networking view.

920
00:33:51,750 --> 00:33:54,960
The networking view actually
lists all of the asset

921
00:33:54,960 --> 00:33:57,880
requests that your module has
made through Chrome over the

922
00:33:57,880 --> 00:33:59,390
lifetime of its application.

923
00:33:59,390 --> 00:34:02,470
So you can actually see, hey,
am I loading my zip file.

924
00:34:02,470 --> 00:34:03,770
Am I loading my audio data?

925
00:34:03,770 --> 00:34:05,780
How long does it take
to fetch that?

926
00:34:05,780 --> 00:34:07,790
Can I change anything
to make that faster?

927
00:34:07,790 --> 00:34:09,929
Can I bundle things up
to make that easier?

928
00:34:09,929 --> 00:34:13,070
These are sort of quintessential
tools that you

929
00:34:13,070 --> 00:34:15,159
need to be using, if you're
starting to develop inside of

930
00:34:15,159 --> 00:34:17,620
Chrome, especially the console
tab, which will tell you a lot

931
00:34:17,620 --> 00:34:19,780
of errors the Native Client
spits out that you may not be

932
00:34:19,780 --> 00:34:22,570
able to catch in
other fashions.

933
00:34:22,570 --> 00:34:25,260
Another amazing tool
is About Tracing.

934
00:34:25,260 --> 00:34:27,050
So if you open up Chrome, and
you create a new tab, and you

935
00:34:27,050 --> 00:34:31,906
type in the address bar About
Tracing, it will take you to

936
00:34:31,906 --> 00:34:34,889
this great API here, which
effectively is an inline

937
00:34:34,889 --> 00:34:37,940
profiler view of Chrome.

938
00:34:37,940 --> 00:34:41,030
So it actually shows you what
thread is running and what

939
00:34:41,030 --> 00:34:42,560
blocks of time is
running there.

940
00:34:42,560 --> 00:34:45,520
And it allows you to drill down
to actually get the name

941
00:34:45,520 --> 00:34:47,679
of the function being called.

942
00:34:47,679 --> 00:34:50,790
The best part about this is you
can actually issue data

943
00:34:50,790 --> 00:34:53,929
into About Tracing from
JavaScript or, subsequently,

944
00:34:53,929 --> 00:34:54,760
Native Client.

945
00:34:54,760 --> 00:34:57,660
And the even cooler thing about
this is see that little

946
00:34:57,660 --> 00:34:59,530
Load button over there?

947
00:34:59,530 --> 00:35:01,660
You can write out an
inline profile.

948
00:35:01,660 --> 00:35:04,280
So for those of you who have
inline profilers that already

949
00:35:04,280 --> 00:35:07,610
exist in your game, you can
modify it to output adjacent

950
00:35:07,610 --> 00:35:12,130
file that matches what this tool
uses, and use Chrome to

951
00:35:12,130 --> 00:35:14,450
do all of the profiling
in your game.

952
00:35:14,450 --> 00:35:16,180
It's an entire tool that allows
you to get all this

953
00:35:16,180 --> 00:35:18,530
progress and availability
to you free of charge.

954
00:35:18,530 --> 00:35:19,850
You don't have to
write the UI.

955
00:35:19,850 --> 00:35:20,520
You don't have to do that.

956
00:35:20,520 --> 00:35:22,230
We got a guy dedicated
to writing this.

957
00:35:22,230 --> 00:35:22,860
Use this tool.

958
00:35:22,860 --> 00:35:25,130
It's amazing to see.

959
00:35:25,130 --> 00:35:25,740
Google Stack.

960
00:35:25,740 --> 00:35:28,670
So now we've talked about what
the ecosystem is and all this

961
00:35:28,670 --> 00:35:29,020
other stuff.

962
00:35:29,020 --> 00:35:30,850
So let's talk about what
Google can do to

963
00:35:30,850 --> 00:35:31,980
help you with this.

964
00:35:31,980 --> 00:35:33,800
So you've got your game.

965
00:35:33,800 --> 00:35:36,300
You can serve your content, your
database information, off

966
00:35:36,300 --> 00:35:37,270
of Google App Engine.

967
00:35:37,270 --> 00:35:40,770
So this is basically your
database handling and your

968
00:35:40,770 --> 00:35:42,680
asset distribution.

969
00:35:42,680 --> 00:35:44,710
We have the Chrome web store
that we've already talked

970
00:35:44,710 --> 00:35:46,130
about and touched on,
which handles

971
00:35:46,130 --> 00:35:47,680
distribution and discovery.

972
00:35:47,680 --> 00:35:49,500
You also need to install your
Native Client apps from there

973
00:35:49,500 --> 00:35:50,560
to white list them.

974
00:35:50,560 --> 00:35:53,130
We've got Google Wallet, which
helps you monetize through

975
00:35:53,130 --> 00:35:55,890
in-app payments and everything
else along those lines.

976
00:35:55,890 --> 00:35:57,530
Once you've got all that, you're
eventually going to

977
00:35:57,530 --> 00:35:59,470
want some sort of social graph,
so that people can

978
00:35:59,470 --> 00:36:01,440
detect and move between
friends and submit

979
00:36:01,440 --> 00:36:01,870
information.

980
00:36:01,870 --> 00:36:04,820
We've got Google+ And then,
finally, we've got Google

981
00:36:04,820 --> 00:36:07,780
Analytics, which is an amazingly
powerful tool that

982
00:36:07,780 --> 00:36:10,180
allows you to detect what your
users are doing, how they're

983
00:36:10,180 --> 00:36:13,030
doing it, and kick off
events to match that.

984
00:36:13,030 --> 00:36:16,130
Now definitely check out my
other talk today on best

985
00:36:16,130 --> 00:36:19,100
practices in developing a web
application to do a deep dive

986
00:36:19,100 --> 00:36:22,020
on the way to properly use
these for your web game.

987
00:36:22,020 --> 00:36:23,110
Check it out, and
leave comments.

988
00:36:23,110 --> 00:36:25,040
I highly appreciate it.

989
00:36:25,040 --> 00:36:26,050
That's all for me.

990
00:36:26,050 --> 00:36:28,040
Make sure you check out
gonacl.com for the best

991
00:36:28,040 --> 00:36:29,140
information available.

992
00:36:29,140 --> 00:36:32,270
And then you can find me on all
of these different places,

993
00:36:32,270 --> 00:36:34,320
especially
mainroach.blogspot.com.

994
00:36:34,320 --> 00:36:35,540
So, hey, thank you
for your time.

995
00:36:35,540 --> 00:36:36,550
Appreciate your comments.

996
00:36:36,550 --> 00:36:37,290
Drop me a line.

997
00:36:37,290 --> 00:36:38,150
I'd love to hear from you.

998
00:36:38,150 --> 00:36:39,400
Thank you.

999
00:36:39,400 --> 00:36:39,700

