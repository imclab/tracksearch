1
00:00:00,429 --> 00:00:05,069
>>Colton McAnlis: I'm here today. This is
fantastic. Hello, everyone!

2
00:00:05,069 --> 00:00:10,140
Try that again.
Oh, this is Google I/O. Hello everyone!

3
00:00:10,140 --> 00:00:12,300
>>> Hello!
>>Colton McAnlis: There it is.

4
00:00:12,300 --> 00:00:16,680
Now, I don't know if you guys know this, hopefully
you do, this session is being live recorded

5
00:00:16,680 --> 00:00:20,369
and broadcasted on the intertubes right now.
Hopefully we won't clog them up with all of

6
00:00:20,369 --> 00:00:25,030
our awesomeness.
A couple of months ago I said, Hey, I want

7
00:00:25,030 --> 00:00:29,970
to talk about this HTML5 game and to demo
it, and actually I want to have some skydivers

8
00:00:29,970 --> 00:00:33,550
jump down, come in and give a talk. And they
were like, Sorry, we can't do that. We did

9
00:00:33,550 --> 00:00:39,510
that for the keynote. Next year we'll do skydiving.
Anyway, my name is Colt McAnlis and I'm a

10
00:00:39,510 --> 00:00:44,600
developer advocate here working at Google,
focusing on Chrome games.

11
00:00:44,600 --> 00:00:50,430
And today is really cool because for you guys
this is Google I/O and you get a lot of information,

12
00:00:50,430 --> 00:00:56,219
but for us Googlers this is a holiday, this
is a magical event for us because all year

13
00:00:56,219 --> 00:01:01,640
long we toil and we struggle and we write
tons of code and throw tons of code away and

14
00:01:01,640 --> 00:01:07,860
we spend all of our time making products that
we can't talk to any of you about. Except

15
00:01:07,860 --> 00:01:11,360
today.
And today is a fantastic day because I get

16
00:01:11,360 --> 00:01:15,979
to talk about a project myself and a core
group of people have been working on, and

17
00:01:15,979 --> 00:01:20,490
that's a game called GRITS. And GRITS, first
off it has robots, pretty cool. Everybody

18
00:01:20,490 --> 00:01:22,210
love robots.
Hands up for robots.

19
00:01:22,210 --> 00:01:25,990
[Applause]
Love this. Yes, I think there should be more

20
00:01:25,990 --> 00:01:29,400
robots on the internet. That's my personal
opinion.

21
00:01:29,400 --> 00:01:33,880
Let's talk about where GRITS started.
GRITS is player versus player game entirely

22
00:01:33,880 --> 00:01:37,200
written in HTML5.
A couple of months ago I gave a great talk

23
00:01:37,200 --> 00:01:40,860
-- I thought it was a great talk. I didn't
get promoted afterwards, but it still went

24
00:01:40,860 --> 00:01:46,229
over quite well, best practices in developing
an HTML5 game. The talk effectively highlighted

25
00:01:46,229 --> 00:01:50,780
issues that game developers were running into
in developing HTML5 and kind of how to overcome

26
00:01:50,780 --> 00:01:53,229
them.
Someone came up to me and said "This is a

27
00:01:53,229 --> 00:01:58,210
great talk. Where's the source code?"
Dang it! You got me.

28
00:01:58,210 --> 00:02:01,700
We just talked about ideas.
So at that point we decided, Hey, let's actually

29
00:02:01,700 --> 00:02:06,439
write a full player versus player game in
HTML5, open source it and bring the results

30
00:02:06,439 --> 00:02:10,099
to Google I/O. And that's what we're here
talking about today.

31
00:02:10,099 --> 00:02:14,769
So in order to make sure that a bunch of Googlers
didn't run off into the distance and do something

32
00:02:14,769 --> 00:02:19,029
crazy, our managers made us specify some bounding
parameters on what kind of video game we were

33
00:02:19,029 --> 00:02:21,480
going to make.
So we wanted to make sure it was multiplayer

34
00:02:21,480 --> 00:02:25,819
only. We're gonna be a small group with a
small a lot of time. We didn't have artists,

35
00:02:25,819 --> 00:02:30,549
we don't have designers, we don't have the
ability to create a 56-hour expression of

36
00:02:30,549 --> 00:02:36,809
our inner angst by you riding a horse and
slaying a dragon. Let's make it multiplayer

37
00:02:36,809 --> 00:02:41,299
only where robots shoot robots in the face.
Super easy, right?

38
00:02:41,299 --> 00:02:46,900
Second, let's leverage Google technologies.
As you guys have been hearing today already

39
00:02:46,900 --> 00:02:51,279
-- because you're here at Google I/O you are
probably already very aware that Google provides

40
00:02:51,279 --> 00:02:56,189
a suite of powerful technologies. And a lot
of game developers out there actually don't

41
00:02:56,189 --> 00:02:59,730
know how to use a lot of the Google technologies
and translate it into the game development

42
00:02:59,730 --> 00:03:03,099
process.
So for GRITS what we wanted to do was highlight

43
00:03:03,099 --> 00:03:07,260
those technologies and provide a source code
on how to properly use them so that we can

44
00:03:07,260 --> 00:03:11,949
actually say, Hey, here's a game that actually
works and it's using app engine. Here's the

45
00:03:11,949 --> 00:03:16,199
source code. Or Hey, here's how to use wallet
the right way. Here's the source code.

46
00:03:16,199 --> 00:03:20,839
Second, we wanted to contract our art and
sound. Google is a big company, but we're

47
00:03:20,839 --> 00:03:24,879
predominantly engineer heavy. We don't have
a lot of 3D artists and designers sitting

48
00:03:24,879 --> 00:03:29,059
around. So we actually we tapped a great company
called Fuzzy Cube Software to do all the art

49
00:03:29,059 --> 00:03:32,189
for our games. Give it up for those guys.
[ Applause ]

50
00:03:32,189 --> 00:03:38,089
>>Colton McAnlis: It was like we came in and
we were like, Hey, we need a ton of art in

51
00:03:38,089 --> 00:03:41,400
like six days.
And they were like, Okay.

52
00:03:41,400 --> 00:03:46,549
And finally -- and this was one my manager
actually made me put on the slide was our

53
00:03:46,549 --> 00:03:50,359
intent was not to make this product commercially
viable. This was intended to be a source code

54
00:03:50,359 --> 00:03:55,209
repo that everyone in this room can go grab
and start making player versus player HTML5

55
00:03:55,209 --> 00:03:59,040
games. We're not trying to take on all the
big names of the industry out there. We're

56
00:03:59,040 --> 00:04:02,319
really trying to prove that this is something
we can do.

57
00:04:02,319 --> 00:04:08,359
In order to do this, I actually tapped game
developers who work at Google. So these are

58
00:04:08,359 --> 00:04:12,989
developers who used to be in the industry,
shipped games on console and PC who now work

59
00:04:12,989 --> 00:04:16,070
at Google.
In addition to that, we also grabbed a couple

60
00:04:16,070 --> 00:04:21,229
of people who were experts in the subject
area we needed so that we can actually get

61
00:04:21,229 --> 00:04:26,550
a full-fledged team.
Consider GRITS a view of traditional game

62
00:04:26,550 --> 00:04:30,539
developers looking at HTML5 as a viable platform.
And hopefully the discussion that we're going

63
00:04:30,539 --> 00:04:34,840
to have today is going to highlight some of
the things from that particular perspective.

64
00:04:34,840 --> 00:04:39,650
Again, we wanted to bring our results here.
We thought this was the proper platform. And

65
00:04:39,650 --> 00:04:44,530
from the start to finish we only had 120 days.
I'm sure everyone in here has heard of Google's

66
00:04:44,530 --> 00:04:49,840
20% projects hopefully? That basically means
we're only allowed to work on this one day

67
00:04:49,840 --> 00:04:54,280
a week. So really for the 120 days we only
got one day a week. But with that short amount

68
00:04:54,280 --> 00:04:59,530
of time what we found was the APIs and the
technology available in HTML5 allowed us to

69
00:04:59,530 --> 00:05:02,960
do some amazing things.
So let's talk about what we actually were

70
00:05:02,960 --> 00:05:08,009
able to do. I'm going to cut to a video because
I've been having internet trouble all day.

71
00:05:08,009 --> 00:05:15,009
Let's see if I can do this.
So what you're looking at here sort of the

72
00:05:17,030 --> 00:05:20,819
log-in screen. We allow players to use Quick
Game or log-in.

73
00:05:20,819 --> 00:05:24,979
We have full G+ integration so when we log
in you actually see my friends list and my

74
00:05:24,979 --> 00:05:29,000
Circles there on the side. You actually see
my name and my portrait and we've got that

75
00:05:29,000 --> 00:05:32,430
nice little share button which allows you
to share the game to the live stream and tell

76
00:05:32,430 --> 00:05:35,439
people what a great thing you're doing. Now,
you notice I actually misspelled GRITS so

77
00:05:35,439 --> 00:05:37,870
I decided not to share that one. It's a little
embarrassing.

78
00:05:37,870 --> 00:05:42,050
For the game we support keyboard layout or
mouse so that you can actually play it on

79
00:05:42,050 --> 00:05:46,849
your laptop or on your desktop.
When you run into the game you configure your

80
00:05:46,849 --> 00:05:51,669
robot first. This is sort of phase one of
a longer strategy here. You can pick primary,

81
00:05:51,669 --> 00:05:57,539
secondary or tertiary weapons like chainsaw,
land mines, shotgun. I think I have the energy

82
00:05:57,539 --> 00:06:00,039
sword here.
Energy sword is the bomb. If you're playing

83
00:06:00,039 --> 00:06:04,129
the game always choose the energy sword. It's
plus 10 uber awesome.

84
00:06:04,129 --> 00:06:11,129
We have a little bit of a lag on the delay.
It's not that choppy live, but basically it's

85
00:06:11,419 --> 00:06:15,289
robots shooting each other. Right? Everyone
loves that, right? This is why we get up in

86
00:06:15,289 --> 00:06:19,789
the morning to see robots shooting each other.
Effectively you see a little bit of the jittering

87
00:06:19,789 --> 00:06:25,379
here. That's due to latency, networking correction.
We've got energy items that you can pick up.

88
00:06:25,379 --> 00:06:30,159
We've got help bars, names. You can actually
see the anonymous players running around in

89
00:06:30,159 --> 00:06:34,909
the universe. You can see the bullets bouncing.
Energy shield, awesome. +1 on the energy field.

90
00:06:34,909 --> 00:06:38,759
Like sometimes you wish the +1 button were
bigger so you could hit it so hard it would

91
00:06:38,759 --> 00:06:41,810
put a dent in wall. Right, when you find something
cool? Nobody else? No one?

92
00:06:41,810 --> 00:06:43,509
[Laughter]
>>Colton McAnlis: You're at a Google conference

93
00:06:43,509 --> 00:06:46,560
and you don't applaud for a bigger +1 button?
[ Applause ]

94
00:06:46,560 --> 00:06:53,560
>>Colton McAnlis: Okay. There you go. In the
back, give that guy a T-shirt.

95
00:06:53,719 --> 00:06:57,460
But this is more of the game play running
around. Of course I died at the end.

96
00:06:57,460 --> 00:07:02,999
Now, that little QR code at the top there,
we'll talk a little more about that in a minute.

97
00:07:02,999 --> 00:07:06,539
So that is the demo.
So what we're going to talk about today is

98
00:07:06,539 --> 00:07:10,319
how we built this product, how we put it together
so that you can walk out of here understanding

99
00:07:10,319 --> 00:07:14,479
how you actually make player versus player
games with HTML5 and then you can go off and

100
00:07:14,479 --> 00:07:17,680
make awesomeness on your own because that's
what I/O is all about, right?

101
00:07:17,680 --> 00:07:22,499
So let's start at the top. The player part
of player versus player is the most important.

102
00:07:22,499 --> 00:07:26,219
So in a traditional game developer sense,
when you want to get a bunch of computers

103
00:07:26,219 --> 00:07:30,529
simulating a game together the easiest way
to do it is to allow each game to actually

104
00:07:30,529 --> 00:07:35,270
simulate the state on its own and then transfer
the state to all the other machines.

105
00:07:35,270 --> 00:07:40,129
This model is actually called a peer-to-peer
networking, so each game actually independently

106
00:07:40,129 --> 00:07:45,120
computes all the physics, math, position of
rockets, explosions, power-ups, sends it to

107
00:07:45,120 --> 00:07:48,389
all the other clients which receives it and
says, Okay, this is your game state.

108
00:07:48,389 --> 00:07:54,620
Now, in the early '90s this was the predominant
way that games did multiplayer networking,

109
00:07:54,620 --> 00:07:58,509
and we've thankfully moved away from that
for a couple of reasons. Number one is this

110
00:07:58,509 --> 00:08:03,650
methodology is actually really prone to lag
or high latency. So what will happen is in

111
00:08:03,650 --> 00:08:08,279
a player versus player or a peer-to-peer network,
if any single player actually starts to slow

112
00:08:08,279 --> 00:08:13,370
down or their connection is bad or the machine
slows down, you miss a whole load of data

113
00:08:13,370 --> 00:08:17,159
that has to be synced between all the other
machines. And the only real resolution to

114
00:08:17,159 --> 00:08:21,319
that is actually to halt the other players
in the simulation or slow them down as well.

115
00:08:21,319 --> 00:08:25,409
So if any of you played some classic first-person
shooter games from the '90s you would get

116
00:08:25,409 --> 00:08:28,999
that disconnected icon in the corner, like,
Hey, wait, we're waiting for someone to tell

117
00:08:28,999 --> 00:08:31,379
us what's going on.
Another problem with the peer-to-peer networking

118
00:08:31,379 --> 00:08:35,469
model is it was massively prone to cheating.
So what would happen is a single player could

119
00:08:35,469 --> 00:08:40,139
say Hey, I just picked up the rune of Antioch
and I'm now invincible for the next 12 days,

120
00:08:40,139 --> 00:08:44,639
and all the other players would have to abide
by that information because that's the way

121
00:08:44,639 --> 00:08:48,399
peer to peer worked.
Thankfully again we've moved from this.

122
00:08:48,399 --> 00:08:51,920
What we use today, and this is what GRITS
is actually built on, is the technology called

123
00:08:51,920 --> 00:08:55,870
the authoritative server. So instead of the
clients actually calculating the game state

124
00:08:55,870 --> 00:09:00,420
themself, we actually allow a centralized
server to calculate all the game state and

125
00:09:00,420 --> 00:09:05,560
then send the results down to the clients.
At this point this means the clients are nothing

126
00:09:05,560 --> 00:09:10,350
more than dumb terminals. All they do is take
an input, send it to the server, receive game

127
00:09:10,350 --> 00:09:14,639
state and render the results of what the server
tells them to do.

128
00:09:14,639 --> 00:09:19,089
This is a lot better. First off, it fixes
our cheating problem because the server is

129
00:09:19,089 --> 00:09:22,920
authoritative. It tells you who has the rune
of Antioch and whether or not it's [indiscernible]

130
00:09:22,920 --> 00:09:29,040
and whether or not there's a DPS sell at the
end of it, but that's a separate discussion.

131
00:09:29,040 --> 00:09:29,899
Gamers!
[Laughter]

132
00:09:29,899 --> 00:09:33,980
>>Colton McAnlis: Secondly, it also fixes
the lag problem, right? If any single individual

133
00:09:33,980 --> 00:09:38,310
actually drops out of the network or experiences
bad latency, what happens is we don't have

134
00:09:38,310 --> 00:09:42,449
to slow down the other players in the simulation,
we just have to let that guy go do its thing

135
00:09:42,449 --> 00:09:48,149
and the server assumes that it hasn't received
any new input. This actually creates a better

136
00:09:48,149 --> 00:09:51,440
quality of game play for the rest of the people
in the simulation.

137
00:09:51,440 --> 00:09:55,279
This is actually pretty much the architecture
that most multiplayer games are built on today.

138
00:09:55,279 --> 00:10:02,070
This includes all your RPG's, MMO's, FPS's.
Most RTS games, real time strategy games,

139
00:10:02,070 --> 00:10:05,899
today are actually built on the peer-to-peer
network technology simply because there's

140
00:10:05,899 --> 00:10:09,540
so much data to actually simulate, and then
they get around the cheating issue with some

141
00:10:09,540 --> 00:10:14,899
other craziness that is way beyond this talk.
Because we have an authoritative server we

142
00:10:14,899 --> 00:10:19,660
run into a very specific problem, and that
problem is server compute latency. So let's

143
00:10:19,660 --> 00:10:23,399
say you're running on the client and you actually
say, Hey, I want to move my robot forward.

144
00:10:23,399 --> 00:10:27,990
That input is actually sent up to the server.
The server will take some time to compute

145
00:10:27,990 --> 00:10:32,649
the new state and then the state is then transferred
back down to the client where the client receives

146
00:10:32,649 --> 00:10:37,750
it, updates its information and then hopefully
displays it to the user.

147
00:10:37,750 --> 00:10:43,170
The problem with this is that the time between
input move and update state from the server

148
00:10:43,170 --> 00:10:47,839
is going to always be longer than it takes
for the client to actually render the next

149
00:10:47,839 --> 00:10:51,149
frame, or at least you hope that you're rendering
it at 60 frames per second and you're not

150
00:10:51,149 --> 00:10:54,500
getting packets that fast.
The result of this is that you actually get

151
00:10:54,500 --> 00:10:58,750
really choppy animation. So we've got our
robot on the bottom here and if we just only

152
00:10:58,750 --> 00:11:02,560
update his position when the server tells
us to, he will pop into position A and then

153
00:11:02,560 --> 00:11:07,560
pop into position B, if my clicker works.
See, the clicker, it's awesome.

154
00:11:07,560 --> 00:11:14,560
Now to compete -- uh, blublublublublu. Will
she write blublublublublu if I say that again?

155
00:11:19,300 --> 00:11:21,220
Yes!
[Laughter]

156
00:11:21,220 --> 00:11:28,220
>>Colton McAnlis: I found a new toy!
I want to actually do the rest of the talk

157
00:11:29,360 --> 00:11:31,079
like this.
[Laughter]

158
00:11:31,079 --> 00:11:36,259
>>Colton McAnlis: Sorry, I'm messing with
the people typing.

159
00:11:36,259 --> 00:11:40,540
Anyhow, GRITS computes this with something
we actually call clientside protection, which

160
00:11:40,540 --> 00:11:44,329
means that while the server is actually computing
the game state the client will compute the

161
00:11:44,329 --> 00:11:49,259
same game state in parallel. What this means
is that after the user issues the move command,

162
00:11:49,259 --> 00:11:53,009
that is sent off to the server and the server
will compute the state, but the client will

163
00:11:53,009 --> 00:11:57,990
also compute the state. This actually allows
us to do a smooth animation between the next

164
00:11:57,990 --> 00:12:04,019
position so that the user actually doesn't
see this lag created by sending packets to

165
00:12:04,019 --> 00:12:06,680
the server.
And that was supposed to be animated, but

166
00:12:06,680 --> 00:12:09,509
something happened and so the arrows mean
animation.

167
00:12:09,509 --> 00:12:16,459
Use your imagination. You guys are smart.
I think. She wrote it, cool.

168
00:12:16,459 --> 00:12:21,759
The cool thing is that's on the internet live
right now. Someone is like "He's insulting

169
00:12:21,759 --> 00:12:24,529
the audience!"
So anyhow, that's the basics of how player

170
00:12:24,529 --> 00:12:27,420
versus player games work.
Now, let's talk about the things that GRITS

171
00:12:27,420 --> 00:12:32,000
does specifically because GRITS of course
is an HTML5 game. So what you just saw is

172
00:12:32,000 --> 00:12:36,050
applicable to C++ games and everything else
in the wild. GRITS being HTML5 had to do a

173
00:12:36,050 --> 00:12:43,050
lot of things different. Let's dive into that
a bit.

174
00:12:43,370 --> 00:12:47,449
So let's talk about our architecture. First
off, our client's information, which consists

175
00:12:47,449 --> 00:12:53,180
basically of our HTML data, our JavaScript,
our sound files in OGG, everything else, this

176
00:12:53,180 --> 00:12:57,740
is actually served on top of App Engine. We
actually serve all the content. Our domain

177
00:12:57,740 --> 00:13:03,630
is at appengine.com domain. And we actually
store and communicate to App Engine, also

178
00:13:03,630 --> 00:13:07,209
store the database information. So the number
of kills you get, the number of credits you

179
00:13:07,209 --> 00:13:12,100
have, how many times you use the energy sword
of awesomeness to frag some other dude, that's

180
00:13:12,100 --> 00:13:16,690
all stored on the server. Actually, if you
look at the code you will see traces of information

181
00:13:16,690 --> 00:13:20,459
about how to do unlockable items. One of the
first updates in the patches that we want

182
00:13:20,459 --> 00:13:25,690
to do is show you how to do unlockable items
using Wallet and credit applications. You

183
00:13:25,690 --> 00:13:30,319
guys can just grab that code and put it into
your games, making more awesome games.

184
00:13:30,319 --> 00:13:34,110
The client will also communicate to Google+
as well as Google Analytics. You saw in the

185
00:13:34,110 --> 00:13:38,459
video that Google+ we grab your friends information,
we can actually link to the page, we can post

186
00:13:38,459 --> 00:13:42,399
to your stream.
The Analytics one is actually really cool.

187
00:13:42,399 --> 00:13:47,839
So for those of you in here who aren't game
developers, there's the concept of being able

188
00:13:47,839 --> 00:13:52,589
to track what your users are doing at pretty
much every second of a game. So what we actually

189
00:13:52,589 --> 00:13:57,699
do in GRITS is when a player dies we actually
log that data to Google Analytics. We actually

190
00:13:57,699 --> 00:14:02,040
fire off a custom event and that's stored
in the Analytic system. Then what we can do

191
00:14:02,040 --> 00:14:06,199
is come back and say, Hey, show me the map
and show me where all the deaths have occurred

192
00:14:06,199 --> 00:14:10,470
in the past 72 hours. The cool thing about
it is that it allows our designers to take

193
00:14:10,470 --> 00:14:14,069
a look at the map and go Hey, you know, there's
a choke point right here. There's probably

194
00:14:14,069 --> 00:14:17,610
way too many deaths. I'd like to change the
map a little bit and move things around.

195
00:14:17,610 --> 00:14:22,069
It also tells us things like how many people
actually use the energy sword and whether

196
00:14:22,069 --> 00:14:25,569
or not we should get rid of it entirely.
And we drive all this data collection through

197
00:14:25,569 --> 00:14:30,440
Google Analytics, so it's not just for webmasters
trying to figure out if half the traffic is

198
00:14:30,440 --> 00:14:35,069
coming from Asia or it's coming from slashdot.
We can actually use these custom events to

199
00:14:35,069 --> 00:14:38,839
get real information about what our players
are actually doing in our game and provide

200
00:14:38,839 --> 00:14:45,839
a tight feedback loop to make adjustments,
real time. We use node.js. Node.js fans?

201
00:14:47,000 --> 00:14:47,699
[ APPLAUSE ]

202
00:14:47,699 --> 00:14:52,670
>>Colton McAnlis: When I was taking notes,
I was like I need to write a talk, there's

203
00:14:52,670 --> 00:14:58,500
probably going to be robot fans and node.js
fans. Check. We -- our back end actually runs

204
00:14:58,500 --> 00:15:04,160
node.js out in the cloud running on a compute
server, and our client communicates to our

205
00:15:04,160 --> 00:15:08,839
game instance, our node.js instance, using
socket IO through websockets, and there's

206
00:15:08,839 --> 00:15:13,420
a cool fact of the matter that, you know,
Web sockets are actually sort of a TCP variant

207
00:15:13,420 --> 00:15:18,879
with a much safer UI. Much safer API. Now,
the client will also do some other interesting

208
00:15:18,879 --> 00:15:23,339
communications. You'll notice that when I
clicked quick game, or wanted to join a game,

209
00:15:23,339 --> 00:15:27,589
the client and the server actually communicate
to match maker. Now, this is actually one

210
00:15:27,589 --> 00:15:31,129
of sort of the advents in the last fifteen
years of game development process is the fact

211
00:15:31,129 --> 00:15:35,899
that people realize that if there's a 12-year-old
kid sitting in some area where he doesn't

212
00:15:35,899 --> 00:15:39,629
have to go to school all day, and can just
sit there and play games all day, you hop

213
00:15:39,629 --> 00:15:42,759
on for a match, and you're matched with him,
he's going to destroy you, and every time,

214
00:15:42,759 --> 00:15:46,470
and that's not cool for you, because he's
like, "ha, ha, I'm only 12," and you're like,

215
00:15:46,470 --> 00:15:51,819
"Hey, dude, i got a job, lay off me." He's
like, "you smell". Or at least that's what

216
00:15:51,819 --> 00:15:56,550
my last weekend was like. Anyhow, what match
makers do is they effectively attempt to try

217
00:15:56,550 --> 00:16:01,680
to match players of unique skills, put them
together in buckets, find an open game this

218
00:16:01,680 --> 00:16:06,050
massive conversational back end that figures
out how to slot people and combine them in

219
00:16:06,050 --> 00:16:09,980
ways that make their experience in the game
a lot better. So we actually have a match

220
00:16:09,980 --> 00:16:14,209
maker running for GRITS that runs entirely
on app engine, and the cool thing is we're

221
00:16:14,209 --> 00:16:18,170
not going to talk about this today, but you
all need to go to the talk by Fred Sauer called

222
00:16:18,170 --> 00:16:21,850
"Gaming in the Cloud", and I think actually
that time is incorrect. I think it got moved

223
00:16:21,850 --> 00:16:25,759
again. But anyhow, go to gaming in the cloud.
He's going to talk about all of the app engine

224
00:16:25,759 --> 00:16:31,240
side of GRITS including that interesting QR
code. One of the things Fred did was actually

225
00:16:31,240 --> 00:16:36,589
write an Android controller for GRITS, and
so if you actually scan that QR code with

226
00:16:36,589 --> 00:16:40,620
your Android phone, you can actually play
the entire game using your Android device,

227
00:16:40,620 --> 00:16:45,550
connected to your PC. We use this as sort
of a controller. Definitely check out his

228
00:16:45,550 --> 00:16:49,889
talk, he's a cool guy.
At the core of our simulation is a fantastic

229
00:16:49,889 --> 00:16:55,670
library called box2d.JS. And what you're looking
at here is sort of a mockup of a top-down

230
00:16:55,670 --> 00:16:59,720
setup. Box2d. So, rather when you look at
this, you see a game, right?

231
00:16:59,720 --> 00:17:04,600
But in reality, it's comprised of a lot of
box2d primitives. In green here we have the

232
00:17:04,600 --> 00:17:07,720
physics objects represents collision. You
know, you can't shoot through these things,

233
00:17:07,720 --> 00:17:12,850
you can't walk through these things. The red
squares here actually represent in-game objects.

234
00:17:12,850 --> 00:17:18,570
These are tele-porters. Box2d has a fantastic
call back system in that as you intersect

235
00:17:18,570 --> 00:17:22,050
with two items or as a collision occurs, we
get a nice little call back and we can respond

236
00:17:22,050 --> 00:17:25,800
to it properly, which means for us writing
GRITS, we actually can be pretty lazy about

237
00:17:25,800 --> 00:17:29,200
what kind of code we write. We actually don't
have to write interesting simulation loops

238
00:17:29,200 --> 00:17:32,700
or anything. The only code we really write
is how to spawn an object and what to do when

239
00:17:32,700 --> 00:17:36,820
it hits another object, so when a user touches
a tele-porter object, we know that a user

240
00:17:36,820 --> 00:17:41,970
is touching a tele-porter and then can make
the appropriate change to tele-port him to

241
00:17:41,970 --> 00:17:47,630
whatever position he's at or into, you know,
zulu alpha 90 which is a cool place, you should

242
00:17:47,630 --> 00:17:52,890
check it out. We also use a great concept
that Box2D provides which is the collision

243
00:17:52,890 --> 00:17:59,280
filtering system, so any time we actually
launch projectiles or objects or spawn a new

244
00:17:59,280 --> 00:18:02,980
member into the game, they're assigned a team,
so what you're looking at right there is their

245
00:18:02,980 --> 00:18:07,620
red player actually -- or the player there
is actually on the red team, firing projectiles

246
00:18:07,620 --> 00:18:11,590
that are attached to the red team, and of
course subsequently we have the blue team.

247
00:18:11,590 --> 00:18:15,910
This allows us to actually say, hey, don't
do friendly fire, right? So if you got a team,

248
00:18:15,910 --> 00:18:18,550
all of red team, you don't want to get shot
in the back of the head by your teammate.

249
00:18:18,550 --> 00:18:23,200
Box2d handles all this for us. All we have
to do when we spawn a projectile is specify

250
00:18:23,200 --> 00:18:27,650
don't intersect with anybody else who's got
the team red flag. Again, completely hands

251
00:18:27,650 --> 00:18:31,580
off on our part. We're so super lazy when
writing this project. Box2D did all the heavy

252
00:18:31,580 --> 00:18:37,580
lifting for us. The explosion up there is
actually the same process, again, projectile

253
00:18:37,580 --> 00:18:41,450
intersected with the wall and we computed
what those two objects were, and then decided

254
00:18:41,450 --> 00:18:46,190
that the proper result was to actually spawn
an instance of an explosion. Again, Box2D

255
00:18:46,190 --> 00:18:52,850
is awesome. Use it. Now, one of the issues
that we ran into while having Box2D as well

256
00:18:52,850 --> 00:18:59,850
as clientside prediction is prediction adjustment,
so what happens is, as the client says I would

257
00:18:59,870 --> 00:19:04,050
like to move forward, the client can go off
and move forward, well, the problem is positioning

258
00:19:04,050 --> 00:19:08,660
is actually driven by Box2D, which means that
the server can actually disagree with where

259
00:19:08,660 --> 00:19:12,160
you're supposed to be at. So the client thinks
he should be there, while the server says

260
00:19:12,160 --> 00:19:15,220
actually you should be along this spector
over here for some whatever reason; they're

261
00:19:15,220 --> 00:19:18,920
you're running into a wall or a demon is chasing
you. I don't know why there would be a demon

262
00:19:18,920 --> 00:19:23,580
chasing a robot, that would be weird, just
go with it. So what we do is something called

263
00:19:23,580 --> 00:19:29,280
prediction adjustment where over time we'll
actually modify the forward vector of our

264
00:19:29,280 --> 00:19:34,630
moving robots slightly toward what the server
has told us we should be at, so what happens

265
00:19:34,630 --> 00:19:40,100
is after a couple of frames, we correct our
position just enough where the player actually

266
00:19:40,100 --> 00:19:45,910
doesn't see that they're getting discrepancy
between the client server. This actually allows

267
00:19:45,910 --> 00:19:49,280
us to hide a lot of the latency that you would
normally see from the client and the server

268
00:19:49,280 --> 00:19:53,760
-- the authoritative server communication
process. Now, if the client and the server

269
00:19:53,760 --> 00:19:58,560
position differ by some extremely large value,
we'll just snap, because at that point, you

270
00:19:58,560 --> 00:20:01,620
know, it's like, oh, we're fifteen frames
away, and it would take too long and it doesn't

271
00:20:01,620 --> 00:20:05,770
look good. So we do have sort of a catch-all
in case we get too far ahead. Now one of the

272
00:20:05,770 --> 00:20:09,870
other things . This was -- we actually found
this like last week, so I'm glad we fixed

273
00:20:09,870 --> 00:20:15,950
the bug before my talk -- yay -- is our third
server actually has to drive the client in

274
00:20:15,950 --> 00:20:20,310
more ways than we were originally predicting.
So let's say you're running the client here,

275
00:20:20,310 --> 00:20:26,620
and you choose to fire a missile, I think
that's the proper pronunciation, and the client

276
00:20:26,620 --> 00:20:30,450
says, hey, this missile has intersected with
this object. Well, again, remember the client

277
00:20:30,450 --> 00:20:34,280
is computing games data parallel, so the client
actually says, hey, this guy is there. Well,

278
00:20:34,280 --> 00:20:39,430
the server says, no, he's actually over here.
So now we have a mismatch. The client has

279
00:20:39,430 --> 00:20:43,860
said a collision has occurred, the server
says no, you're wrong, and so what we do in

280
00:20:43,860 --> 00:20:48,040
this situation is we actually say, I'm sorry,
client, we're not listening to you, right,

281
00:20:48,040 --> 00:20:52,200
because to a player if they saw collision,
they would expect to see health go down or

282
00:20:52,200 --> 00:20:57,510
some sort of validation that they're doing
the right thing in killing their fellow robots,

283
00:20:57,510 --> 00:21:00,950
but instead what we do is we ignore the collision
and actually let the bullet pass through.

284
00:21:00,950 --> 00:21:04,690
This is really important from a game player
perspective. There's been a lot of research

285
00:21:04,690 --> 00:21:09,690
over the past ten years about doing multiplayer
prediction and adjustment analysis and what

286
00:21:09,690 --> 00:21:14,510
players actually can perceive as the problem
versus actually being the problem, and actually,

287
00:21:14,510 --> 00:21:19,740
saying, hey, we're going to ignore clientside
prediction is hands down is the perceptive

288
00:21:19,740 --> 00:21:23,290
correct solution from all the game players.
If you're writing games, make sure you do

289
00:21:23,290 --> 00:21:29,680
it this way. Or not. It's up to you. You can
write games. You're smart. Let's talk about

290
00:21:29,680 --> 00:21:36,460
networking. One of the things that we did
specifically, how many of you have actually

291
00:21:36,460 --> 00:21:42,200
written like TCP networking code in C++?
A lot of hands. I'm proud of this room.

292
00:21:42,200 --> 00:21:46,360
This is an awesome room. We should like fight
the other rooms and prove how awesome we are.

293
00:21:46,360 --> 00:21:51,810
I think we'd win. Anyhow, so in C++ what you
usually end up with is some sort of structure

294
00:21:51,810 --> 00:21:57,180
that you define like this, a flag for what
kind of packet it is, 32 bits for the data,

295
00:21:57,180 --> 00:22:01,440
again let's say a float, a direction packet,
and then this would be communicated between

296
00:22:01,440 --> 00:22:04,710
client server, because sooner or later in
C++ this is usually in a header file, and

297
00:22:04,710 --> 00:22:09,930
you would cut a server build versus a -- let's
say you have a Junior programmer that comes

298
00:22:09,930 --> 00:22:15,860
in says, I didn't want to listen to you anyway,
I'm going to push a client build without updating

299
00:22:15,860 --> 00:22:20,920
the server. Now everything is broken, right,
we no longer have the same package structure,

300
00:22:20,920 --> 00:22:25,710
all the data is getting out of line and this
is a massive problem. GRITS solves this with

301
00:22:25,710 --> 00:22:30,660
a really unique solution that I felt was super
important to talk about. What we actually

302
00:22:30,660 --> 00:22:34,770
define is rather than defining the structures
themselves that are then copied between client

303
00:22:34,770 --> 00:22:39,030
server in builds that we cut, we actually
define a proto structure, so what you're seeing

304
00:22:39,030 --> 00:22:42,560
right here is the input structure. We say
who it's actually from and what direction

305
00:22:42,560 --> 00:22:47,380
you're going, specified as strengths. We're
sort of proto defining what this class should

306
00:22:47,380 --> 00:22:53,330
be, or instructor, or whatever it is in JavaScript.
I'm not a JavaScript guy. What the server

307
00:22:53,330 --> 00:22:57,820
actually does, is when it instance boots up,
it actually parses this JavaScript file, reads

308
00:22:57,820 --> 00:23:02,280
this proto data and actually runs code generation
on it, so rather than actually generating

309
00:23:02,280 --> 00:23:07,490
the structures, we actually generate a whole
suite of functions, an API set that allows

310
00:23:07,490 --> 00:23:12,180
the client and the server -- well, the server
specifically to actually use that as an API,

311
00:23:12,180 --> 00:23:18,590
push data in and the APIs will properly pack
the bytes in an efficient manner into what

312
00:23:18,590 --> 00:23:23,320
the structure would be. Now here is where
the cool part of JavaScript comes into play.

313
00:23:23,320 --> 00:23:29,080
We actually pass this code generated set of
APIs down to the client, and then on the client

314
00:23:29,080 --> 00:23:34,350
we just call an eval function, so this means
that our client and server will always be

315
00:23:34,350 --> 00:23:38,700
in sync when communicating with each other.
There is no possible way that they can actually

316
00:23:38,700 --> 00:23:42,300
get out of sync, because as a client connects
to its server, it actually receives all of

317
00:23:42,300 --> 00:23:45,850
the information on how it's supposed to communicate
through this API packet.

318
00:23:45,850 --> 00:23:49,470
This is actually really cool. It's one of
the few things that I love about JavaScript

319
00:23:49,470 --> 00:23:55,800
that you can't do in C++ for game development,
right? Actually say, here, use this. Now,

320
00:23:55,800 --> 00:23:59,630
once you're writing this code, especially
with multiplayer games, you end up shooting

321
00:23:59,630 --> 00:24:04,380
a lot of bullets, sooner or later you're going
to just sit there and hit buttons, kind of

322
00:24:04,380 --> 00:24:06,640
like that button master, playing a street
fighter game. It's like, you're not hitting

323
00:24:06,640 --> 00:24:10,770
any buttons but you're still beating me, I
hate you and you're 12. Yay. What we actually

324
00:24:10,770 --> 00:24:16,120
found was in our original implementation,
that in a about a second -- in about a second

325
00:24:16,120 --> 00:24:21,330
of game play with a full 8 player session,
we'd send about 6.2 megabytes of data, and

326
00:24:21,330 --> 00:24:26,400
that is position information, directional
information, index data, you know, what state

327
00:24:26,400 --> 00:24:31,400
is, rotation, all this other stuff. So we
needed to address this really quickly, because

328
00:24:31,400 --> 00:24:36,260
I'm sure again everyone here is at Google
I/O, your internet developers, you understand

329
00:24:36,260 --> 00:24:42,670
this graph, is that if I've got 240 millisecond
window and I've got really fat packets, the

330
00:24:42,670 --> 00:24:47,710
number of packets, or rather the information
update from the server that I get is limited,

331
00:24:47,710 --> 00:24:52,430
so in that 240 milliseconds, I can only get
so much data from the server to tell me about

332
00:24:52,430 --> 00:24:56,900
the game state. I can only update my information
so fast. Instead what you want to do is create

333
00:24:56,900 --> 00:25:01,480
smaller packets, more concise information,
so we can receive more of them in that short

334
00:25:01,480 --> 00:25:05,900
window so we can update the game state quicker,
because again, since the server is doing the

335
00:25:05,900 --> 00:25:11,250
entire computation, we need to ensure that
we receive the updates as fast as possible

336
00:25:11,250 --> 00:25:16,990
so the client can stay in sync. Now, one of
the ways we do this -- clicking -- is actually

337
00:25:16,990 --> 00:25:20,980
using packet grouping. So usually when you
send a packet down the wire there's multiple

338
00:25:20,980 --> 00:25:25,700
levels of technology stack, and each level
that your packet runs into usually adds a

339
00:25:25,700 --> 00:25:30,770
little bit of overhead, right? So socket IO
will add some bits to it, the ttp layer will

340
00:25:30,770 --> 00:25:34,510
add some bits to it, maybe the operating system
will add some bits to it. Well, what happens

341
00:25:34,510 --> 00:25:38,010
is you actually end up with a lot of data
that you don't need, right? And for these

342
00:25:38,010 --> 00:25:42,640
individual packets, this actually adds up
to a bit, a significant amount. So what we

343
00:25:42,640 --> 00:25:48,920
do is we actually have a heuristic set that
defines the ability to group all of our packets

344
00:25:48,920 --> 00:25:53,340
based upon memory size. So what we say, is,
hey, we're going to cue up our packets until,

345
00:25:53,340 --> 00:25:57,250
you know, a time limit has elapsed, so if
we only get one packet, and let's say a second

346
00:25:57,250 --> 00:26:01,160
has elapsed, we just go ahead and send that
on. Or we'll cue up all of our packets until

347
00:26:01,160 --> 00:26:05,520
it reaches like a megabyte, and then we'll
send that down the line. What this does, it

348
00:26:05,520 --> 00:26:10,250
actually reduces all of the additional overhead
that's added by each of these layers. This

349
00:26:10,250 --> 00:26:14,120
is really a critical thing for us because
we send a lot of data.

350
00:26:14,120 --> 00:26:19,100
One of the other things we do, or another
set of things we do, is actually duplicate

351
00:26:19,100 --> 00:26:26,100
packet reduction, so we do this in two ways:
The first is that we understand that the people

352
00:26:27,790 --> 00:26:31,770
writing the game are not thinking about the
networking layer as they're writing the game,

353
00:26:31,770 --> 00:26:33,790
right?
So as we're going through update loop, as

354
00:26:33,790 --> 00:26:36,780
all the items are updating themselves, sooner
or later you're going to have someone come

355
00:26:36,780 --> 00:26:40,910
along and assign a variable to A, and then
20 loops later it's going to assign it to

356
00:26:40,910 --> 00:26:43,820
C, and then some time is going to go by and
then you're going to assign it to B. What

357
00:26:43,820 --> 00:26:47,810
we do in this situation is we actually track
these state data and updates over time, and

358
00:26:47,810 --> 00:26:52,100
we only send the latest update, so what will
happen is we'll say, hey, if the variable

359
00:26:52,100 --> 00:26:55,920
has already been set and we're setting it
to something different, forget the other state,

360
00:26:55,920 --> 00:26:59,620
don't put it in our packet grouping. Right?
This keeps the client from doing redundant

361
00:26:59,620 --> 00:27:05,720
state updates, in otherwise C, A and then
finally B, which it doesn't need to do. Another

362
00:27:05,720 --> 00:27:10,410
thing we do with our staple tracking is we
actually analyze whether or not the state

363
00:27:10,410 --> 00:27:15,440
that we're about to update a packet for is
identical to the state that already exists,

364
00:27:15,440 --> 00:27:19,510
so if a line of code comes along and says
let's set the position to A, and the position

365
00:27:19,510 --> 00:27:24,120
is already A, then the server won't actually
update that data, won't send it to the client

366
00:27:24,120 --> 00:27:30,510
at all. Now, with the packet grouping, as
well as the duplicate packet deduping -- Dr.

367
00:27:30,510 --> 00:27:36,310
Seuss rhyme. I should write a book. We actually
modify our situation quite significantly.

368
00:27:36,310 --> 00:27:41,960
We end up going from about 6.2 megabytes per
second to about 1.3, which is a lot better

369
00:27:41,960 --> 00:27:46,730
in our situation. So these are like three
super easy things that had really nothing

370
00:27:46,730 --> 00:27:52,420
to do with the technology but had a lot to
do with our analysis of how our game was molesting

371
00:27:52,420 --> 00:27:59,420
the networking stack and sending packets around.
So let's talk about rendering. HTML5 is awesome.

372
00:28:00,350 --> 00:28:03,800
I always thought this was a great quote that
no one really laughs at, but "world domination

373
00:28:03,800 --> 00:28:07,530
often starts as a misunderstood napkin doodle."
Like I don't know if you guys walk into a

374
00:28:07,530 --> 00:28:12,510
bar and see some weird doodle that looks like
a dinosaur attacking Manhattan; I've got an

375
00:28:12,510 --> 00:28:19,060
idea. At least in my mind, that's how it works.
So again, let's go back to our mockup screen

376
00:28:19,060 --> 00:28:22,240
here, again you've got a bunch of things,
you've got a bunch of pretty pixels that are

377
00:28:22,240 --> 00:28:26,860
being displayed. In reality this is broken
down is that this is actually our background

378
00:28:26,860 --> 00:28:31,020
layer. Our background layer is a bunch of
64 by 64 pixel sprites that an artist has

379
00:28:31,020 --> 00:28:35,270
placed together on a large sheet. And we actually
render that data. On top of that, we actually

380
00:28:35,270 --> 00:28:40,330
render our player Avatars which are animated
sprite sheets, and then all of our projectiles

381
00:28:40,330 --> 00:28:44,590
and explosions are also animated sprite sheets
that are blended using a different composite

382
00:28:44,590 --> 00:28:51,590
layer. In order to do this, and stay performance,
we actually heavily use the concept of atlasing.

383
00:28:52,600 --> 00:28:56,970
Now, in the games industry we call it atlasing.
I know in the HTML5 world or Web development

384
00:28:56,970 --> 00:29:01,410
you call this sprite sheets, right? Nods.
I don't see a nod. Everyone asleep already?

385
00:29:01,410 --> 00:29:07,160
Cool. That dude game me a thumb's up. Get
him a T-shirt too. Thumb's up for T-Shirt.

386
00:29:07,160 --> 00:29:11,160
Anyhow, we actually atlas everything. In fact,
you're seeing, and what you're looking at

387
00:29:11,160 --> 00:29:15,120
here are the only three atlases we actually
use in the game. That's it. Everything, every

388
00:29:15,120 --> 00:29:18,960
piece of art, all of our menu data, all of
our in-game sprites are packed into these

389
00:29:18,960 --> 00:29:25,850
three textures, and here's why. With one Atlas
request, let's say that you have got a 4k-by-4k

390
00:29:25,850 --> 00:29:31,750
texture, about 100k of information total,
your total transfer time as measured by the

391
00:29:31,750 --> 00:29:36,210
Chrome developer tools is about 240 milliseconds,
so this is nice, right? We have got a 4k-by-4k

392
00:29:36,210 --> 00:29:42,060
texture, it comes down the line pretty quickly,
really fast, get it into the canvas render,

393
00:29:42,060 --> 00:29:46,410
and we are doing good.
Now, if you were to say chop that 4k-by-4k

394
00:29:46,410 --> 00:29:53,410
texture up into say 4096 individual requests,
each one is about 10k each at about 64 pixels

395
00:29:54,310 --> 00:30:01,000
by 64 pixels, what you end up with is about
4.3 seconds of total load time. And the reason

396
00:30:01,000 --> 00:30:07,130
for this is kind of two to threefold. Firstly
is that any given client connection to a server

397
00:30:07,130 --> 00:30:11,950
can have -- only have so many open connections,
so if you have got 4,000 connections sitting

398
00:30:11,950 --> 00:30:15,760
around waiting to happen and your browser
has only allowed six at a time, basically

399
00:30:15,760 --> 00:30:19,850
everything gets stacked. What you are looking
at in the Chrome tools here is that transparent

400
00:30:19,850 --> 00:30:24,330
line, the long bar there, is actually Chrome
being blocked by the server saying "I'm sorry

401
00:30:24,330 --> 00:30:28,660
you can't get this file yet because we're
still waiting on something else to complete."

402
00:30:28,660 --> 00:30:34,090
So with all of these loose assets being requested,
you slow down your load time significantly.

403
00:30:34,090 --> 00:30:38,850
Now, you will also notice at the end of the
line is the little opaque circle. That opaque

404
00:30:38,850 --> 00:30:43,650
circle actually represents the time once we've
actually received the file to decompress it,

405
00:30:43,650 --> 00:30:46,870
get it on the screen, do all of the other
stuff, which is really fast process. We lose

406
00:30:46,870 --> 00:30:51,570
almost, you know, we lose four seconds just
in waiting around for Chrome to do more connections.

407
00:30:51,570 --> 00:30:55,330
So in reality using Atlases saves your load
time significantly, which again a lot of Web

408
00:30:55,330 --> 00:30:59,540
developers are starting to notice this, so
stop using the leaf assets, stop doing it,

409
00:30:59,540 --> 00:31:05,220
or the robots will get you.
Now when our artists made our original map,

410
00:31:05,220 --> 00:31:08,670
they actually came to us with a small set.
They said, "Hey, we are going to use these

411
00:31:08,670 --> 00:31:10,810
64-by-64 tiles, and we're going to draw them
everywhere."

412
00:31:10,810 --> 00:31:13,370
We said, "That's fine."
When you look at the screen, you should really

413
00:31:13,370 --> 00:31:16,520
look at it like this. Which is sort of how
the rendering engine looks at it, a bunch

414
00:31:16,520 --> 00:31:20,740
of little tiles that are rendered on the canvas.
Well, the issue we ran into was that each

415
00:31:20,740 --> 00:31:24,880
one of those was actually a separate draw
call. And for each draw call you have sort

416
00:31:24,880 --> 00:31:29,060
of an implicit API overhead that's involved
in the draw call. Now you'll see that there's

417
00:31:29,060 --> 00:31:33,100
actually some nice blends here, we've got
a green background, we've got some of the

418
00:31:33,100 --> 00:31:36,920
tiles, we've got some more of the little hexagons
that are blending on top of it, and then we've

419
00:31:36,920 --> 00:31:42,170
got a dent in the universe, and then a little
thing there. That's like five to seven draws

420
00:31:42,170 --> 00:31:46,500
per quadrant there. Now, this adds up over
time because artists want to make really pretty

421
00:31:46,500 --> 00:31:51,480
art. That's usually accomplished by compositing
layers of art on top of itself to create this

422
00:31:51,480 --> 00:31:54,670
really rich environment. Well, again, this
doesn't work for us, right? If you've got

423
00:31:54,670 --> 00:31:59,100
a high-res monitor, and a lot of screen space,
this is going to be a lot of draws and a lot

424
00:31:59,100 --> 00:32:02,530
of machines can't handle this. So what we
did to counteract this is actually used the

425
00:32:02,530 --> 00:32:07,350
concept of off DOM canvas, where rather than
rendering each of these small tiles at run

426
00:32:07,350 --> 00:32:11,900
time, we created a canvas object that's not
attached to the DOM and actually render each

427
00:32:11,900 --> 00:32:17,490
of these tiles into that canvas, and then
later on we can simply do one draw call, offsetting

428
00:32:17,490 --> 00:32:22,220
that large canvas wherever our ViewPort happens
to be. This actually was a huge savings for

429
00:32:22,220 --> 00:32:25,120
us.
On some of our Linux machines this actually

430
00:32:25,120 --> 00:32:30,380
took our frame rate from two frames a second
back up to 60. Just this one change. It was

431
00:32:30,380 --> 00:32:34,740
about 10 minutes of code to get us that frame
rate back, which was fantastic.

432
00:32:34,740 --> 00:32:37,900
Of course, then the artist came back, said,
"Oh, by the way I've got a bigger map for

433
00:32:37,900 --> 00:32:41,160
you," and then we ran into a different problem.
[Laughter]

434
00:32:41,160 --> 00:32:47,590
Which was now that we had a 24k by 24k pixel
map. [Laughter]. And we were doing one draw

435
00:32:47,590 --> 00:32:54,440
call every frame for this massive pile of
pixels. And that put us back at two frames

436
00:32:54,440 --> 00:32:59,210
a second. So all of my work was for naught.
To counteract this, we had to do something

437
00:32:59,210 --> 00:33:02,340
different. So let's say we have got our little
ViewPort there in pink because hot pink is

438
00:33:02,340 --> 00:33:08,860
the cool thing to do on the internet. Cool
thing to do on the internet. [Laughter]. Cool

439
00:33:08,860 --> 00:33:11,510
thing to do on the internet. Cool thing to
do -- oh, man [Laughter].

440
00:33:11,510 --> 00:33:15,490
>>Colt McAnlis: Sorry, when you find a toy,
you've just got to play with it.

441
00:33:15,490 --> 00:33:20,050
Anyhow, what I actually do is I actually create
-- in order to combat the fact that this one

442
00:33:20,050 --> 00:33:24,020
draw call actually puts too many pixels on
the screen, because the canvas actually just

443
00:33:24,020 --> 00:33:29,030
does a dumb draw. Right? It doesn't say this
pixel of this subtexture is or is not in your

444
00:33:29,030 --> 00:33:32,430
ViewPort. It just blips the whole thing to
the screen, and lets the GPU figure out the

445
00:33:32,430 --> 00:33:37,140
-- for hardware accelerated -- let's the GPU
figure out the details there. So what I actually

446
00:33:37,140 --> 00:33:40,910
do to combat this, is we actually chunked
up our environment. So when you are actually

447
00:33:40,910 --> 00:33:46,700
playing in the large maps in GRITS, we actually
chunk it up into 1024-by-1024 tiles, this

448
00:33:46,700 --> 00:33:51,250
heuristic of 1024 versus 24 or 28 or anything
else, was actually sort of just done by trial

449
00:33:51,250 --> 00:33:55,660
and error. We effectively said this looks
good on this Linux box, this Linux box is

450
00:33:55,660 --> 00:34:00,750
not powered. So what this allows us to do
is we were doing one draw call for the little

451
00:34:00,750 --> 00:34:07,270
pink box. We actually do two draw calls now,
but it's significantly less pixels that the

452
00:34:07,270 --> 00:34:10,960
disband process has to actually deal with
or more importantly that the GPU has to deal

453
00:34:10,960 --> 00:34:17,960
with, with rendering, clipping, figuring everything
else out. Now, let's talk about the tools.

454
00:34:18,579 --> 00:34:24,690
So when you are writing games -- actually
taking a step back, let's take a step back.

455
00:34:24,690 --> 00:34:28,029
So as a traditional game developer, I was
a game developer for about 10 years in the

456
00:34:28,029 --> 00:34:31,220
industry, worked a lot of really cool places
doing really cool things. One of the most

457
00:34:31,220 --> 00:34:36,210
important things that I worked on consistently
was creating really good tools that allowed

458
00:34:36,210 --> 00:34:41,909
designers and artists to create amazing content
that really caused people to buy our games.

459
00:34:41,909 --> 00:34:47,769
Now, in my opinion, one of the biggest drawbacks
to HTML5 as a viable gaming technology is

460
00:34:47,769 --> 00:34:53,869
the lack of good tools to allow content creators
to create great content. Now I'm not talking

461
00:34:53,869 --> 00:34:57,460
about the language here. I'm talking about
the ability to create content in a way that

462
00:34:57,460 --> 00:35:02,470
content creators can reflect with.
So what we did with GRITS was we didn't try

463
00:35:02,470 --> 00:35:07,500
to reinvent the wheel. Rather than trying
to create HTML5 specific tools, we went back

464
00:35:07,500 --> 00:35:11,920
to the basics and used tools from standard
C++ game development and just made sure that

465
00:35:11,920 --> 00:35:18,230
the data was read in by HTML5 properly. It
started with a great tool called Tiled. Tiled

466
00:35:18,230 --> 00:35:24,920
is a free open sourceish map editor on the
internet, and using QT as a primary UI engine,

467
00:35:24,920 --> 00:35:30,019
so that means that it runs across platform.
Now Tiled does some really cool stuff. What

468
00:35:30,019 --> 00:35:34,690
you are looking at here is actually our Atlas
of our map sprites and then of course our

469
00:35:34,690 --> 00:35:39,180
map next to it, you can actually go in and
fill in your sprites, use cool brushes, and

470
00:35:39,180 --> 00:35:42,930
use a blend effect and, you know, fill things
together.

471
00:35:42,930 --> 00:35:47,789
Tiled also allows us to create collision objects
or just objects in general, then we can flag

472
00:35:47,789 --> 00:35:51,599
them with collision values. So what you are
actually looking here is a the polygon tool

473
00:35:51,599 --> 00:35:56,589
actually specifying out that, hey, this is
some object in the environment. You can see

474
00:35:56,589 --> 00:36:00,230
on the side of the map over there, this is
actually the collision layer. Right? So when

475
00:36:00,230 --> 00:36:04,480
the game reads it in, it says anything in
the collision layer we make an actual physics

476
00:36:04,480 --> 00:36:08,299
object that you can't shoot through or run
through or teleport on top of or use the rune

477
00:36:08,299 --> 00:36:15,299
of Antioch to destroy it. Really critical.
This comes crucial into play when we do things

478
00:36:18,619 --> 00:36:23,869
like teleporters or quad damage or picking
up energy capsules, because what it allows

479
00:36:23,869 --> 00:36:28,430
us to do is put a little box on the map and
say, "Hey, this is a spawn item, this is a

480
00:36:28,430 --> 00:36:32,779
help box," right? So we can actually specify
all of that stuff inside of tiles, we don't

481
00:36:32,779 --> 00:36:35,930
have to write custom code for this.
In fact, the designer and the artist can use

482
00:36:35,930 --> 00:36:41,349
this tool exclusively, then it just spits
out a nice JSON file, which Tiled does, by

483
00:36:41,349 --> 00:36:45,410
the way, that we read into our game. And the
client and the server both read this information

484
00:36:45,410 --> 00:36:49,519
so we know where collision objects are, we
know where teleporters are and more importantly

485
00:36:49,519 --> 00:36:52,829
we know where quad damage is, because if you
don't have quad damage you are losing the

486
00:36:52,829 --> 00:36:59,829
game, pro tip tweet that. Pro tip.
The next tool we actually use is a great tool

487
00:37:00,299 --> 00:37:06,519
called Texture Packer. Texture Packer is probably
one of -- one of the most advanced tools that

488
00:37:06,519 --> 00:37:10,160
I have seen for actually taking a whole bunch
of small textures and then packing them into

489
00:37:10,160 --> 00:37:12,710
a big Atlas and then passing that data off
to you.

490
00:37:12,710 --> 00:37:15,380
Now what you are looking at on the screen
here is all of our assets are actually listed

491
00:37:15,380 --> 00:37:18,589
on the side over there. So the artist literally
grabbed them all and dragged them in the tool.

492
00:37:18,589 --> 00:37:21,869
What you see in the middle window is the result
of Texture Packer putting it all in.

493
00:37:21,869 --> 00:37:26,029
Now one of the real cool things that texture
packer does, is it will actually analyze the

494
00:37:26,029 --> 00:37:32,440
true boundaries of an image. Let's say that
you make a 64-by-64 texture, put like a 5-by-5

495
00:37:32,440 --> 00:37:36,470
little sprite right in the middle of it. Texture
Packer will actually analyze that image and

496
00:37:36,470 --> 00:37:42,359
realize that the true content bounds are actually
5-by-5 and it will actually crop it and only

497
00:37:42,359 --> 00:37:47,200
put the 5-by-5 image in the map. Then it will
spit out a JSON file with the original bounding

498
00:37:47,200 --> 00:37:52,269
values. So by using Texture Packer, you are
actually optimizing the number of pixels used

499
00:37:52,269 --> 00:37:57,559
by your artists. Sometimes artists don't make
the best optimized art work.

500
00:37:57,559 --> 00:38:01,720
[Laughter].
>>Colton McAnlis: Maybe. This is also really

501
00:38:01,720 --> 00:38:07,829
cool, too, actually we had to break up our
end game assets versus our start menu assets.

502
00:38:07,829 --> 00:38:11,960
That's why we actually have three Atlases,
right? This is actually all of our menu data.

503
00:38:11,960 --> 00:38:16,519
It's in a separate Atlas so that we can load
it to do all of our rendering in HTML or in

504
00:38:16,519 --> 00:38:19,940
the DOM, so all of our menu stuff is done
in the DOM, all of the game play is done on

505
00:38:19,940 --> 00:38:25,180
the canvas. So we can actually load this Atlas
ahead of time. Use CSS, use sprites, transition,

506
00:38:25,180 --> 00:38:29,750
I think you guys saw impress.js, moving the
menus around in there. And that's all loaded

507
00:38:29,750 --> 00:38:33,480
before you get into the game. So once we get
in the game, we can load the other two Atlases.

508
00:38:33,480 --> 00:38:38,619
So we reduce load time. Reduce pixel latency.
And really it's all given to us by these two

509
00:38:38,619 --> 00:38:44,779
simple tools.
So -- so the lessons, let's talk about what

510
00:38:44,779 --> 00:38:50,420
we actually learned in this process.
So first off, can you do player versus player

511
00:38:50,420 --> 00:38:53,009
in HTML5?
Absolutely. Someone say mission accomplished.

512
00:38:53,009 --> 00:38:57,140
I would plant a flag or hang a banner or something
like that, but they wouldn't let me put pyrotechnics

513
00:38:57,140 --> 00:39:01,430
on the stage. I did ask, after they turned
down the skydiving thing, I was like well

514
00:39:01,430 --> 00:39:04,029
what about pyrotechnics. It was like stop
talking. I was like, okay.

515
00:39:04,029 --> 00:39:08,079
Anyhow, you can actually do player versus
player in HTML5, it's a fantastic ability.

516
00:39:08,079 --> 00:39:12,450
We've got canvas rendering, we've got hardware
accelerated rendering, we've got WebSockets,

517
00:39:12,450 --> 00:39:16,029
we have the ability to manipulate the bytes
that are sent over the line, which is probably

518
00:39:16,029 --> 00:39:20,509
the most crucial thing in bandwidth reduction,
in latency optimization. Really it's there,

519
00:39:20,509 --> 00:39:27,509
we can do it. From a game developer perspective,
the HTML5 APIs were not built for games. HTML5

520
00:39:29,029 --> 00:39:33,829
was built for a Web to transfer data and do
rich content, but they weren't built for games.

521
00:39:33,829 --> 00:39:38,670
The good news is that they're starting to
change. As you probably already have seen,

522
00:39:38,670 --> 00:39:43,809
Chrome has been very proactive in adding APIs
for game development. We've added full-screen

523
00:39:43,809 --> 00:39:50,250
support. Mouse lock support. We've added game
pad support, which usually when you say why

524
00:39:50,250 --> 00:39:54,000
is Chrome putting in a game pad, am I going
to use a controller to navigate my FaceBook

525
00:39:54,000 --> 00:39:56,299
page?
No, this is because we are putting in games.

526
00:39:56,299 --> 00:40:01,160
We are being very proactive about understanding
the games more than any other technology pushed

527
00:40:01,160 --> 00:40:06,170
the boundaries, pushed the envelope, and trying
to be a -- a modern browser, Chrome is very

528
00:40:06,170 --> 00:40:11,799
aggressive about this.
For a player versus player game, bandwidth

529
00:40:11,799 --> 00:40:15,009
reduction is crucial. In fact it's the only
thing that you really need to worry about

530
00:40:15,009 --> 00:40:19,720
the world. Hiding the latency from the user,
reducing the number of bits on the line, this

531
00:40:19,720 --> 00:40:24,150
is a full-time job. Again, we only had 120
days. We had some really great results out

532
00:40:24,150 --> 00:40:28,740
of that, you should probably spend a lot more
time optimizing that system if you are putting

533
00:40:28,740 --> 00:40:32,720
out a commercial product that you're going
to use.

534
00:40:32,720 --> 00:40:37,819
Also, this sort of piggyback in it is that
the client side prediction algorithm, and

535
00:40:37,819 --> 00:40:42,549
I encourage you to go Google this, there's
tons of papers out there by tons of first

536
00:40:42,549 --> 00:40:47,230
person shooters and MMO RPGs and any of the
game developer conferences out there saying

537
00:40:47,230 --> 00:40:51,849
"Hey, we solved it this way". I highly recommend
that you take a look at the GRITS source code,

538
00:40:51,849 --> 00:40:55,670
see what we are doing, compare that against
what the industry is doing and figure out

539
00:40:55,670 --> 00:40:59,670
a proper technique to use for your game, right?
What we provide should be considered a boilerplate

540
00:40:59,670 --> 00:41:04,490
and starting base, then you need to move into
more advanced versions after that. WebSockets

541
00:41:04,490 --> 00:41:08,749
work really well. In fact I would say probably
we had no problems with WebSockets once we

542
00:41:08,749 --> 00:41:15,009
moved to socket I/O. We used it, sent packets,
received packets, it was fantastic and easy

543
00:41:15,009 --> 00:41:18,829
to use.
As I said before, canvas, we did all of our

544
00:41:18,829 --> 00:41:24,130
rendering in canvas. A hardware accelerated
canvas in Chrome is really fast and powerful.

545
00:41:24,130 --> 00:41:29,019
We didn't want to write a full WebGL version,
we didn't have time to worry about atlasing,

546
00:41:29,019 --> 00:41:34,029
or UV sets, and whether or not we were rendering
middle of polygon, versus edge of polygon,

547
00:41:34,029 --> 00:41:38,140
and what's the GPU doing and out of process
-- no. Hardware accelerated canvas shielded

548
00:41:38,140 --> 00:41:41,490
us from all of that information and gives
us the same performance, which is great. If

549
00:41:41,490 --> 00:41:47,569
you are writing a 2D game in Chrome, consider
canvas first, and then if you run into performance

550
00:41:47,569 --> 00:41:50,059
problems, optimize it until you absolutely
have to go over to GL for it.

551
00:41:50,059 --> 00:41:56,230
Now if you are doing 3D, you can't do canvas
in 3 d easily. Definitely take advantage of

552
00:41:56,230 --> 00:42:00,039
off DOM canvas to accelerate any large bitmap
stuff, right? If you have a lot of static

553
00:42:00,039 --> 00:42:03,480
data being rendered per frame, make sure that
you do that, but definitely make sure that

554
00:42:03,480 --> 00:42:06,480
you segment it because the artist will keep
generating content that's going to make it

555
00:42:06,480 --> 00:42:11,309
harder and harder for your frame rate to be
what you need it at. Again, use atlasing,

556
00:42:11,309 --> 00:42:17,130
right? Going from 270 milliseconds for the
load time to 4.6 seconds is crazy. Right?

557
00:42:17,130 --> 00:42:21,140
Especially if you are doing this stuff on
mobile, right? We are usually on mobile, if

558
00:42:21,140 --> 00:42:24,569
my site takes more than a second to load,
I have already thrown the phone across the

559
00:42:24,569 --> 00:42:26,609
room and started drinking heavily.
[Laughter]

560
00:42:26,609 --> 00:42:32,460
>>Colton McAnlis: That's my Saturday night.
Doesn't have to be your Saturday night. Utilizing

561
00:42:32,460 --> 00:42:37,220
the HTML5, utilizing the DOM to do all of
our UI was a huge win. Coming from traditional

562
00:42:37,220 --> 00:42:40,440
game development, we have a ton of packages
and middle ware out there that we spend a

563
00:42:40,440 --> 00:42:47,440
lot of time trying to bend C++ into the will
of our UI system. The fact that HTML5 comes

564
00:42:47,480 --> 00:42:52,660
with the DOM, the most advanced sophisticated
UI system in the world, Galaxy, I'm going

565
00:42:52,660 --> 00:42:56,869
to say Galaxy because I think that it's that
cool. That was a huge win. To ignore that

566
00:42:56,869 --> 00:43:01,509
or try to reproduce all of that stuff inside
of canvas, don't even try it, it's not even

567
00:43:01,509 --> 00:43:08,509
worth it. So the game is live right now. Actually
been live for two weeks. Game's live. Gritsgame.appspot.com.

568
00:43:08,720 --> 00:43:13,430
You can go play right now, hopefully the servers
are up, maybe they're not, I don't know, we'll

569
00:43:13,430 --> 00:43:20,430
find out soon. The code is live. Code.google.com/p/GRITSgame.
Go get the code. Start hacking on it. Please.

570
00:43:22,369 --> 00:43:25,890
We would love to hear what you're breaking
and how you're breaking it.

571
00:43:25,890 --> 00:43:30,309
We had a great question a couple weeks ago
from an internal Googler who said, "Hey, do

572
00:43:30,309 --> 00:43:37,309
you mind if we write an AI system that cheats?"
I said, "Please do and then send me the patch."

573
00:43:38,980 --> 00:43:45,059
More importantly, go to the Chrome Sandbox.
Check out a game called Strike Fortress. What

574
00:43:45,059 --> 00:43:49,190
I have done with GRITS, what our team has
done is a small subset of what you can do

575
00:43:49,190 --> 00:43:56,190
in 120 days. EA, electronic arts, has had
a team working on a pure 3D HTML5 game, working

576
00:43:57,490 --> 00:44:02,369
on it for a lot longer than we have, in the
Chrome Sandbox live right now that you can

577
00:44:02,369 --> 00:44:07,829
play. The coolest part is you can actually
go up and scan the QR code, start influencing

578
00:44:07,829 --> 00:44:12,150
the game with your phone. So while two people
are standing there actually playing, we are

579
00:44:12,150 --> 00:44:17,210
utilizing the full power of the Web by letting
other developers actually drop bombs on people

580
00:44:17,210 --> 00:44:21,289
on the phone.
It's a fantastic product. The guys have been

581
00:44:21,289 --> 00:44:25,789
doing an amazing job. Please, leave the session,
walk right over there and play it and tell

582
00:44:25,789 --> 00:44:30,279
them that I sent you because I get a T-shirt
every time you do. I run out of clothes really

583
00:44:30,279 --> 00:44:34,319
fast. It's happens.
So with that, hey, thank you all so much for

584
00:44:34,319 --> 00:44:38,339
attending this talk. I'm excited to see what
HTML5 is doing with gaming. I'm excited to

585
00:44:38,339 --> 00:44:41,490
see the room this packed. We've got people
sitting on the floor. Hi, I see you. T-shirt

586
00:44:41,490 --> 00:44:45,789
for those guys.
My name is Colt McAnlis. This is how you get

587
00:44:45,789 --> 00:44:50,549
ahold of me. Thank you so much for the talk.
We'll open it up for some questions now.

588
00:44:50,549 --> 00:44:57,549
[ Applause ]
>>Colton McAnlis: Please feel free to use

589
00:44:57,960 --> 00:45:01,509
the microphone. And before we do that, hey,
a big round of applause for the typy person.

590
00:45:01,509 --> 00:45:08,509
[ Applause ]
>>Colton McAnlis: Yes, you're awesome. You're

591
00:45:09,559 --> 00:45:12,410
awesome with the typing. I'm a huge fan.
Questions.

592
00:45:12,410 --> 00:45:17,680
>>> Yes. What do you see the overlap with
this and play-in? And also, how did you do

593
00:45:17,680 --> 00:45:22,579
the server side application? Did you use the
same JavaScript code to validate the state?

594
00:45:22,579 --> 00:45:26,029
>>Colton McAnlis: That's a great question.
A two-part question there, which you're cheating,

595
00:45:26,029 --> 00:45:29,049
you're only allowed one.
Two-part question there. How does this overlap

596
00:45:29,049 --> 00:45:33,509
with things like play-in and the second part
is how do we actually do our sharing or our

597
00:45:33,509 --> 00:45:38,180
computation of state on the server side.
The first one is play-in is a fantastic tool

598
00:45:38,180 --> 00:45:43,730
framework that works more with Java to my
understanding of it to produce a sort of nice

599
00:45:43,730 --> 00:45:48,390
games middleware setup.
GRITS is not considered an engine and should

600
00:45:48,390 --> 00:45:54,019
not be used in that vocabulary. GRITS is boilerplate
code. This is a setup and a bunch of things

601
00:45:54,019 --> 00:45:58,190
that are not intended for you to use as an
entirety, but a bunch of little small capsules

602
00:45:58,190 --> 00:46:01,839
that you can consume individually and then
take the knowledge from that and build off

603
00:46:01,839 --> 00:46:04,829
of it. We're by no means creating a larger
ecosystem here. We're just trying to give

604
00:46:04,829 --> 00:46:09,970
you guys sort of pebbles to feed the empire.
The second question was how we're actually

605
00:46:09,970 --> 00:46:15,579
splitting our code client server. We have
two metrics for that. First off, we have an

606
00:46:15,579 --> 00:46:20,049
is server variable that is only defined on
the server side through NodeJS. So in our

607
00:46:20,049 --> 00:46:24,019
shared code that's actually included in the
client's as well, we can actually say if it's

608
00:46:24,019 --> 00:46:29,049
a server run this loop or run this set of
code. If it's not the server, exclude it.

609
00:46:29,049 --> 00:46:35,499
Now, for some side classes we actually have
-- for instance, if you want to load graphics

610
00:46:35,499 --> 00:46:39,339
or do drawing, it doesn't make sense to have
any of that code sitting on the server side.

611
00:46:39,339 --> 00:46:42,829
So in those situations we actually split the
code. We actually have a server folder and

612
00:46:42,829 --> 00:46:47,619
a client folder, and those are actually separate
modules that use object-oriented programming

613
00:46:47,619 --> 00:46:52,480
to inherit from the server side classes.
So fantastic question. For a lot more of that

614
00:46:52,480 --> 00:46:55,970
I really encourage you to dig deep in the
source code. Check it out.

615
00:46:55,970 --> 00:46:59,690
I believe you're next, sir.
>>> Quick one about the source code. Has it

616
00:46:59,690 --> 00:47:04,029
been tested across different browser as well
or has it been optimized for Chrome? And are

617
00:47:04,029 --> 00:47:09,279
the assets as far as peer posture as well,
like the tile tools and the original graphics?

618
00:47:09,279 --> 00:47:12,920
>>Colton McAnlis: Absolutely. So the questions
were have we tested the source code across

619
00:47:12,920 --> 00:47:17,200
multiple browsers and are the assets available
in the source code? We haven't had a time

620
00:47:17,200 --> 00:47:22,049
to actually test the code in other browsers.
Right now I just kind of hack out and say

621
00:47:22,049 --> 00:47:25,970
sorry, this is optimized for Chrome. I can't
fix the other issues.

622
00:47:25,970 --> 00:47:30,619
The good news is that the assets for the game
in their atlased form are provided in the

623
00:47:30,619 --> 00:47:35,499
source code under the license we provide.
We don't provide the PSD's or the originals

624
00:47:35,499 --> 00:47:39,809
because of some weird thing, but it's all
there. And we provide the JSON files, too.

625
00:47:39,809 --> 00:47:43,390
So you can actually scrape the JSON, scrape
the alias and generate all the loose asset

626
00:47:43,390 --> 00:47:46,349
if you would like that.
Thank you. You were next, sir.

627
00:47:46,349 --> 00:47:49,410
>>> Yeah, two questions.
>>Colton McAnlis: All you guys are cheating.

628
00:47:49,410 --> 00:47:53,960
You're only supposed to have one.
>>> Not a real question. Why is it called

629
00:47:53,960 --> 00:47:58,710
GRITS? And then how did you do any kind of
like automated testing for your game?

630
00:47:58,710 --> 00:48:03,869
>>Colton McAnlis: Okay. Why is it called GRITS?
I'm a fan of grits, that's all there is to

631
00:48:03,869 --> 00:48:06,089
it.
There's only -- let me put it this way, as

632
00:48:06,089 --> 00:48:10,999
a Google employee you see a lot of projects
come through with secret code names and stuff

633
00:48:10,999 --> 00:48:15,119
like that. And when you have a chance to name
one you kind of pick something kooky so someone

634
00:48:15,119 --> 00:48:19,499
else didn't already steal it. Like you would
hate to have named your project Glass and

635
00:48:19,499 --> 00:48:24,430
then have a dude skydive in and say "Here's
some Glass!"

636
00:48:24,430 --> 00:48:29,239
So GRITS just kind of showed up one day. It's
not an acronym or anything.

637
00:48:29,239 --> 00:48:34,059
And the second question was automated testing.
We had some basic stuff to sort test load

638
00:48:34,059 --> 00:48:39,650
balancing for App Engine, which Fred will
talk about in his talk a little later. How

639
00:48:39,650 --> 00:48:44,690
to properly scale that sort of things forward.
We didn't do any testing on the client side

640
00:48:44,690 --> 00:48:49,400
code and we didn't have a lot of time in our
window to test the server side code.

641
00:48:49,400 --> 00:48:53,140
So other than sort of mandatory play test
for all six of our team members everyday,

642
00:48:53,140 --> 00:48:55,950
we didn't get a chance to get much of a big
harness put together. That's kind of our fault

643
00:48:55,950 --> 00:48:58,369
on our thing that we definitely would like
to see fixed.

644
00:48:58,369 --> 00:49:02,890
We're over here now.
>>> Hi. You talked about some prototype language

645
00:49:02,890 --> 00:49:06,759
that allowed you to create both the client
and server side JavaScript, and I was wondering

646
00:49:06,759 --> 00:49:11,559
if you could speak more about that or where
I can find out more information about that?

647
00:49:11,559 --> 00:49:16,660
>>Colton McAnlis: Uh, okay. Yeah, so the question
was prototype languages that allow you to

648
00:49:16,660 --> 00:49:19,819
generate both client and severer. Oh, so you're
talking about the code generation that we

649
00:49:19,819 --> 00:49:25,069
do? Yes. So look at our source code. That's
actually the place. It's not actually a prototype

650
00:49:25,069 --> 00:49:29,470
language. We actually define a structure in
JavaScript and then use JavaScript to scrape

651
00:49:29,470 --> 00:49:34,589
that JavaScript and then omit JavaScript.
So we use JavaScript to code gen and then

652
00:49:34,589 --> 00:49:37,690
move that file around.
>>> So it's not a third-party library?

653
00:49:37,690 --> 00:49:40,900
>>Colton McAnlis: Nope. It's all in our code
base. In fact, the file you're looking for

654
00:49:40,900 --> 00:49:47,109
in the source code is server/proto.js, the
exact file. You will find our definition and

655
00:49:47,109 --> 00:49:52,119
then proto i is I think the one that actually
does the scraping of the code generation after

656
00:49:52,119 --> 00:49:53,799
that.
Over here.

657
00:49:53,799 --> 00:49:59,970
>>> So since Web socket is TCP only, did you
guys have any kind of evaluation of TCP versus

658
00:49:59,970 --> 00:50:05,849
UDP and like how that behaves when you have
real network conditions and packet loss and

659
00:50:05,849 --> 00:50:09,730
things like that?
>>Colton McAnlis: The question is did we get

660
00:50:09,730 --> 00:50:14,249
a chance to evaluate TCP versus UDP versus
packet loss in real network conditions and

661
00:50:14,249 --> 00:50:17,380
stuff like that?
I would love to have somebody do that testing

662
00:50:17,380 --> 00:50:19,529
for us and let us know where it's falling
out.

663
00:50:19,529 --> 00:50:23,549
UDP wasn't really an option that we're able
to dive into a lot. We have Web sockets that

664
00:50:23,549 --> 00:50:27,079
are available. There's very rich containers
and wrappers for that.

665
00:50:27,079 --> 00:50:30,809
So again, in standard C++ development you
run into a brick wall of like, Hey, there's

666
00:50:30,809 --> 00:50:34,109
really no good library for UDP. You have to
reinvent the wheel every time.

667
00:50:34,109 --> 00:50:39,900
The fact that the JavaScript developer ecosystem
is very vibrant with people putting out open

668
00:50:39,900 --> 00:50:44,579
source libraries, it didn't make sense for
us to just reinvent the wheel there. It made

669
00:50:44,579 --> 00:50:47,480
more sense to use things like Socket I/O and
take advantage of that stuff.

670
00:50:47,480 --> 00:50:51,660
I will say that the guy who wrote all of our
networking code, Craig Tiller, absolutely

671
00:50:51,660 --> 00:50:56,099
genius. He's from the games industry where
all he's done for his entire career is optimize

672
00:50:56,099 --> 00:51:00,980
server side code and bandwidth and latency
hiding and everything. Definitely contact

673
00:51:00,980 --> 00:51:06,480
him. He's that first portrait right there.
Very beautiful man. Contact him. Craig, if

674
00:51:06,480 --> 00:51:08,720
you're watching...
Yes, sir?

675
00:51:08,720 --> 00:51:14,279
>>> So how did you host your NodeJS?
>>Colton McAnlis: Next question.

676
00:51:14,279 --> 00:51:20,799
[Laughter]
>>Colton McAnlis: I like that. That was nice.

677
00:51:20,799 --> 00:51:26,130
Going once... going twice... The live internet
feed, everyone is like refresh.

678
00:51:26,130 --> 00:51:28,809
[Laughter]
>>Colton McAnlis: Hey, thank you guys so much

679
00:51:28,809 --> 00:51:33,720
again for your time. I really appreciate it.
Go check out the EA game. I'm Colt McAnlis.

680
00:51:33,720 --> 00:51:34,970
Send me an email.

