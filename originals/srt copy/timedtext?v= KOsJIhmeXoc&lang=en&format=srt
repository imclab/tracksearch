1
00:00:00,000 --> 00:00:00,090

2
00:00:00,090 --> 00:00:01,030
NICK BRAY: Hello.

3
00:00:01,030 --> 00:00:02,300
My name is Nick Bray.

4
00:00:02,300 --> 00:00:03,470
I'm a software engineer.

5
00:00:03,470 --> 00:00:05,930
And I'm working on
Native Client.

6
00:00:05,930 --> 00:00:07,460
This is, unfortunately,
where dinner parties

7
00:00:07,460 --> 00:00:08,810
get a little awkward.

8
00:00:08,810 --> 00:00:10,440
So Nick, what's Native Client?

9
00:00:10,440 --> 00:00:13,680

10
00:00:13,680 --> 00:00:14,880
It's a developer thing.

11
00:00:14,880 --> 00:00:16,170
It's part of Chrome.

12
00:00:16,170 --> 00:00:17,420
I work on Chrome.

13
00:00:17,420 --> 00:00:19,830

14
00:00:19,830 --> 00:00:21,620
That's usually a fairly
soul-crushing thing.

15
00:00:21,620 --> 00:00:24,640
But fortunately, this isn't
a dinner party.

16
00:00:24,640 --> 00:00:27,050
And we can talk about
interesting things.

17
00:00:27,050 --> 00:00:29,910
So when I say "interesting,"
what I mean is--

18
00:00:29,910 --> 00:00:31,850
you get to drink from
the fire hose.

19
00:00:31,850 --> 00:00:33,720
So we're going to be discussing
address space.

20
00:00:33,720 --> 00:00:35,700
We're going to be discussing
instructions, assembly

21
00:00:35,700 --> 00:00:37,110
language, that kind of thing.

22
00:00:37,110 --> 00:00:40,290
I will try to make sure everyone
can follow along,

23
00:00:40,290 --> 00:00:43,450
even if you don't have a huge
amount of background in this.

24
00:00:43,450 --> 00:00:45,270
But we're going to get into
the nitty gritty technical

25
00:00:45,270 --> 00:00:48,950
details of how Native
Client works.

26
00:00:48,950 --> 00:00:52,170
Before we do this, of course,
the only kind thing to do is

27
00:00:52,170 --> 00:00:55,330
give a bit of an overview and
say how this fits in, why

28
00:00:55,330 --> 00:00:57,400
we're doing it, what's
important here.

29
00:00:57,400 --> 00:01:00,700
So one big thing we keep saying
is that Native Client

30
00:01:00,700 --> 00:01:03,330
allows native code to be safe
and secure as JavaScript.

31
00:01:03,330 --> 00:01:07,800
And this is a very compressed
tag line, which unless you

32
00:01:07,800 --> 00:01:10,690
actually know what's going on
behind the scenes, you aren't

33
00:01:10,690 --> 00:01:12,050
quite sure what that means.

34
00:01:12,050 --> 00:01:14,020
So one picture is worth
a thousand words.

35
00:01:14,020 --> 00:01:15,930
And this is a picture, which
you probably are familiar

36
00:01:15,930 --> 00:01:18,710
with, is whenever you try to run
a piece of native code on

37
00:01:18,710 --> 00:01:21,240
a computer, you get a
scary dialog box, or

38
00:01:21,240 --> 00:01:22,000
run from the web.

39
00:01:22,000 --> 00:01:25,590
So say someone tries to install
an NPAPI plug-in on

40
00:01:25,590 --> 00:01:29,000
your computer or even download
an EXE from the Internet, then

41
00:01:29,000 --> 00:01:31,820
try to run it, well, the
operating system is typically

42
00:01:31,820 --> 00:01:34,350
skeptical of any binary which
is coming from the network.

43
00:01:34,350 --> 00:01:36,540
And says, hey wait, you probably
shouldn't do this,

44
00:01:36,540 --> 00:01:38,170
but what do I know?

45
00:01:38,170 --> 00:01:40,040
You can do it anyways.

46
00:01:40,040 --> 00:01:43,240
So the problem with this is that
most users really cannot

47
00:01:43,240 --> 00:01:46,640
evaluate whether they should
click Run or not.

48
00:01:46,640 --> 00:01:50,130
And you sometimes lose 60 to
90% of your users when they

49
00:01:50,130 --> 00:01:51,730
get this dialog box.

50
00:01:51,730 --> 00:01:54,330
And even if they do hit Run,
then suddenly a lot of

51
00:01:54,330 --> 00:01:55,530
burden is on you.

52
00:01:55,530 --> 00:01:57,750
The burden becomes on you as
the developer to make sure

53
00:01:57,750 --> 00:02:00,650
that this piece of native code
you installed on your customer

54
00:02:00,650 --> 00:02:03,780
system is actually safe and
secure and doesn't become an

55
00:02:03,780 --> 00:02:06,290
attack vector where someone
exploits your customers

56
00:02:06,290 --> 00:02:07,710
because you made a mistake.

57
00:02:07,710 --> 00:02:12,090
So native code, understandably,
is very scary,

58
00:02:12,090 --> 00:02:14,400
especially when you get
these dialog boxes.

59
00:02:14,400 --> 00:02:17,290
So does the story end there,
Native Client?

60
00:02:17,290 --> 00:02:19,070
Should we be doing this?

61
00:02:19,070 --> 00:02:22,410
As it turns out, it isn't native
code itself which is

62
00:02:22,410 --> 00:02:23,000
the problem.

63
00:02:23,000 --> 00:02:24,810
It's the fact that my
presentation has not been

64
00:02:24,810 --> 00:02:27,360
refreshed, and the bullet
points aren't fading in.

65
00:02:27,360 --> 00:02:28,610
Hold on a second.

66
00:02:28,610 --> 00:02:37,811

67
00:02:37,811 --> 00:02:39,550
OK, back in business.

68
00:02:39,550 --> 00:02:42,280
So the problem is that the
operating system has a very

69
00:02:42,280 --> 00:02:46,220
different notion of security
than the web does.

70
00:02:46,220 --> 00:02:49,520
So say I'm browsing a website
to watch videos of cats,

71
00:02:49,520 --> 00:02:51,870
because that's what we all do,
we just don't admit it.

72
00:02:51,870 --> 00:02:56,300
And then suddenly I notice my
tax return being uploaded to a

73
00:02:56,300 --> 00:02:58,080
Russian website.

74
00:02:58,080 --> 00:03:00,530
So this right here
is a Windows API

75
00:03:00,530 --> 00:03:03,000
call to open a file.

76
00:03:03,000 --> 00:03:06,030
So really, this Russian website
does not need my tax

77
00:03:06,030 --> 00:03:08,580
return in order for me to
watch videos of cats.

78
00:03:08,580 --> 00:03:10,730
So there's something seriously
wrong here.

79
00:03:10,730 --> 00:03:13,800
But as it turns out, operating
systems are secure.

80
00:03:13,800 --> 00:03:15,760
They just think that any
program running on your

81
00:03:15,760 --> 00:03:18,750
computer is acting
on your behalf.

82
00:03:18,750 --> 00:03:21,610
So because you can open your
own spreadsheet, it assumes

83
00:03:21,610 --> 00:03:25,270
that any native program should
have access to it.

84
00:03:25,270 --> 00:03:27,580
The web figured out this is
probably not the way things

85
00:03:27,580 --> 00:03:30,170
should run when you're loading
other people's programs.

86
00:03:30,170 --> 00:03:33,260
So instead they say that the
program is operating on behalf

87
00:03:33,260 --> 00:03:34,570
of the website.

88
00:03:34,570 --> 00:03:36,880
And it should only do things
which you authorize the

89
00:03:36,880 --> 00:03:39,320
website to do.

90
00:03:39,320 --> 00:03:41,480
What this means, of course, is
that if you load native code

91
00:03:41,480 --> 00:03:43,530
and it can talk to the operating
system, it can just

92
00:03:43,530 --> 00:03:45,340
blow right past the browser.

93
00:03:45,340 --> 00:03:47,600
And that is the fundamental
problem with native code, is

94
00:03:47,600 --> 00:03:51,490
it can do things that your web
browser says is unsafe.

95
00:03:51,490 --> 00:03:53,530
Another problem, which isn't
immediately apparent, is this

96
00:03:53,530 --> 00:03:56,630
is a Windows API call
to open a file.

97
00:03:56,630 --> 00:03:59,480
And imagine if you were, say,
writing a nice application to

98
00:03:59,480 --> 00:04:02,780
view cat videos, which also
happens to upload files.

99
00:04:02,780 --> 00:04:05,880
Well, suddenly you have a cross-
platform support issue.

100
00:04:05,880 --> 00:04:08,290
You can open the files on
Windows, but are you going to

101
00:04:08,290 --> 00:04:09,180
support Mac builds?

102
00:04:09,180 --> 00:04:10,720
Are you going to support
Linux builds?

103
00:04:10,720 --> 00:04:12,790
I mean, honestly, when you're
writing malware, it becomes a

104
00:04:12,790 --> 00:04:14,150
huge problem.

105
00:04:14,150 --> 00:04:15,810
Of course, there's some
honest developers who

106
00:04:15,810 --> 00:04:16,769
have the same problem.

107
00:04:16,769 --> 00:04:19,220
And that's, when I distribute
native code, how do I make

108
00:04:19,220 --> 00:04:21,290
sure it actually
runs on all the

109
00:04:21,290 --> 00:04:23,540
operating systems out there?

110
00:04:23,540 --> 00:04:25,920
Another thing, again, which
isn't immediately obvious, is

111
00:04:25,920 --> 00:04:27,440
this is a synchronous call.

112
00:04:27,440 --> 00:04:30,100
A lot of operating system APIs
were designed back in the days

113
00:04:30,100 --> 00:04:32,230
where synchronous blocking
of things

114
00:04:32,230 --> 00:04:33,640
seemed like a good idea.

115
00:04:33,640 --> 00:04:36,740
But with the advent of browsers
and JavaScript, a

116
00:04:36,740 --> 00:04:39,570
decision was made to eliminate
the use of threads for the

117
00:04:39,570 --> 00:04:42,450
most part within a single
JavaScript environment, a

118
00:04:42,450 --> 00:04:43,620
single document.

119
00:04:43,620 --> 00:04:45,440
And instead, everything was
single-threaded with

120
00:04:45,440 --> 00:04:46,860
asynchronous callbacks.

121
00:04:46,860 --> 00:04:49,710
So APIs have had to change in
order to support the web.

122
00:04:49,710 --> 00:04:52,320
Whenever you open a file on the
web, you, in fact, give it

123
00:04:52,320 --> 00:04:54,100
a callback to call you back.

124
00:04:54,100 --> 00:04:59,020
So, the big crux of Native
Client is making you talk to

125
00:04:59,020 --> 00:05:01,930
the web browser instead of
talking to the operating

126
00:05:01,930 --> 00:05:05,260
system, and in fact making it
impossible to talk to the

127
00:05:05,260 --> 00:05:06,510
operating system.

128
00:05:06,510 --> 00:05:08,560

129
00:05:08,560 --> 00:05:11,170
So this is an example of what
a native program talking to

130
00:05:11,170 --> 00:05:12,350
the web browser would
look like.

131
00:05:12,350 --> 00:05:14,690
It's a little ugly, but
it's from real code.

132
00:05:14,690 --> 00:05:16,370
And well, real code is ugly.

133
00:05:16,370 --> 00:05:20,180
So this is an example of doing
a URL request to get the page

134
00:05:20,180 --> 00:05:22,660
www.google.com.

135
00:05:22,660 --> 00:05:25,070
It's analogous to what we were
seeing with opening a file.

136
00:05:25,070 --> 00:05:27,030
But it's a different
API, and it's

137
00:05:27,030 --> 00:05:29,120
routed through the browser.

138
00:05:29,120 --> 00:05:33,070
So Native Client provides a
bunch of APIs for I/O that are

139
00:05:33,070 --> 00:05:35,300
mediated through the browser
through an API called the

140
00:05:35,300 --> 00:05:36,950
Pepper Plugin API.

141
00:05:36,950 --> 00:05:39,530
The Pepper Plugin API you can
think of as a successor to the

142
00:05:39,530 --> 00:05:41,990
Netscape Plugin API, where
things we've learned in the

143
00:05:41,990 --> 00:05:45,170
meantime, such as 3D graphics
are good, have been

144
00:05:45,170 --> 00:05:45,910
incorporated.

145
00:05:45,910 --> 00:05:48,950
And instead of just drawing to
a random window, you can now

146
00:05:48,950 --> 00:05:51,420
delegate to the browser and say
here's some 3D content,

147
00:05:51,420 --> 00:05:52,610
just like WebGL.

148
00:05:52,610 --> 00:05:55,120
So ultimately, the Pepper Plugin
API gives you a lot of

149
00:05:55,120 --> 00:05:57,680
functionality similar
to JavaScript.

150
00:05:57,680 --> 00:06:01,190
As you can think, all the APIs
that JavaScript has to open

151
00:06:01,190 --> 00:06:04,940
URLs, to draw 3D content, it's
also exposed to native code

152
00:06:04,940 --> 00:06:06,190
through Pepper.

153
00:06:06,190 --> 00:06:08,080

154
00:06:08,080 --> 00:06:10,910
Not everything is I/O. So if you
want to spin up a thread

155
00:06:10,910 --> 00:06:13,030
or do things like that, that
actually occurs within a

156
00:06:13,030 --> 00:06:13,830
single process.

157
00:06:13,830 --> 00:06:15,100
You don't need to talk
to the browser,

158
00:06:15,100 --> 00:06:16,450
don't need it's approval.

159
00:06:16,450 --> 00:06:18,860
And for that, we've used
the POSIX API.

160
00:06:18,860 --> 00:06:21,750
So you can spawn threads
and do similar things.

161
00:06:21,750 --> 00:06:25,650
So if your code's running on
Linux, you can port the I/O to

162
00:06:25,650 --> 00:06:26,760
use Pepper.

163
00:06:26,760 --> 00:06:29,330
And more or less, everything
else should look

164
00:06:29,330 --> 00:06:31,570
relatively the same.

165
00:06:31,570 --> 00:06:33,810
And why are we doing this?

166
00:06:33,810 --> 00:06:36,030
The ultimate goal is no
scary dialog box.

167
00:06:36,030 --> 00:06:37,580
You can just run the code.

168
00:06:37,580 --> 00:06:39,680
It follows the web safety rules,
so you don't have to

169
00:06:39,680 --> 00:06:40,660
warn the user.

170
00:06:40,660 --> 00:06:41,940
It's part a seamless
experience.

171
00:06:41,940 --> 00:06:45,010
And in fact, most users won't
know the running NaCl.

172
00:06:45,010 --> 00:06:48,150
We have a lot of games in the
web store now, which we aren't

173
00:06:48,150 --> 00:06:48,950
trumpeting NaCl.

174
00:06:48,950 --> 00:06:50,970
It's just you can run bastion
on your computer now.

175
00:06:50,970 --> 00:06:53,710

176
00:06:53,710 --> 00:06:56,670
So the life cycle of a Native
Client application has three

177
00:06:56,670 --> 00:06:57,710
distinct stages.

178
00:06:57,710 --> 00:06:59,040
The first stage is what
the developer

179
00:06:59,040 --> 00:07:00,230
does on their computer.

180
00:07:00,230 --> 00:07:04,000
So you can get a bunch of
sources, existing library.

181
00:07:04,000 --> 00:07:06,170
Or say you've written a game,
and you want to port the game,

182
00:07:06,170 --> 00:07:07,660
run it on the web.

183
00:07:07,660 --> 00:07:10,590
You do supporting work on your
C files, and then you use a

184
00:07:10,590 --> 00:07:13,850
modified version of GCC,
which we provide.

185
00:07:13,850 --> 00:07:15,130
There's one wrinkle on this.

186
00:07:15,130 --> 00:07:18,060
And that's that you need to
use a version of GCC that

187
00:07:18,060 --> 00:07:20,870
targets binaries for different
platforms--

188
00:07:20,870 --> 00:07:22,930
or different architectures,
I should say, chip

189
00:07:22,930 --> 00:07:23,820
architectures.

190
00:07:23,820 --> 00:07:26,810
So the binaries that are
produced are OS independent,

191
00:07:26,810 --> 00:07:31,710
but for the moment, they have a
architecture, an instruction

192
00:07:31,710 --> 00:07:33,730
architecture set dependency.

193
00:07:33,730 --> 00:07:38,130
So for this talk, I'm going to
show you the internals for the

194
00:07:38,130 --> 00:07:40,670
x86-64 sandboxing model.

195
00:07:40,670 --> 00:07:43,890
And you can think that the
x86-32 and the ARM sandboxing

196
00:07:43,890 --> 00:07:46,230
models are quite similar.

197
00:07:46,230 --> 00:07:50,670
The details differ, but
spiritually they're the same.

198
00:07:50,670 --> 00:07:52,130
At the end of the year,
we're going to have a

199
00:07:52,130 --> 00:07:54,590
product called PNaCl.

200
00:07:54,590 --> 00:07:56,020
I should've defined this
a little earlier.

201
00:07:56,020 --> 00:07:59,530
When I say NaCl, I mean
Native Client.

202
00:07:59,530 --> 00:08:02,650
And I've just use this term so
much, I use it automatically.

203
00:08:02,650 --> 00:08:05,430
So I need to make very sure
that everyone knows I mean

204
00:08:05,430 --> 00:08:06,220
Native Client.

205
00:08:06,220 --> 00:08:09,540
So PNaCl, Portable Native,
Client, P-NaCl, is going to

206
00:08:09,540 --> 00:08:12,510
use an LLVM-based tool chain,
which will allow you to ship

207
00:08:12,510 --> 00:08:15,560
bit code, platform independent
bit code, across the wire.

208
00:08:15,560 --> 00:08:17,740
And that'll get translated to
whatever architecture you want

209
00:08:17,740 --> 00:08:18,940
to use on the computer.

210
00:08:18,940 --> 00:08:21,860
So that'll be roughly
the end of the year.

211
00:08:21,860 --> 00:08:26,060
And at the bottom level, what
we're going to talk about

212
00:08:26,060 --> 00:08:27,260
today remains the same.

213
00:08:27,260 --> 00:08:29,800
So the interchange format will
change, but the sandboxing

214
00:08:29,800 --> 00:08:32,580
model, the inner mechanics,
is going to stay the same.

215
00:08:32,580 --> 00:08:36,840
So this modified version of GCC
outputs code which we can

216
00:08:36,840 --> 00:08:38,640
later statically analyze.

217
00:08:38,640 --> 00:08:39,919
And we'll get into
what this is.

218
00:08:39,919 --> 00:08:42,150
We call it validation.

219
00:08:42,150 --> 00:08:44,450
Once you compile this code, you
upload it to a web server,

220
00:08:44,450 --> 00:08:45,490
just like a normal web app.

221
00:08:45,490 --> 00:08:47,640
In fact, it looks a lot
like a normal web app.

222
00:08:47,640 --> 00:08:48,710
You have an HTML file.

223
00:08:48,710 --> 00:08:49,780
You can have JavaScript.

224
00:08:49,780 --> 00:08:51,390
You can have CSS.

225
00:08:51,390 --> 00:08:53,810
And then within that app, you
have an embed tag somewhere.

226
00:08:53,810 --> 00:08:56,970
And the embed tag pulls in the
Native Client executable, and

227
00:08:56,970 --> 00:08:58,360
it can talk with the rest
of the web page.

228
00:08:58,360 --> 00:09:03,970
So you can make a UI
with HTML elements.

229
00:09:03,970 --> 00:09:06,890
And finally, at the end,
there is the user.

230
00:09:06,890 --> 00:09:08,940
The user is running a browser
on the computer.

231
00:09:08,940 --> 00:09:12,490
The browser loads the page,
loads the embed tag, pulls in

232
00:09:12,490 --> 00:09:15,040
the Native Client executable.

233
00:09:15,040 --> 00:09:16,200
So the question to
ask at this point

234
00:09:16,200 --> 00:09:18,020
is, where's the security?

235
00:09:18,020 --> 00:09:21,360
Ultimately, the user wants to
say that this application I'm

236
00:09:21,360 --> 00:09:24,230
running on the network isn't
going to harm my computer.

237
00:09:24,230 --> 00:09:26,230
So how are we are able to
make that assertion?

238
00:09:26,230 --> 00:09:29,810
We actually can't say that
about the compiler.

239
00:09:29,810 --> 00:09:32,530
So the compiler tries to output
code, which we can

240
00:09:32,530 --> 00:09:34,120
verify as safe.

241
00:09:34,120 --> 00:09:37,550
But we don't trust it, because
at the end of the day who

242
00:09:37,550 --> 00:09:38,990
knows what the developer's
intending.

243
00:09:38,990 --> 00:09:41,105
They could just have an
arbitrary binary blob that

244
00:09:41,105 --> 00:09:42,870
they put together with
the hex editor.

245
00:09:42,870 --> 00:09:45,720
And when the user gets it, they
have to look at it and

246
00:09:45,720 --> 00:09:47,770
verify it's safe before
they run it.

247
00:09:47,770 --> 00:09:50,380
And similarly, even if
it isn't malicious,

248
00:09:50,380 --> 00:09:52,300
compilers have bugs.

249
00:09:52,300 --> 00:09:55,560
So GCC, LLVM, very complex
pieces of software.

250
00:09:55,560 --> 00:09:59,000
They were not written with
safety in mind to begin with.

251
00:09:59,000 --> 00:10:01,220
So saying that these compilers
are going to produce perfect

252
00:10:01,220 --> 00:10:03,520
code, that's a bad assumption
to make.

253
00:10:03,520 --> 00:10:06,590
Instead, on the web browser, we
look at the code before we

254
00:10:06,590 --> 00:10:09,410
run it and apply some simple
rules to try to verify it's

255
00:10:09,410 --> 00:10:12,000
safe rather than saying this
big complicated piece of

256
00:10:12,000 --> 00:10:14,000
software is where
the safety is.

257
00:10:14,000 --> 00:10:16,760

258
00:10:16,760 --> 00:10:21,010
When Native Client actually runs
an EXE, the process model

259
00:10:21,010 --> 00:10:22,330
looks a little bit like this.

260
00:10:22,330 --> 00:10:25,740
So what you think of as the web
browser, what you see is

261
00:10:25,740 --> 00:10:27,020
called the browser process.

262
00:10:27,020 --> 00:10:29,500
And that's just a normal
application running on your

263
00:10:29,500 --> 00:10:31,230
computer, talking with the OS.

264
00:10:31,230 --> 00:10:35,860
But every time Chrome visits a
new domain, it usually splits

265
00:10:35,860 --> 00:10:38,840
it off into its own process
and says there is a render

266
00:10:38,840 --> 00:10:42,460
process for the specific site,
which can do all the

267
00:10:42,460 --> 00:10:45,100
JavaScript execution, all the
rendering of the DOM.

268
00:10:45,100 --> 00:10:47,100
And we're going to try to
keep sites separate.

269
00:10:47,100 --> 00:10:50,690
So if one site is compromised,
it rattles around in its own

270
00:10:50,690 --> 00:10:54,300
process and has a much harder
time attacking another site,

271
00:10:54,300 --> 00:10:56,790
stealing your credentials from
your banking system,

272
00:10:56,790 --> 00:10:57,860
or things like that.

273
00:10:57,860 --> 00:11:00,050
So these renderer processes run
in something called the

274
00:11:00,050 --> 00:11:01,730
Chrome Sandbox.

275
00:11:01,730 --> 00:11:04,800
The Chrome Sandbox, you can
think of it as deprivileging

276
00:11:04,800 --> 00:11:06,050
the processes.

277
00:11:06,050 --> 00:11:09,480
It says, hey, if these processes
ask for your tax

278
00:11:09,480 --> 00:11:12,300
return, that's probably
a bad idea.

279
00:11:12,300 --> 00:11:15,470
So don't trust them, don't
give it to them.

280
00:11:15,470 --> 00:11:17,120
So you'd think that this
solves most of the

281
00:11:17,120 --> 00:11:18,730
problems for NaCl.

282
00:11:18,730 --> 00:11:21,910
But as it turns out, we're
following a pattern called

283
00:11:21,910 --> 00:11:23,440
defense in depth.

284
00:11:23,440 --> 00:11:26,910
We try to build layers, each of
which is secure on its own.

285
00:11:26,910 --> 00:11:29,410
And if one of those layers
fails, the other should catch

286
00:11:29,410 --> 00:11:30,920
the problem.

287
00:11:30,920 --> 00:11:32,600
And there's actually some
subtle problems with the

288
00:11:32,600 --> 00:11:34,770
sandbox I'm not going
to get fully into.

289
00:11:34,770 --> 00:11:38,180
But Native Client tries to
provide an inner sandbox

290
00:11:38,180 --> 00:11:39,800
inside its own process.

291
00:11:39,800 --> 00:11:42,460
So when you have an embed tag
in the web page, instead of

292
00:11:42,460 --> 00:11:44,450
running the Native Client
executable inside the render

293
00:11:44,450 --> 00:11:47,510
process, it spins up yet another
process, and then

294
00:11:47,510 --> 00:11:50,820
applies the inner sandbox to
make sure it never can--

295
00:11:50,820 --> 00:11:54,690
or we try to make sure it can
never do anything bad.

296
00:11:54,690 --> 00:11:57,270
So for the rest of this
presentation, I'm going to be

297
00:11:57,270 --> 00:11:58,740
talking about the
inner sandbox.

298
00:11:58,740 --> 00:12:00,280
I'm going to be talking
about what

299
00:12:00,280 --> 00:12:02,350
happens in the NaCl process.

300
00:12:02,350 --> 00:12:06,400
Now, there's a lot of little
pieces that build up in order

301
00:12:06,400 --> 00:12:09,950
for us to verify that the
process isn't talking with the

302
00:12:09,950 --> 00:12:12,150
operating system, or more
correctly, the code that's

303
00:12:12,150 --> 00:12:15,250
loaded across the network is not
talking directly with the

304
00:12:15,250 --> 00:12:16,230
operating system.

305
00:12:16,230 --> 00:12:19,470
And we can do very controlled
calls to provide services that

306
00:12:19,470 --> 00:12:22,430
are needed.

307
00:12:22,430 --> 00:12:25,180
So the first step in this
journey is being able to

308
00:12:25,180 --> 00:12:28,050
understand what code we have.

309
00:12:28,050 --> 00:12:29,240
So you'd think this is easy.

310
00:12:29,240 --> 00:12:30,550
You've done assembly language.

311
00:12:30,550 --> 00:12:32,030
You see a lot of instructions.

312
00:12:32,030 --> 00:12:34,900
And we just look at the
instructions and say, bad

313
00:12:34,900 --> 00:12:35,430
instruction.

314
00:12:35,430 --> 00:12:37,070
We're not running it.

315
00:12:37,070 --> 00:12:38,400
End of the story.

316
00:12:38,400 --> 00:12:40,960
However, computers see the world
in a different way than

317
00:12:40,960 --> 00:12:41,740
humans usually do.

318
00:12:41,740 --> 00:12:45,070
And that's that native code
is a stream of bytes.

319
00:12:45,070 --> 00:12:47,220
And they start executing
the stream of bytes--

320
00:12:47,220 --> 00:12:50,660
pull in bytes, execute, pull
in more bytes, execute.

321
00:12:50,660 --> 00:12:52,595
And if we really want to
understand what the processor

322
00:12:52,595 --> 00:12:55,380
is doing, we have to disassemble
the code.

323
00:12:55,380 --> 00:12:58,160
We have to look at it from the
CPU's point of view and see

324
00:12:58,160 --> 00:13:01,080
what it's going to execute.

325
00:13:01,080 --> 00:13:04,300
So before we get into why this
is all difficult, the question

326
00:13:04,300 --> 00:13:05,440
is, what are we looking for?

327
00:13:05,440 --> 00:13:08,880
What instructions do we
not want to execute?

328
00:13:08,880 --> 00:13:12,070
The first one which I've been
harping on is syscall.

329
00:13:12,070 --> 00:13:15,150
So syscall, just as a
convention, on the right I

330
00:13:15,150 --> 00:13:18,670
will have the bytes that these
instructions compile into.

331
00:13:18,670 --> 00:13:20,760
So syscall is a two-byte
instruction.

332
00:13:20,760 --> 00:13:23,680
And what this does is, it says,
hey, operating system, I

333
00:13:23,680 --> 00:13:25,920
want you provide a
service for me.

334
00:13:25,920 --> 00:13:29,720
And without the outer sandbox,
without the Chrome sandbox,

335
00:13:29,720 --> 00:13:31,900
there is very obvious problems
here, is that you can open

336
00:13:31,900 --> 00:13:33,630
files, do all sorts
of bad things.

337
00:13:33,630 --> 00:13:35,910
But even with the Chrome
sandbox, there are still a lot

338
00:13:35,910 --> 00:13:36,830
of problems.

339
00:13:36,830 --> 00:13:41,480
So there's a recently publicized
vulnerability in

340
00:13:41,480 --> 00:13:46,460
the Intel implementation of the
x86-64 architecture, where

341
00:13:46,460 --> 00:13:49,810
the sysexit return-- so in the
operating system return from

342
00:13:49,810 --> 00:13:53,820
assist call, if you set it up
in such a clever way, you

343
00:13:53,820 --> 00:13:56,030
could cause it to overwrite
arbitrary memory inside the

344
00:13:56,030 --> 00:14:00,080
operating system and result in
a exploit, where you could

345
00:14:00,080 --> 00:14:02,430
escalate privileges in
the operating system.

346
00:14:02,430 --> 00:14:06,810
So the silicon itself
allowed an attack on

347
00:14:06,810 --> 00:14:08,250
the operating system.

348
00:14:08,250 --> 00:14:09,840
The bottom line is, we
simply do not want

349
00:14:09,840 --> 00:14:10,930
to make these calls.

350
00:14:10,930 --> 00:14:12,880
These calls are the gateway
to the operating system.

351
00:14:12,880 --> 00:14:14,230
They are an attack surface.

352
00:14:14,230 --> 00:14:16,400
So even if we're in a
de-privilege process, we don't

353
00:14:16,400 --> 00:14:19,260
want to make them in
the first place.

354
00:14:19,260 --> 00:14:20,480
Another interesting
instruction.

355
00:14:20,480 --> 00:14:23,930
This is actually a fairly old
example, but famous, is the

356
00:14:23,930 --> 00:14:25,410
FOOF instruction.

357
00:14:25,410 --> 00:14:29,840
The FOOF instruction, because
it starts with F-O-O-F, had

358
00:14:29,840 --> 00:14:33,420
this nasty habit of actually
freezing your entire computer

359
00:14:33,420 --> 00:14:35,560
when executed on an
older Pentium.

360
00:14:35,560 --> 00:14:39,990
So under the hood what was going
on is it applied a lock,

361
00:14:39,990 --> 00:14:42,780
and then it tried to execute
an invalid instruction.

362
00:14:42,780 --> 00:14:46,250
And it never recovered
and unlocked so your

363
00:14:46,250 --> 00:14:47,790
entire CPU hung up.

364
00:14:47,790 --> 00:14:50,020
So if you talk to some security
people, they'll say,

365
00:14:50,020 --> 00:14:52,160
well, this isn't really a
security vulnerability.

366
00:14:52,160 --> 00:14:54,990
Because, well, you know, you
aren't using your bank account

367
00:14:54,990 --> 00:14:56,980
information to some
random hacker.

368
00:14:56,980 --> 00:14:59,060
But if you think about it from
a web perspective, do you

369
00:14:59,060 --> 00:15:01,240
really want to surf to a web
page and have to power cycle

370
00:15:01,240 --> 00:15:01,850
your computer?

371
00:15:01,850 --> 00:15:02,890
It's bad.

372
00:15:02,890 --> 00:15:05,470
So there is these classes of
instructions that again we

373
00:15:05,470 --> 00:15:08,260
want to blacklist and say if
we encounter these in an

374
00:15:08,260 --> 00:15:11,080
executable, obviously the
person's up to no good.

375
00:15:11,080 --> 00:15:13,860
So syscalls, FOOF instructions,
we're not going

376
00:15:13,860 --> 00:15:16,460
to mess with them and just
reject the binary out right

377
00:15:16,460 --> 00:15:18,590
and not run it.

378
00:15:18,590 --> 00:15:20,310
So there's a third class
of instruction,

379
00:15:20,310 --> 00:15:22,470
which is a little weird.

380
00:15:22,470 --> 00:15:25,700
And if you just look at this
instruction, all it does is

381
00:15:25,700 --> 00:15:27,790
multiply a bunch of
numbers together.

382
00:15:27,790 --> 00:15:28,980
Perfectly safe.

383
00:15:28,980 --> 00:15:30,570
There's no problem with this.

384
00:15:30,570 --> 00:15:33,520
Well, as it turns out, the one
wrinkle here is that this is

385
00:15:33,520 --> 00:15:38,350
part of a new instruction set,
the SSE4 instruction set.

386
00:15:38,350 --> 00:15:40,880
So if you're running on a
computer that doesn't support

387
00:15:40,880 --> 00:15:43,670
this instruction set, what
happens when you try to

388
00:15:43,670 --> 00:15:45,440
execute it?

389
00:15:45,440 --> 00:15:48,240
So in theory, it should just
halt the process, but has

390
00:15:48,240 --> 00:15:51,620
everyone really tested every
invalid instruction possible

391
00:15:51,620 --> 00:15:52,770
on every chip?

392
00:15:52,770 --> 00:15:55,670
So instead of running this risk,
instead what we do when

393
00:15:55,670 --> 00:15:57,960
we encounter it, instead of
rejecting the program, we

394
00:15:57,960 --> 00:16:00,570
simply write over it with
halt instructions.

395
00:16:00,570 --> 00:16:04,250
So a well-formed executable
should not try to execute this

396
00:16:04,250 --> 00:16:06,160
instruction if it's
not supported.

397
00:16:06,160 --> 00:16:08,290
But if it does, because we
overwrote it with halt

398
00:16:08,290 --> 00:16:11,960
instructions, that causes the
execution to stop when it

399
00:16:11,960 --> 00:16:14,720
encounters it, just like it
theoretically should if the

400
00:16:14,720 --> 00:16:17,940
instruction was not supported
by the processor.

401
00:16:17,940 --> 00:16:20,460
So overall, Native Client is
looking for a variety of

402
00:16:20,460 --> 00:16:24,250
instructions that wants to say
either don't run the program,

403
00:16:24,250 --> 00:16:27,780
or overwrite this to be
sure that we're safe.

404
00:16:27,780 --> 00:16:29,720
So how do we find these
instructions?

405
00:16:29,720 --> 00:16:32,290
That's the crucial step.

406
00:16:32,290 --> 00:16:34,250
So previously, I said it's
a stream of bytes.

407
00:16:34,250 --> 00:16:35,630
And you're taking chunks
out of the stream of

408
00:16:35,630 --> 00:16:36,440
bytes as you go.

409
00:16:36,440 --> 00:16:39,630
And that's nice until you
realize that you aren't just

410
00:16:39,630 --> 00:16:41,070
going in one direction.

411
00:16:41,070 --> 00:16:43,050
You can occasionally hit
a jump that'll take you

412
00:16:43,050 --> 00:16:44,680
somewhere else in
the execution.

413
00:16:44,680 --> 00:16:46,010
And it could be an
arbitrary byte.

414
00:16:46,010 --> 00:16:47,330
So there's two classes
of jumps we're

415
00:16:47,330 --> 00:16:48,150
going to deal with.

416
00:16:48,150 --> 00:16:51,110
One is direct jumps, jumps where
you know the address

417
00:16:51,110 --> 00:16:53,830
that you're going to, and
indirect jumps, where your

418
00:16:53,830 --> 00:16:56,620
address is calculated from data,
and you may not know

419
00:16:56,620 --> 00:16:59,480
exactly where you're
going upfront.

420
00:16:59,480 --> 00:17:02,530
So here's an example of a
problematic direct jump.

421
00:17:02,530 --> 00:17:04,270
So two instructions here.

422
00:17:04,270 --> 00:17:08,890
The first instruction loads a
constant into a register.

423
00:17:08,890 --> 00:17:11,770
Now, this is a strange constant,
but we'll assume the

424
00:17:11,770 --> 00:17:13,710
programmer knows what they're
doing, and they have some

425
00:17:13,710 --> 00:17:15,790
reason for that constant.

426
00:17:15,790 --> 00:17:20,920
And then the next instruction
jumps backwards 4 bytes.

427
00:17:20,920 --> 00:17:24,020
So on the surface, this
should be OK.

428
00:17:24,020 --> 00:17:26,230
But the fundamental problem is
that the move instruction

429
00:17:26,230 --> 00:17:30,130
right before the jump backwards
is 5 bytes.

430
00:17:30,130 --> 00:17:32,890
So you're actually jumping back
into the middle of the

431
00:17:32,890 --> 00:17:34,820
move instruction.

432
00:17:34,820 --> 00:17:37,790
So if we look at how the
processor sees this instead of

433
00:17:37,790 --> 00:17:42,280
how our human eyes see the
assembly instruction, it first

434
00:17:42,280 --> 00:17:45,490
sees the byte b8 and says, oh,
b8, that's a move constant

435
00:17:45,490 --> 00:17:47,610
into eax instruction.

436
00:17:47,610 --> 00:17:50,130
And then there's going to be
4 bytes following it, which

437
00:17:50,130 --> 00:17:51,080
define a constant.

438
00:17:51,080 --> 00:17:53,420
So it happily pulls out the
constant, moves in the

439
00:17:53,420 --> 00:17:55,020
register, goes on.

440
00:17:55,020 --> 00:17:58,070
Then it says, oh, there's a
jump backwards 4 bytes.

441
00:17:58,070 --> 00:18:00,730
It's actually a jump backwards 6
bytes, because the processor

442
00:18:00,730 --> 00:18:03,250
calculates from the end of the
instruction, whereas the

443
00:18:03,250 --> 00:18:05,660
assembly language calculates
from the beginning.

444
00:18:05,660 --> 00:18:06,940
Just a detail, but
some people may

445
00:18:06,940 --> 00:18:08,260
find it a little confusing.

446
00:18:08,260 --> 00:18:11,520
So you jump backwards 4 bytes,
and then the processor happily

447
00:18:11,520 --> 00:18:13,780
starts executing what
it previously

448
00:18:13,780 --> 00:18:15,610
treated as a constant.

449
00:18:15,610 --> 00:18:18,070
So it says oh, 0f 05.

450
00:18:18,070 --> 00:18:18,850
Hey, that's a syscall.

451
00:18:18,850 --> 00:18:20,170
Let me do a syscall.

452
00:18:20,170 --> 00:18:21,880
And then suddenly, you don't.

453
00:18:21,880 --> 00:18:24,650
And then it sees a jump, which
nicely takes you out past the

454
00:18:24,650 --> 00:18:27,460
previous jump, and you go on
with your normal execution.

455
00:18:27,460 --> 00:18:30,870
So in one single instruction,
we managed to smuggle in two

456
00:18:30,870 --> 00:18:32,860
additional instructions,
which just entirely

457
00:18:32,860 --> 00:18:34,670
compromised your system.

458
00:18:34,670 --> 00:18:36,720
So Native Client doesn't
play this game.

459
00:18:36,720 --> 00:18:39,760
If it ever detects a program
trying to jump into what it

460
00:18:39,760 --> 00:18:42,820
previously thought was an
instruction, it says I'm not

461
00:18:42,820 --> 00:18:43,590
going to run this program.

462
00:18:43,590 --> 00:18:44,450
I'm not going to touch it.

463
00:18:44,450 --> 00:18:46,450
Obviously, you're doing
something sketchy.

464
00:18:46,450 --> 00:18:50,940
So if you generate code like
this, we don't run it.

465
00:18:50,940 --> 00:18:52,870
The other class of jumps
are indirect jumps.

466
00:18:52,870 --> 00:18:54,290
These are a little harder.

467
00:18:54,290 --> 00:18:56,450
Because you don't know exactly
where you're going.

468
00:18:56,450 --> 00:18:58,630
So how do we tell if we're
jumping inside an

469
00:18:58,630 --> 00:19:00,860
instruction or not?

470
00:19:00,860 --> 00:19:03,930
So this is a C example of where
indirect jumps come in.

471
00:19:03,930 --> 00:19:05,610
You take a function pointer.

472
00:19:05,610 --> 00:19:07,720
You call the function pointer.

473
00:19:07,720 --> 00:19:11,580
So if you look at the assembly
language, this is very

474
00:19:11,580 --> 00:19:12,700
simplified, assuming
you have an

475
00:19:12,700 --> 00:19:14,720
aggressive optimizing compiler.

476
00:19:14,720 --> 00:19:18,200
You do a direct call to a known
address, which we don't

477
00:19:18,200 --> 00:19:18,990
know what it is.

478
00:19:18,990 --> 00:19:20,700
So it's not fully
disassembled.

479
00:19:20,700 --> 00:19:23,550
And then the return value ends
up in rax, the register.

480
00:19:23,550 --> 00:19:27,330
And then you say, yeah, just
call that, whatever it is.

481
00:19:27,330 --> 00:19:29,100
So if we were being aggressive,
we could do some

482
00:19:29,100 --> 00:19:31,540
deep analysis, try to figure
out what the pointer could

483
00:19:31,540 --> 00:19:32,570
possibly point to.

484
00:19:32,570 --> 00:19:33,390
But that's hard.

485
00:19:33,390 --> 00:19:34,570
That's expensive.

486
00:19:34,570 --> 00:19:37,290
So instead, a much simpler
thing to do is look at

487
00:19:37,290 --> 00:19:40,400
individual instructions and
say can we infer from the

488
00:19:40,400 --> 00:19:42,370
sequence if what we're
doing is safe?

489
00:19:42,370 --> 00:19:45,740
So what we're saying is that
this function pointer could be

490
00:19:45,740 --> 00:19:47,680
a random number for
all we care.

491
00:19:47,680 --> 00:19:50,375
Can we make jumping to
a random number safe?

492
00:19:50,375 --> 00:19:53,490
Can we make sure that jumping to
a random number doesn't get

493
00:19:53,490 --> 00:19:56,640
us inside an instruction?

494
00:19:56,640 --> 00:19:59,400
So the first step, which may not
make sense until you see

495
00:19:59,400 --> 00:20:03,360
the second step, is any pointer,
any function pointer,

496
00:20:03,360 --> 00:20:05,690
any instruction pointer that
we're going to jump to, we

497
00:20:05,690 --> 00:20:08,350
first put a mask on it.

498
00:20:08,350 --> 00:20:11,140
And that mask says, drop
the lower 5 bits.

499
00:20:11,140 --> 00:20:13,950
Set the lower 5 bits to 0.

500
00:20:13,950 --> 00:20:15,430
So how does this help us out?

501
00:20:15,430 --> 00:20:17,570
What it means is that instead
of being able to jump

502
00:20:17,570 --> 00:20:23,950
anywhere, we can instead jump
to every 32 bytes, 1/32 of

503
00:20:23,950 --> 00:20:24,430
everywhere.

504
00:20:24,430 --> 00:20:26,690
And this isn't immediately
obvious how it

505
00:20:26,690 --> 00:20:28,040
improves our lives.

506
00:20:28,040 --> 00:20:30,440
But we modified a
compiler, right?

507
00:20:30,440 --> 00:20:33,450
So we can tell the compiler
that instead of having

508
00:20:33,450 --> 00:20:37,310
instructions that could move
over or lap over the 32-byte

509
00:20:37,310 --> 00:20:39,960
boundaries, any time you would
potentially omit an

510
00:20:39,960 --> 00:20:42,910
instruction that overlaps the
boundary, nudge it down a

511
00:20:42,910 --> 00:20:43,590
little bit.

512
00:20:43,590 --> 00:20:46,200
Stick in extra operations
that do nothing.

513
00:20:46,200 --> 00:20:48,990
And then we know that any time
you do an indirect jump to a

514
00:20:48,990 --> 00:20:51,600
32-byte boundary, you will be
hitting the start of an

515
00:20:51,600 --> 00:20:55,010
instruction instead of the
middle of an instruction.

516
00:20:55,010 --> 00:20:58,440
So the mask allows you to jump
to known safe locations, even

517
00:20:58,440 --> 00:21:01,570
if you don't know what
those locations are.

518
00:21:01,570 --> 00:21:03,110
Here's a more concrete
example.

519
00:21:03,110 --> 00:21:05,660
Here is that funky move again
with that constant.

520
00:21:05,660 --> 00:21:08,730
And if you generated it so that
it overlapped the 32-byte

521
00:21:08,730 --> 00:21:11,060
boundary, an indirect
jump could again

522
00:21:11,060 --> 00:21:12,420
execute this syscall.

523
00:21:12,420 --> 00:21:18,270
Because it would go to a mov 32
address, see the 0f 05, and

524
00:21:18,270 --> 00:21:20,230
boom, there goes your
tax return.

525
00:21:20,230 --> 00:21:24,720
So instead, the validation
algorithm require would reject

526
00:21:24,720 --> 00:21:26,780
this, because it overlaps
the boundary.

527
00:21:26,780 --> 00:21:29,440
Instead the compiler would
generate this extra

528
00:21:29,440 --> 00:21:32,420
no-operation and move the
instruction down.

529
00:21:32,420 --> 00:21:35,030
So the combination of not
allowing direct jumps inside

530
00:21:35,030 --> 00:21:37,590
that instruction and making
sure that no instructions

531
00:21:37,590 --> 00:21:40,610
overlap 32-byte boundaries allow
you to know where all

532
00:21:40,610 --> 00:21:44,650
the control flow in your
program is going.

533
00:21:44,650 --> 00:21:46,600
Aha, you say, but I'm
a clever hacker.

534
00:21:46,600 --> 00:21:48,750
I can modify the code after
you validate it.

535
00:21:48,750 --> 00:21:51,500
So validation just happens
at the beginning.

536
00:21:51,500 --> 00:21:53,460
We say, we'll look
at the code.

537
00:21:53,460 --> 00:21:56,820
If it's good to go, we'll
let you run the code.

538
00:21:56,820 --> 00:21:59,900
So, to prevent code
modification, we say any time

539
00:21:59,900 --> 00:22:02,480
we have a chunk of data, which
represents code, it's going to

540
00:22:02,480 --> 00:22:05,830
be readable and executable
when you don't have the

541
00:22:05,830 --> 00:22:07,510
permissions to write it.

542
00:22:07,510 --> 00:22:09,850
So everything that goes through
the validator, once we

543
00:22:09,850 --> 00:22:12,430
know what it does, we make sure
it keeps doing what we

544
00:22:12,430 --> 00:22:14,390
know it does.

545
00:22:14,390 --> 00:22:15,360
Aha, you say.

546
00:22:15,360 --> 00:22:17,110
But what about things
that aren't code?

547
00:22:17,110 --> 00:22:20,200
So I can just do a buffer
overflow somewhere, jump to

548
00:22:20,200 --> 00:22:23,120
that buffer overflow, start
executing it, and I just

549
00:22:23,120 --> 00:22:24,950
executed code you haven't
validated.

550
00:22:24,950 --> 00:22:28,580
Well, again, every piece of data
we make sure can be read

551
00:22:28,580 --> 00:22:31,360
and written, but not executed.

552
00:22:31,360 --> 00:22:34,450
So this plugs the hole for
self-modifying code.

553
00:22:34,450 --> 00:22:35,930
So I just lied to you.

554
00:22:35,930 --> 00:22:39,840
And that's that things can
change after the initial setup

555
00:22:39,840 --> 00:22:40,410
of the program.

556
00:22:40,410 --> 00:22:42,390
So you can load dynamic
libraries.

557
00:22:42,390 --> 00:22:45,270
You can have just-in-time
compilers which emit new code

558
00:22:45,270 --> 00:22:48,030
and actually modify the code
in very controlled ways.

559
00:22:48,030 --> 00:22:50,360
But how you do that is
kind of complicated.

560
00:22:50,360 --> 00:22:52,320
Because you need to make sure
that if there's multiple

561
00:22:52,320 --> 00:22:56,340
threads, you never get memory
de-coherency, where you

562
00:22:56,340 --> 00:22:57,980
execute an instruction
which is in the

563
00:22:57,980 --> 00:22:59,930
middle of being modified.

564
00:22:59,930 --> 00:23:01,980
At the end of this presentation,
I'll have a link

565
00:23:01,980 --> 00:23:02,880
to the research papers.

566
00:23:02,880 --> 00:23:05,810
So if you're really interested
in how we do memory safe code

567
00:23:05,810 --> 00:23:08,110
modification, you can read
up or ask me afterwards.

568
00:23:08,110 --> 00:23:10,640
But for this presentation, we're
going to ignore this

569
00:23:10,640 --> 00:23:13,640
rather large, ugly issue.

570
00:23:13,640 --> 00:23:18,370
Another thing is that mprotect
is now security-critical.

571
00:23:18,370 --> 00:23:21,250
So syscalls, we've thought about
all the damage we could

572
00:23:21,250 --> 00:23:22,150
do with them.

573
00:23:22,150 --> 00:23:24,930
But now we can start doing
indirect damage like

574
00:23:24,930 --> 00:23:27,860
unprotecting a page, writing it,
then boom, we're executing

575
00:23:27,860 --> 00:23:30,260
code that is invalid.

576
00:23:30,260 --> 00:23:33,440
Similarly, there's other
syscalls like GetProcessID,

577
00:23:33,440 --> 00:23:35,690
not immediately obvious why
they're dangerous, but they

578
00:23:35,690 --> 00:23:38,370
can be used to escalate attacks
by knowing where

579
00:23:38,370 --> 00:23:39,270
you're going from.

580
00:23:39,270 --> 00:23:41,720
So the name of the game is
white-listing, only allowing

581
00:23:41,720 --> 00:23:44,805
functionality we know is safe
instead of saying, eh, do a

582
00:23:44,805 --> 00:23:46,055
syscall , whatever.

583
00:23:46,055 --> 00:23:48,210

584
00:23:48,210 --> 00:23:51,330
So that's the basics of how we
allow code to be decompiled.

585
00:23:51,330 --> 00:23:54,280
And if you actually start
looking at how this affects

586
00:23:54,280 --> 00:23:55,850
calling and returning a
function, there's some

587
00:23:55,850 --> 00:23:57,890
interesting things that
get shaken out.

588
00:23:57,890 --> 00:23:59,270
So I'm going to do
in the reverse.

589
00:23:59,270 --> 00:24:01,450
I'm going to show how you
return from a function.

590
00:24:01,450 --> 00:24:03,880
Then I'm going to show how you
call it, because the return

591
00:24:03,880 --> 00:24:05,130
impacts the call.

592
00:24:05,130 --> 00:24:07,460

593
00:24:07,460 --> 00:24:09,360
So usually, returning from
a function is a single

594
00:24:09,360 --> 00:24:10,400
instruction.

595
00:24:10,400 --> 00:24:14,980
Return, pop an address off the
stack, jumps to that address,

596
00:24:14,980 --> 00:24:17,230
and you're back to where
you called from.

597
00:24:17,230 --> 00:24:20,120
So you could call the same
function for multiple places.

598
00:24:20,120 --> 00:24:23,190
So the call records where you
called from on the stack in

599
00:24:23,190 --> 00:24:24,800
order to be able to
return to it.

600
00:24:24,800 --> 00:24:29,040
But implicitly, this is
an indirect jump.

601
00:24:29,040 --> 00:24:32,400
So a malicious program could
stick a random number on the

602
00:24:32,400 --> 00:24:35,870
stack and then jump instead of
calling to the function.

603
00:24:35,870 --> 00:24:37,940
And then when the function
returned, who

604
00:24:37,940 --> 00:24:39,090
knows where you are.

605
00:24:39,090 --> 00:24:41,290
So there is a type of exploit
called return-oriented

606
00:24:41,290 --> 00:24:44,710
programming, which uses this
kind of thing where the

607
00:24:44,710 --> 00:24:46,695
returns can be repurposed
for jumping

608
00:24:46,695 --> 00:24:48,890
to arbitrary locations.

609
00:24:48,890 --> 00:24:50,550
So we can try to fix this.

610
00:24:50,550 --> 00:24:54,200
We can manually pop the return
address off the stack, mask

611
00:24:54,200 --> 00:24:56,980
it, just like we should for
indirect jumps, push it back

612
00:24:56,980 --> 00:24:58,860
on the stack, and then return.

613
00:24:58,860 --> 00:24:59,950
So problem solved.

614
00:24:59,950 --> 00:25:01,230
Well, no.

615
00:25:01,230 --> 00:25:02,490
I mentioned threads earlier.

616
00:25:02,490 --> 00:25:04,840
And threads are a big problem
because there could be another

617
00:25:04,840 --> 00:25:07,520
thread in the background trying
to smash the stack.

618
00:25:07,520 --> 00:25:10,700
And so between the moment where
you push the address on

619
00:25:10,700 --> 00:25:14,180
the stack and when you return,
the memory could get changed

620
00:25:14,180 --> 00:25:16,880
out from under you, and you
could end up anywhere.

621
00:25:16,880 --> 00:25:17,920
Who knows where?

622
00:25:17,920 --> 00:25:20,760
So we can't really trust any
addresses in memory.

623
00:25:20,760 --> 00:25:23,180
We can only trust addresses
in registers.

624
00:25:23,180 --> 00:25:26,090
So what this means is that in
order to return, we can't use

625
00:25:26,090 --> 00:25:27,230
the return instruction.

626
00:25:27,230 --> 00:25:31,090
We pop off the stack, mask it,
and then jump to the address.

627
00:25:31,090 --> 00:25:33,900
This has a few consequences,
like branch prediction is a

628
00:25:33,900 --> 00:25:34,980
little harder.

629
00:25:34,980 --> 00:25:38,480
And we're using more bytes
to do the same operation.

630
00:25:38,480 --> 00:25:41,870
So I mentioned earlier that
the sandboxing schemes for

631
00:25:41,870 --> 00:25:43,670
different architectures
were different.

632
00:25:43,670 --> 00:25:45,870
And this is largely due to the
fact that we are trying to

633
00:25:45,870 --> 00:25:49,940
minimize the cost and tailor
it to each architecture.

634
00:25:49,940 --> 00:25:52,850
So we try to keep the number
of bytes per sandbox

635
00:25:52,850 --> 00:25:55,640
instruction as low as possible
through being horrendously

636
00:25:55,640 --> 00:25:57,570
clever about how
we mask things.

637
00:25:57,570 --> 00:25:59,745
And if you want to talk about
this, again, we can talk about

638
00:25:59,745 --> 00:26:02,640
it afterwards, about clever
instruction encodings.

639
00:26:02,640 --> 00:26:03,840
So return.

640
00:26:03,840 --> 00:26:06,940
A very basic instruction is
actually dangerous because

641
00:26:06,940 --> 00:26:13,680
it's doing an indirect jump
to a location from memory.

642
00:26:13,680 --> 00:26:15,060
So bad idea.

643
00:26:15,060 --> 00:26:18,280
We have to do it explicitly.

644
00:26:18,280 --> 00:26:23,580
So whenever we have masks, it
becomes critical that we don't

645
00:26:23,580 --> 00:26:25,690
bypass the mask.

646
00:26:25,690 --> 00:26:28,930
So we may have two instructions,
the mask and

647
00:26:28,930 --> 00:26:29,990
then the jump.

648
00:26:29,990 --> 00:26:32,010
But if there's some other jump
which goes between the

649
00:26:32,010 --> 00:26:34,400
instructions, it doesn't
actually violate what I talked

650
00:26:34,400 --> 00:26:35,620
about previously.

651
00:26:35,620 --> 00:26:38,020
I said you can't jump
into an instruction.

652
00:26:38,020 --> 00:26:40,350
But if you jump between these
two instructions that are

653
00:26:40,350 --> 00:26:42,050
critical for safety,
suddenly you just

654
00:26:42,050 --> 00:26:42,970
stripped off the mask.

655
00:26:42,970 --> 00:26:44,900
The entire security
model fails.

656
00:26:44,900 --> 00:26:47,270
And you have a problem.

657
00:26:47,270 --> 00:26:48,780
We call these
pseudo-instructions.

658
00:26:48,780 --> 00:26:50,880
So whenever we have a sequence
of instructions which is

659
00:26:50,880 --> 00:26:53,760
security critical, we say treat
it just like it was an

660
00:26:53,760 --> 00:26:54,870
instruction.

661
00:26:54,870 --> 00:26:58,480
So direct jumps cannot jump
inside a pseudo-instruction.

662
00:26:58,480 --> 00:27:01,150
Indirect jumps cannot jump
inside a pseudo-instruction,

663
00:27:01,150 --> 00:27:04,580
which means that the entire
pseudo-instruction has to not

664
00:27:04,580 --> 00:27:09,220
cross a 32-byte boundary.

665
00:27:09,220 --> 00:27:12,990
As a terminology, we
call this bundling.

666
00:27:12,990 --> 00:27:18,960
So what does this mean for
calling a function?

667
00:27:18,960 --> 00:27:21,590
If you just call it like you
expected, just from the middle

668
00:27:21,590 --> 00:27:25,320
of a bundle somewhere,
you do the call.

669
00:27:25,320 --> 00:27:26,180
You know, you see
the mask here.

670
00:27:26,180 --> 00:27:27,910
You see the indirect jump.

671
00:27:27,910 --> 00:27:29,630
And then where do
you return to?

672
00:27:29,630 --> 00:27:32,690
The problem is that the mask
drops the lower 5 bits of the

673
00:27:32,690 --> 00:27:36,230
address, so you aren't returning
to the address that

674
00:27:36,230 --> 00:27:38,800
was pushed on the stack
if those lower bits

675
00:27:38,800 --> 00:27:40,430
were not all zeroes.

676
00:27:40,430 --> 00:27:44,800
So you end up returning to the
beginning of the bundle where

677
00:27:44,800 --> 00:27:45,850
the call was from.

678
00:27:45,850 --> 00:27:47,420
And this is obviously
not what you want.

679
00:27:47,420 --> 00:27:49,840
This starts to look a bit like
an infinite loop unless you

680
00:27:49,840 --> 00:27:50,710
account for it.

681
00:27:50,710 --> 00:27:52,790
Where you really want it to
return is immediately after

682
00:27:52,790 --> 00:27:53,950
the instruction.

683
00:27:53,950 --> 00:27:58,630
So the work-around for this is
that whenever you have a call,

684
00:27:58,630 --> 00:28:01,510
you pat it down to the very
end of the bundle.

685
00:28:01,510 --> 00:28:05,020
And this means that the return
address is at the beginning of

686
00:28:05,020 --> 00:28:06,500
the very next bundle.

687
00:28:06,500 --> 00:28:09,150
So when you mask it, when you
drop the lower 5 bits, it

688
00:28:09,150 --> 00:28:11,190
doesn't change it at all.

689
00:28:11,190 --> 00:28:16,130
So all these instruction
sequences that we're showing

690
00:28:16,130 --> 00:28:19,860
in fact should not change the
correctness of the program.

691
00:28:19,860 --> 00:28:23,030
They are simply there for the
validator to say, oh, yep, I

692
00:28:23,030 --> 00:28:24,600
can prove that this is safe.

693
00:28:24,600 --> 00:28:27,870
And if somehow garbage data gets
in here, I know that I'm

694
00:28:27,870 --> 00:28:29,500
going to be jumping
to a known place.

695
00:28:29,500 --> 00:28:32,420
But in normal operation, the
compiler will stick everything

696
00:28:32,420 --> 00:28:35,490
on 32-byte aligned boundaries
that we need to jump to

697
00:28:35,490 --> 00:28:36,740
indirectly.

698
00:28:36,740 --> 00:28:39,590

699
00:28:39,590 --> 00:28:41,860
OK, so yet again, I lied.

700
00:28:41,860 --> 00:28:43,480
I seem to be a serial
liar here.

701
00:28:43,480 --> 00:28:46,090
I apologize.

702
00:28:46,090 --> 00:28:48,020
There's more going on
in the process than

703
00:28:48,020 --> 00:28:49,210
just this bit of code.

704
00:28:49,210 --> 00:28:52,130
We can validate a lot of code,
but as it turns out, there's

705
00:28:52,130 --> 00:28:54,090
other code and data in
the process that

706
00:28:54,090 --> 00:28:55,730
we don't fully control.

707
00:28:55,730 --> 00:28:58,210
It needs to be there
so we can use it.

708
00:28:58,210 --> 00:29:02,120
So we have a world where we
have a single process with

709
00:29:02,120 --> 00:29:05,540
code we don't trust and
code that we do trust.

710
00:29:05,540 --> 00:29:10,130
So this is the general view
of what I've shown so far.

711
00:29:10,130 --> 00:29:12,410
There's untrusted code
and untrusted data.

712
00:29:12,410 --> 00:29:15,280
And what I mean by untrusted
is this code is coming from

713
00:29:15,280 --> 00:29:17,040
somewhere across the wire.

714
00:29:17,040 --> 00:29:20,310
And instead of having to have
this dialog box that says,

715
00:29:20,310 --> 00:29:21,730
well, you're running
at your own risk.

716
00:29:21,730 --> 00:29:23,280
Instead, we validate it.

717
00:29:23,280 --> 00:29:25,000
And then we say this conforms
to our rules.

718
00:29:25,000 --> 00:29:27,970
So we'll run it without having
to place trust in it.

719
00:29:27,970 --> 00:29:31,960
We will enforce the security
instead of trusting, so

720
00:29:31,960 --> 00:29:34,850
untrusted code, untrusted
data.

721
00:29:34,850 --> 00:29:38,130
Well, every time you launch a
process, the operating system

722
00:29:38,130 --> 00:29:40,100
likes to stick in some code.

723
00:29:40,100 --> 00:29:42,510
So you can talk with the
operating system.

724
00:29:42,510 --> 00:29:44,870
And we could do something really
nasty, like try to

725
00:29:44,870 --> 00:29:46,540
overwrite this, kick it out.

726
00:29:46,540 --> 00:29:48,430
But we're going to need
it eventually.

727
00:29:48,430 --> 00:29:50,220
We're going to need
to do something.

728
00:29:50,220 --> 00:29:52,540
Simply living within the
sandbox isn't enough.

729
00:29:52,540 --> 00:29:56,310
So down the road, we're going
to need to talk to the NTDLL

730
00:29:56,310 --> 00:29:58,210
on Windows, for instance.

731
00:29:58,210 --> 00:30:01,390
But we don't want the untrusted
code to do it.

732
00:30:01,390 --> 00:30:03,590
Similarly, we're going to be
talking with a web browser.

733
00:30:03,590 --> 00:30:07,220
So the easiest way to do this
is load the DLL for the web

734
00:30:07,220 --> 00:30:08,700
browser in the process.

735
00:30:08,700 --> 00:30:11,120
So we can call the same
functionality to talk between

736
00:30:11,120 --> 00:30:13,690
processes that Chrome uses.

737
00:30:13,690 --> 00:30:15,380
There's also trusted data.

738
00:30:15,380 --> 00:30:18,580
So when we're running the
sandbox, we have to keep track

739
00:30:18,580 --> 00:30:20,590
of things like where
code is mapped.

740
00:30:20,590 --> 00:30:24,110
Because if the untrusted code
says, well, there's actually

741
00:30:24,110 --> 00:30:26,540
no code there, so why don't
you map code there again?

742
00:30:26,540 --> 00:30:28,360
Then we could get weird
overwrites, partial

743
00:30:28,360 --> 00:30:29,340
instructions.

744
00:30:29,340 --> 00:30:30,470
So there's bookkeeping data.

745
00:30:30,470 --> 00:30:33,040
And if you could clobber that
data, if you could go there

746
00:30:33,040 --> 00:30:35,940
and say overwrite the table
for where all the code is,

747
00:30:35,940 --> 00:30:37,600
then the untrusted code
could start doing,

748
00:30:37,600 --> 00:30:40,740
again, very bad things.

749
00:30:40,740 --> 00:30:44,650
What we need to do is we need to
make sure all the execution

750
00:30:44,650 --> 00:30:47,860
and all the data access that
can be done directly by the

751
00:30:47,860 --> 00:30:52,040
untrusted code only happens
within a confined region that

752
00:30:52,040 --> 00:30:55,370
doesn't include NTDLL, that
doesn't include Chrome DLL,

753
00:30:55,370 --> 00:30:58,700
that doesn't include any bit of
code or data which could be

754
00:30:58,700 --> 00:31:00,850
used as an exploit.

755
00:31:00,850 --> 00:31:05,010
So on 64-bit systems, this is a
4-gigabyte range of memory.

756
00:31:05,010 --> 00:31:08,190
And we reserve one of the
registers, R15, to point to

757
00:31:08,190 --> 00:31:10,530
the bottom of this range.

758
00:31:10,530 --> 00:31:12,790
So one of our security-critical
properties

759
00:31:12,790 --> 00:31:15,330
is that R15 cannot
be overwritten by

760
00:31:15,330 --> 00:31:16,510
the entrusted code.

761
00:31:16,510 --> 00:31:18,610
So as the validator goes
through, it looks for anything

762
00:31:18,610 --> 00:31:20,310
that can modify R15.

763
00:31:20,310 --> 00:31:23,020
And if something does, it
goes, nope, not going

764
00:31:23,020 --> 00:31:24,900
to deal with it.

765
00:31:24,900 --> 00:31:27,020
A thing you may note also is
that this is a 4-gigabyte

766
00:31:27,020 --> 00:31:30,850
range, which happens to be 2 of
32, which allows us to do

767
00:31:30,850 --> 00:31:33,820
some horrendously clever stuff
to make our masking as small

768
00:31:33,820 --> 00:31:34,260
as possible.

769
00:31:34,260 --> 00:31:37,130
We'll get into that
in a second.

770
00:31:37,130 --> 00:31:39,330
So here's a scenario that
we have to worry about.

771
00:31:39,330 --> 00:31:41,740
What happens when the untrusted
code tries to jump

772
00:31:41,740 --> 00:31:43,790
outside the sandbox?

773
00:31:43,790 --> 00:31:47,010
So it can't do a direct jump
outside this constrained

774
00:31:47,010 --> 00:31:50,870
range, because the validator
can't see the target.

775
00:31:50,870 --> 00:31:53,180
And because it can't see the
target, it can't tell whether

776
00:31:53,180 --> 00:31:55,770
it's in the middle of an
instruction, so it says, no.

777
00:31:55,770 --> 00:31:58,140
But it could do an
indirect jump.

778
00:31:58,140 --> 00:32:00,840
So it could do an indirect
jump to a 32-byte aligned

779
00:32:00,840 --> 00:32:02,610
boundary somewhere in NTDLL.

780
00:32:02,610 --> 00:32:04,390
And we have to allow this,
because you could be loading

781
00:32:04,390 --> 00:32:05,470
shared libraries.

782
00:32:05,470 --> 00:32:08,630
So you may not know where the
code is before you load it.

783
00:32:08,630 --> 00:32:11,120
So what we have to do is we have
to make sure the indirect

784
00:32:11,120 --> 00:32:14,460
jumps only fall within this
constrained range.

785
00:32:14,460 --> 00:32:16,870
So how do we do that?

786
00:32:16,870 --> 00:32:20,010
We have to confine the jumps
to the 4-gigabyte range.

787
00:32:20,010 --> 00:32:20,800
Here's an example.

788
00:32:20,800 --> 00:32:22,070
It's just an empty function.

789
00:32:22,070 --> 00:32:24,390
What's happening implicitly
here, however,

790
00:32:24,390 --> 00:32:25,690
is that it's returning.

791
00:32:25,690 --> 00:32:28,710
And as we went through all these
explanations, this is

792
00:32:28,710 --> 00:32:30,510
what a return eventually
looks like.

793
00:32:30,510 --> 00:32:33,060
There's this masked indirect
jump back to

794
00:32:33,060 --> 00:32:34,700
wherever you came from.

795
00:32:34,700 --> 00:32:37,200
But this could go into NTDLL.

796
00:32:37,200 --> 00:32:39,400
How do we fix it?

797
00:32:39,400 --> 00:32:43,280
So we confine it by masking
it and dropping

798
00:32:43,280 --> 00:32:45,190
the upper 32 bits.

799
00:32:45,190 --> 00:32:47,820
So we boil it down to
a 32-bit address.

800
00:32:47,820 --> 00:32:49,350
Then we add the offset.

801
00:32:49,350 --> 00:32:51,370
And then we actually use that.

802
00:32:51,370 --> 00:32:53,690
So remember I was saying
horrendously clever?

803
00:32:53,690 --> 00:32:55,960
This is not really
self-promotion.

804
00:32:55,960 --> 00:32:57,760
When I was doing this
presentation, I had to work

805
00:32:57,760 --> 00:33:00,000
through exactly how these
instructions worked.

806
00:33:00,000 --> 00:33:01,250
It's actually pretty
interesting.

807
00:33:01,250 --> 00:33:04,240
So the "and" right here
is doing a 32-bit

808
00:33:04,240 --> 00:33:05,580
operation on a register.

809
00:33:05,580 --> 00:33:09,890
And then later the register is
being used as a 64-bit value.

810
00:33:09,890 --> 00:33:12,550
So doing the 32-bit operation
implicitly

811
00:33:12,550 --> 00:33:14,700
zeroes the upper bits.

812
00:33:14,700 --> 00:33:17,970
And this allows the actual "and"
to be packed down into a

813
00:33:17,970 --> 00:33:19,720
single byte data.

814
00:33:19,720 --> 00:33:22,740
So it says, it's going to
be e0 sign extended.

815
00:33:22,740 --> 00:33:25,220
And then I'll implicitly drop
the upper 32 bits, because

816
00:33:25,220 --> 00:33:26,740
it's a 32-bit operation.

817
00:33:26,740 --> 00:33:30,600
Then you do a full 64-bit add
and a full 64-bit jump.

818
00:33:30,600 --> 00:33:34,300
So the cost of this is about
8 bytes as opposed 2 bytes.

819
00:33:34,300 --> 00:33:36,540
So there's a bit of overhead for
doing it this way, but we

820
00:33:36,540 --> 00:33:37,640
know where it's going.

821
00:33:37,640 --> 00:33:39,790
We know it's only going to be
within the confined region.

822
00:33:39,790 --> 00:33:42,640
And we know it's only going to
be to a 32-byte boundary.

823
00:33:42,640 --> 00:33:44,970
And we know there's going to
be no instructions that are

824
00:33:44,970 --> 00:33:47,930
overlapping those 32-byte
boundaries.

825
00:33:47,930 --> 00:33:51,090
The next thing to worry about is
reading and writing bits of

826
00:33:51,090 --> 00:33:54,800
data that are outside
this confined range.

827
00:33:54,800 --> 00:33:56,950
Writing is obviously
a problem.

828
00:33:56,950 --> 00:33:58,500
If you can write to something,
you can change it.

829
00:33:58,500 --> 00:33:59,610
You can control it.

830
00:33:59,610 --> 00:34:02,020
It makes attacks much easier.

831
00:34:02,020 --> 00:34:07,060
Reading, debatably it's not an
attack, but this can be used

832
00:34:07,060 --> 00:34:09,060
to help attacks.

833
00:34:09,060 --> 00:34:11,420
So if you can poke around
memory, find where things are,

834
00:34:11,420 --> 00:34:14,460
then you can do much more
controlled jumps, much more

835
00:34:14,460 --> 00:34:17,080
dangerous intended
actions than just

836
00:34:17,080 --> 00:34:19,860
jumping around randomly.

837
00:34:19,860 --> 00:34:22,790
So how do we confine
data access?

838
00:34:22,790 --> 00:34:24,540
Here's an example
of a C function.

839
00:34:24,540 --> 00:34:27,239
We're just taking a function
pointer, and we're writing a

840
00:34:27,239 --> 00:34:30,510
constant to that pointer
wherever it may be.

841
00:34:30,510 --> 00:34:32,030
Thus far, we haven't
talked about

842
00:34:32,030 --> 00:34:34,219
sandboxing rights at all.

843
00:34:34,219 --> 00:34:37,000
So the Intel instruction for
doing this just says move this

844
00:34:37,000 --> 00:34:40,210
constant to wherever the memory
address points to.

845
00:34:40,210 --> 00:34:43,489
So to sandbox it, we do
something similar to jumps.

846
00:34:43,489 --> 00:34:47,820
We mask it by moving a 32-bit
register to itself.

847
00:34:47,820 --> 00:34:50,530
So again, we rely on the
implicit zeroing

848
00:34:50,530 --> 00:34:51,370
of the upper bits.

849
00:34:51,370 --> 00:34:53,980
But since we don't need to
discard the lower bits, it's

850
00:34:53,980 --> 00:34:55,000
just a move.

851
00:34:55,000 --> 00:34:56,690
Simple enough.

852
00:34:56,690 --> 00:35:00,750
And then we do a complicated
addressing mode, which

853
00:35:00,750 --> 00:35:06,190
actually adds R15 simultaneously
with moving the

854
00:35:06,190 --> 00:35:08,500
constant to the address
that's computed.

855
00:35:08,500 --> 00:35:13,270
So this move instruction is
saying add R15 to rax and then

856
00:35:13,270 --> 00:35:16,830
multiply rax by 1,
and there you go.

857
00:35:16,830 --> 00:35:20,380
Instead of 5 bytes to do this
move constant, we got 9 bytes.

858
00:35:20,380 --> 00:35:22,360
Not too bad.

859
00:35:22,360 --> 00:35:23,820
There's a little curious
thing here, though.

860
00:35:23,820 --> 00:35:26,030
There's that multiplier.

861
00:35:26,030 --> 00:35:28,860
So we know that rax is a
32-bit value, but that

862
00:35:28,860 --> 00:35:30,960
multiplier can be up to 8.

863
00:35:30,960 --> 00:35:33,740
So we aren't actually operating
within a 4-gigabyte

864
00:35:33,740 --> 00:35:36,180
range, we're potentially
doing a write

865
00:35:36,180 --> 00:35:38,960
to 8 times 4 gigabytes?

866
00:35:38,960 --> 00:35:41,170
And there's ways you can rack
it up even further with

867
00:35:41,170 --> 00:35:42,440
constant offsets.

868
00:35:42,440 --> 00:35:47,600
So we could tweak this a little
harder and do the mask

869
00:35:47,600 --> 00:35:50,070
and get rid of the
multiplications, but sometimes

870
00:35:50,070 --> 00:35:51,880
compilers just like
to generate these.

871
00:35:51,880 --> 00:35:54,340
And the more features you get
rid of, the slower the code's

872
00:35:54,340 --> 00:35:55,660
going to be.

873
00:35:55,660 --> 00:35:58,570
So instead of trying to do
instruction sequences that are

874
00:35:58,570 --> 00:36:04,480
safer, we actually say, well,
40 to 44 gigabytes on either

875
00:36:04,480 --> 00:36:08,580
side of this confined range,
we're going to mark as--

876
00:36:08,580 --> 00:36:09,680
we own it.

877
00:36:09,680 --> 00:36:11,080
So you can't use it.

878
00:36:11,080 --> 00:36:13,420
So you aren't actually
allocating the memory.

879
00:36:13,420 --> 00:36:17,840
You're just marking it as no one
gets this memory but us.

880
00:36:17,840 --> 00:36:19,590
And it's illegal to read.

881
00:36:19,590 --> 00:36:20,550
It's illegal to write.

882
00:36:20,550 --> 00:36:21,770
It's illegal to jump to.

883
00:36:21,770 --> 00:36:23,540
It doesn't exist.

884
00:36:23,540 --> 00:36:28,170
So if you can do a memory access
which is outside this

885
00:36:28,170 --> 00:36:31,720
4-gigabyte range, you get caught
by the guard region.

886
00:36:31,720 --> 00:36:34,420
And that's how we allow these
addressing modes.

887
00:36:34,420 --> 00:36:37,100
And just as a funny side note,
sometimes we get people

888
00:36:37,100 --> 00:36:40,010
benchmarking Native Client
and say, you take over 80

889
00:36:40,010 --> 00:36:41,820
gigabytes of memory!

890
00:36:41,820 --> 00:36:45,190
And we're like, do you have over
80 gigabytes of memory?

891
00:36:45,190 --> 00:36:46,710
But really what they're looking
at is they're looking

892
00:36:46,710 --> 00:36:50,900
at address space usage rather
than actual memory usage.

893
00:36:50,900 --> 00:36:53,590

894
00:36:53,590 --> 00:36:56,170
So we can't do anything fun.

895
00:36:56,170 --> 00:36:58,320
We can just go inside
the sandbox.

896
00:36:58,320 --> 00:36:58,980
How do we get out?

897
00:36:58,980 --> 00:37:02,720
How do we actually request the
URL like I showed in the

898
00:37:02,720 --> 00:37:04,530
beginning of this
presentation?

899
00:37:04,530 --> 00:37:08,960
To do that, at the bottom of
the sandbox Native Client

900
00:37:08,960 --> 00:37:11,910
inserts a bit of code called
the trampoline.

901
00:37:11,910 --> 00:37:14,240
Now the trampoline is code that
would not normally be

902
00:37:14,240 --> 00:37:17,700
validated, but allows you to do
a controlled jump outside

903
00:37:17,700 --> 00:37:18,720
the sandbox.

904
00:37:18,720 --> 00:37:22,020
So there's a trampoline entry
for each service we provide,

905
00:37:22,020 --> 00:37:23,710
such as spawning threads.

906
00:37:23,710 --> 00:37:25,480
And when you want that, you
jump to the trampoline.

907
00:37:25,480 --> 00:37:28,540
And the trampoline jumps you out
into Chrome DLL, where we

908
00:37:28,540 --> 00:37:30,320
provide an implementation
for that.

909
00:37:30,320 --> 00:37:33,020
So the set of trampoline calls
you have, which are analogous

910
00:37:33,020 --> 00:37:35,900
to syscalls, are the same
on every platform.

911
00:37:35,900 --> 00:37:41,390
So in one swoop, we are
providing a cross-platform API

912
00:37:41,390 --> 00:37:47,390
and controlling exactly what
services the native code gets.

913
00:37:47,390 --> 00:37:50,700
The trampoline itself, again,
is small, but in some ways

914
00:37:50,700 --> 00:37:52,020
overly clever.

915
00:37:52,020 --> 00:37:55,840
And we take a constant address,
stick it in a

916
00:37:55,840 --> 00:38:00,270
register, and then call
that address.

917
00:38:00,270 --> 00:38:02,290
And there's a few things
going on here.

918
00:38:02,290 --> 00:38:06,060
One is that we do the move into
the register instead of

919
00:38:06,060 --> 00:38:10,490
doing a direct call, so that
it's easier to patch the code

920
00:38:10,490 --> 00:38:12,820
as we know exactly the address
we're going to.

921
00:38:12,820 --> 00:38:14,790
And in fact, we can make that
address the same for all the

922
00:38:14,790 --> 00:38:15,800
trampolines.

923
00:38:15,800 --> 00:38:17,790
So if you have multiple
trampolines going to the same

924
00:38:17,790 --> 00:38:21,050
place, since direct jumps are
relative, you'd have to do a

925
00:38:21,050 --> 00:38:22,660
lot of math and make sure
that you're jumping

926
00:38:22,660 --> 00:38:23,370
to the right address.

927
00:38:23,370 --> 00:38:25,750
But here we just jump to
a constant address.

928
00:38:25,750 --> 00:38:28,140
Another thing is that it's a
call instead of a jump, so we

929
00:38:28,140 --> 00:38:31,620
can have a trace of where the
syscall's coming from.

930
00:38:31,620 --> 00:38:33,790
So we know, oh, we're going
through trampoline 4,

931
00:38:33,790 --> 00:38:36,350
therefore, we know what
service we're getting.

932
00:38:36,350 --> 00:38:38,390
And then finally at the
end, there's a halt.

933
00:38:38,390 --> 00:38:41,640
So even though we're doing a
call, we never return to where

934
00:38:41,640 --> 00:38:42,270
we called from.

935
00:38:42,270 --> 00:38:44,310
It's just a method to
trace the address of

936
00:38:44,310 --> 00:38:45,530
where we came from.

937
00:38:45,530 --> 00:38:48,800
So if anyone returns from inside
the system code, it's

938
00:38:48,800 --> 00:38:49,840
going to hit the halt, and it's

939
00:38:49,840 --> 00:38:52,140
going to prevent execution.

940
00:38:52,140 --> 00:38:55,210
This is all interesting because
it's within 13 bytes.

941
00:38:55,210 --> 00:38:57,760
So this means that the
trampoline fits within the

942
00:38:57,760 --> 00:39:00,030
32-byte bundle.

943
00:39:00,030 --> 00:39:04,470
And this means that indirect
jumps will never go inside the

944
00:39:04,470 --> 00:39:04,940
trampoline.

945
00:39:04,940 --> 00:39:06,840
They can only go to the start
to the trampoline.

946
00:39:06,840 --> 00:39:10,610
And this is what allows us to
do safe exits outside of the

947
00:39:10,610 --> 00:39:13,110
NaCl sandbox.

948
00:39:13,110 --> 00:39:16,870
So putting it all together, this
is the API call which I

949
00:39:16,870 --> 00:39:18,000
started with.

950
00:39:18,000 --> 00:39:19,690
It is loading a URL.

951
00:39:19,690 --> 00:39:23,300
So to do this, the untrusted
code initiates it by jumping

952
00:39:23,300 --> 00:39:27,150
to the trampoline and saying
I want to do this request.

953
00:39:27,150 --> 00:39:29,740
The trampoline takes
it to Chrome DLL.

954
00:39:29,740 --> 00:39:32,750
Chrome DLL has an implementation
that says, OK,

955
00:39:32,750 --> 00:39:35,130
native code wants to
do a URL request.

956
00:39:35,130 --> 00:39:38,140
Well, I can't do it myself
because I'm running inside the

957
00:39:38,140 --> 00:39:39,340
Chrome sandbox.

958
00:39:39,340 --> 00:39:42,160
So instead, what I have to do
is I have to talk to the

959
00:39:42,160 --> 00:39:44,850
Chrome browser via the
render process.

960
00:39:44,850 --> 00:39:47,030
So to do that, I'm going to need
to do some inter-process

961
00:39:47,030 --> 00:39:48,110
communication.

962
00:39:48,110 --> 00:39:50,830
So it talks to the operating
system and says, hey, send

963
00:39:50,830 --> 00:39:53,875
this bit of the data to the
renderer process, and then it

964
00:39:53,875 --> 00:39:54,770
will know what to do with it.

965
00:39:54,770 --> 00:39:56,830
And at that point, it's
out of NaCl's control.

966
00:39:56,830 --> 00:40:00,040
It's just however the JavaScript
call would be.

967
00:40:00,040 --> 00:40:01,290
Same paths.

968
00:40:01,290 --> 00:40:03,430

969
00:40:03,430 --> 00:40:05,630
That is Native Client
in a nutshell.

970
00:40:05,630 --> 00:40:07,310
And I hope you all
followed that.

971
00:40:07,310 --> 00:40:10,640
And we have questions
afterwards, if you don't.

972
00:40:10,640 --> 00:40:12,640
There's more to this.

973
00:40:12,640 --> 00:40:15,190
As I mentioned before, dynamic
code loading in JIT, memory

974
00:40:15,190 --> 00:40:18,180
consistency, making the
sandboxing model work is a

975
00:40:18,180 --> 00:40:19,440
whole other ball of wax.

976
00:40:19,440 --> 00:40:21,090
I find it very fascinating.

977
00:40:21,090 --> 00:40:23,930
I hope you guys look into it.

978
00:40:23,930 --> 00:40:25,630
Portable Native Client.

979
00:40:25,630 --> 00:40:28,070
This is the future.

980
00:40:28,070 --> 00:40:30,497
Bit code, LLVM tool
chain, fixes, the

981
00:40:30,497 --> 00:40:33,040
architecture-specific issues
we have now, but you

982
00:40:33,040 --> 00:40:33,720
still can use it.

983
00:40:33,720 --> 00:40:35,700
You can write applications
now and switch to

984
00:40:35,700 --> 00:40:36,950
PNaCl when it's available.

985
00:40:36,950 --> 00:40:39,130

986
00:40:39,130 --> 00:40:41,230
You may have noticed that
nothing in this presentation

987
00:40:41,230 --> 00:40:43,700
really has to be inside
the browser.

988
00:40:43,700 --> 00:40:46,600
So this is a technical solution,
the sandboxing,

989
00:40:46,600 --> 00:40:48,070
software for the isolation.

990
00:40:48,070 --> 00:40:51,690
There have been some projects
to use the same sandboxing

991
00:40:51,690 --> 00:40:55,080
technology to, for instance, run
computation in the cloud.

992
00:40:55,080 --> 00:40:57,850
Or to just say, you know,
I don't want to audit

993
00:40:57,850 --> 00:40:58,790
this piece of code.

994
00:40:58,790 --> 00:41:02,590
Well, I'll just throw it in the
sandbox, and that way, I

995
00:41:02,590 --> 00:41:04,840
know that the third-party code
is going to be much more

996
00:41:04,840 --> 00:41:08,110
contained than it
would otherwise.

997
00:41:08,110 --> 00:41:09,310
Recommended reading.

998
00:41:09,310 --> 00:41:11,750
So every time we give a NaCl
talk, we point people to

999
00:41:11,750 --> 00:41:12,860
gonacl.com.

1000
00:41:12,860 --> 00:41:16,130
This is a developer-oriented
site, where you download the

1001
00:41:16,130 --> 00:41:20,460
compiler, the SDK tutorials
about how to get you started.

1002
00:41:20,460 --> 00:41:22,910
This talk was a little
technical, more

1003
00:41:22,910 --> 00:41:25,470
research-based, so we have a
bunch of research papers, too.

1004
00:41:25,470 --> 00:41:26,860
I point you towards those.

1005
00:41:26,860 --> 00:41:30,660
If you Google gonacl or Native
Client research papers, you'll

1006
00:41:30,660 --> 00:41:32,180
get these URLs.

1007
00:41:32,180 --> 00:41:34,660
And my favorite one is actually
"A Tale of Two

1008
00:41:34,660 --> 00:41:37,700
Pwnies." So every year
or so, there's a

1009
00:41:37,700 --> 00:41:39,640
browser security contest.

1010
00:41:39,640 --> 00:41:43,350
And this year, Chrome
had two exploits.

1011
00:41:43,350 --> 00:41:46,220
One of them actually touched
NaCl but did not break it.

1012
00:41:46,220 --> 00:41:48,080
So they used NaCl as
an attack platform

1013
00:41:48,080 --> 00:41:49,580
to hit the GPU process.

1014
00:41:49,580 --> 00:41:52,450
And I myself actually learned
a lot from reading this.

1015
00:41:52,450 --> 00:41:55,790
And it's really eye-opening to
see how many layers and levels

1016
00:41:55,790 --> 00:41:58,660
you have to get through to
do a modern exploit.

1017
00:41:58,660 --> 00:42:00,470
The one that involved
NaCl was six.

1018
00:42:00,470 --> 00:42:03,230
The other one was 10 because
they had to chain that many

1019
00:42:03,230 --> 00:42:04,930
different vulnerabilities
together to

1020
00:42:04,930 --> 00:42:06,650
actually get an exploit.

1021
00:42:06,650 --> 00:42:08,780
So security, very interesting
field.

1022
00:42:08,780 --> 00:42:10,562
I strongly suggest you
read that paper.

1023
00:42:10,562 --> 00:42:13,240

1024
00:42:13,240 --> 00:42:14,130
Now the fun part.

1025
00:42:14,130 --> 00:42:15,828
Questions.

1026
00:42:15,828 --> 00:42:28,060
[APPLAUSE]

1027
00:42:28,060 --> 00:42:29,610
AUDIENCE: Thanks for
the presentation.

1028
00:42:29,610 --> 00:42:30,670
NICK BRAY: My pleasure.

1029
00:42:30,670 --> 00:42:32,560
AUDIENCE: Out of all of I/O,
it's probably the most

1030
00:42:32,560 --> 00:42:34,920
interesting, funnest one that
I've ever been to, so that was

1031
00:42:34,920 --> 00:42:35,400
really cool.

1032
00:42:35,400 --> 00:42:38,350
I've known NaCl for about
an hour and a half.

1033
00:42:38,350 --> 00:42:41,830
I was wondering, does it matter
what version of CIUs?

1034
00:42:41,830 --> 00:42:48,350
Does NaCl care whether
it's C99 or C90?

1035
00:42:48,350 --> 00:42:49,790
NICK BRAY: It doesn't even
matter if you use a

1036
00:42:49,790 --> 00:42:51,180
C-compiler.

1037
00:42:51,180 --> 00:42:54,480
So you can actually hand-write
NaCl code, and it'll run.

1038
00:42:54,480 --> 00:42:57,840
But we provide compilers that
generate code that's

1039
00:42:57,840 --> 00:42:58,920
compatible.

1040
00:42:58,920 --> 00:43:02,920
So I think our version
of GCC supports C99.

1041
00:43:02,920 --> 00:43:04,246
Do you know?

1042
00:43:04,246 --> 00:43:06,120
Yeah, I think, so
you can use C99.

1043
00:43:06,120 --> 00:43:09,430
It's whatever GCC supports,
really.

1044
00:43:09,430 --> 00:43:10,650
AUDIENCE: The one question
I had was about

1045
00:43:10,650 --> 00:43:11,950
the indirect jumps.

1046
00:43:11,950 --> 00:43:15,560
And it sounds like you are
relying on the compiler to put

1047
00:43:15,560 --> 00:43:18,180
everything on 32-bit
boundaries.

1048
00:43:18,180 --> 00:43:20,100
That seems to me like the
only position where

1049
00:43:20,100 --> 00:43:21,130
a handwritten exploit--

1050
00:43:21,130 --> 00:43:25,490
I mean, you were assuming that
all the code coming in would

1051
00:43:25,490 --> 00:43:27,170
allow jumps to 32-byte
boundaries.

1052
00:43:27,170 --> 00:43:30,350
But if I were to hand-write some
asm that a jump into a

1053
00:43:30,350 --> 00:43:32,850
32-bit boundary was a actually
a bad execution, how do you

1054
00:43:32,850 --> 00:43:34,320
manage that?

1055
00:43:34,320 --> 00:43:35,430
NICK BRAY: Validation.

1056
00:43:35,430 --> 00:43:38,260
So while we're going through
looking at what the

1057
00:43:38,260 --> 00:43:41,950
instructions are, we record
where they are, too.

1058
00:43:41,950 --> 00:43:45,010
So internally, you can think
that we have a bit factor,

1059
00:43:45,010 --> 00:43:47,200
which contains a bit
for each byte.

1060
00:43:47,200 --> 00:43:49,990
And every time we see an
instruction start, we say,

1061
00:43:49,990 --> 00:43:51,410
boom, there's a bit.

1062
00:43:51,410 --> 00:43:53,580
So whenever we have a
direct jump we say,

1063
00:43:53,580 --> 00:43:54,870
is the bit set there?

1064
00:43:54,870 --> 00:43:56,520
We actually have to do this
after we see all the

1065
00:43:56,520 --> 00:43:57,110
instructions.

1066
00:43:57,110 --> 00:43:59,770
But in the final thing, we go,
OK, here's all the jump

1067
00:43:59,770 --> 00:44:02,000
targets, here's all the
instructions, starts--

1068
00:44:02,000 --> 00:44:02,830
AUDIENCE: But what about
the indirect

1069
00:44:02,830 --> 00:44:05,180
jumps into the 32 byte--

1070
00:44:05,180 --> 00:44:06,850
NICK BRAY: We do that
on the fly.

1071
00:44:06,850 --> 00:44:10,340
So you say, OK, while I'm
parsing this instruction, I

1072
00:44:10,340 --> 00:44:12,740
notice that it's overlapping
the 32-byte boundary.

1073
00:44:12,740 --> 00:44:13,300
Boom, that's bad.

1074
00:44:13,300 --> 00:44:14,810
AUDIENCE: OK.

1075
00:44:14,810 --> 00:44:18,030
So you also make sure that all
32-byte boundary instructions,

1076
00:44:18,030 --> 00:44:20,350
whatever is at a 32-byte
boundary is also safe.

1077
00:44:20,350 --> 00:44:21,600
NICK BRAY: Yes.

1078
00:44:21,600 --> 00:44:23,910

1079
00:44:23,910 --> 00:44:26,300
AUDIENCE: So it looks like
you're creating a 4-gig memory

1080
00:44:26,300 --> 00:44:26,950
limit again.

1081
00:44:26,950 --> 00:44:30,410
Didn't we just get
rid of that?

1082
00:44:30,410 --> 00:44:33,430
NICK BRAY: It depends on
how you look at it.

1083
00:44:33,430 --> 00:44:35,740
So there's all sorts
of devices.

1084
00:44:35,740 --> 00:44:37,740
But what you're really saying
is, can I get more

1085
00:44:37,740 --> 00:44:39,690
than 4 gigs of memory?

1086
00:44:39,690 --> 00:44:42,400
And the answer is we could
change the sandboxing model,

1087
00:44:42,400 --> 00:44:44,570
but there would be performance
implications.

1088
00:44:44,570 --> 00:44:47,260
So a lot of the clever things
we were doing with dropping

1089
00:44:47,260 --> 00:44:49,710
the upper 32 bits, suddenly
you're carting

1090
00:44:49,710 --> 00:44:52,060
around 8-byte constants.

1091
00:44:52,060 --> 00:44:54,680
And that's a generally
bad thing.

1092
00:44:54,680 --> 00:44:56,440
So has it been a problem?

1093
00:44:56,440 --> 00:44:58,810
And the answer is, we haven't
really had any developers

1094
00:44:58,810 --> 00:45:00,220
complain about it.

1095
00:45:00,220 --> 00:45:03,470
We've been living under the
4-gig limit so long, that it's

1096
00:45:03,470 --> 00:45:04,970
not been an issue.

1097
00:45:04,970 --> 00:45:07,010
Plus do you really want an
application in your web

1098
00:45:07,010 --> 00:45:09,000
browser consuming that
much memory?

1099
00:45:09,000 --> 00:45:10,270
Eh, most the time, not.

1100
00:45:10,270 --> 00:45:11,984
There are some applications
that you write that

1101
00:45:11,984 --> 00:45:12,300
you may want to.

1102
00:45:12,300 --> 00:45:14,070
AUDIENCE: In five years,
certainly?

1103
00:45:14,070 --> 00:45:15,670
NICK BRAY: Yeah.

1104
00:45:15,670 --> 00:45:18,040
So sandboxing models
are flexible.

1105
00:45:18,040 --> 00:45:21,590
And once we get PNaCl running,
we can take another look at

1106
00:45:21,590 --> 00:45:23,778
generating a new sandboxing
model or

1107
00:45:23,778 --> 00:45:26,400
something along those lines.

1108
00:45:26,400 --> 00:45:28,940
AUDIENCE: Kind of a
related question.

1109
00:45:28,940 --> 00:45:34,720
You, at the beginning, showed
x64, x86, and ARM.

1110
00:45:34,720 --> 00:45:37,930
On x86, you obviously can't
do the same kind of jump

1111
00:45:37,930 --> 00:45:40,310
constraint because you are--

1112
00:45:40,310 --> 00:45:44,090
if you're on 32-bit x86,
you're then limited.

1113
00:45:44,090 --> 00:45:47,790
You're going to reduce your
memory space by far more and

1114
00:45:47,790 --> 00:45:49,950
lose a very precious register.

1115
00:45:49,950 --> 00:45:51,390
NICK BRAY: One gig.

1116
00:45:51,390 --> 00:45:53,800
And you don't lose precious
registers.

1117
00:45:53,800 --> 00:45:57,660
We do something very perverse
on 32-bit Intel.

1118
00:45:57,660 --> 00:45:59,410
We use segment registers.

1119
00:45:59,410 --> 00:46:01,530
So we're bringing back all
these things that you

1120
00:46:01,530 --> 00:46:01,830
thought were dead.

1121
00:46:01,830 --> 00:46:03,545
AUDIENCE: Awesome.

1122
00:46:03,545 --> 00:46:05,350
NICK BRAY: So, for those of you
who don't know, segment

1123
00:46:05,350 --> 00:46:08,680
registers say this is the range
of memory you can use.

1124
00:46:08,680 --> 00:46:13,980
So we say, OK, 256 megs for
code, 1 gig for data.

1125
00:46:13,980 --> 00:46:16,500
If you jump outside
this, boom.

1126
00:46:16,500 --> 00:46:19,020
And then we say you can't change
the segment registers

1127
00:46:19,020 --> 00:46:20,120
while you're running.

1128
00:46:20,120 --> 00:46:22,900
This has a few weird
implications, like most people

1129
00:46:22,900 --> 00:46:23,920
thought they were dead.

1130
00:46:23,920 --> 00:46:27,180
So the Intel atom processor
for instance, they didn't

1131
00:46:27,180 --> 00:46:28,990
spend so much time supporting
segment registers.

1132
00:46:28,990 --> 00:46:31,630
They do lip service, but then
when you actually use them in

1133
00:46:31,630 --> 00:46:34,520
nonstandard ways, it
slows down a lot.

1134
00:46:34,520 --> 00:46:36,500
AUDIENCE: Thanks.

1135
00:46:36,500 --> 00:46:37,240
AUDIENCE: Hi.

1136
00:46:37,240 --> 00:46:38,100
It's a great project.

1137
00:46:38,100 --> 00:46:40,090
I love it.

1138
00:46:40,090 --> 00:46:43,380
It is very perverse though, in
some ways, as you're going

1139
00:46:43,380 --> 00:46:45,460
through all of these things.

1140
00:46:45,460 --> 00:46:51,060
I was just wondering, with the
LLVM thing that you're going

1141
00:46:51,060 --> 00:46:54,420
to be doing, does it get easier
now that you control

1142
00:46:54,420 --> 00:46:55,570
the instruction set?

1143
00:46:55,570 --> 00:46:58,190
I mean, can you somehow do
something to make this whole

1144
00:46:58,190 --> 00:47:00,470
process simpler?

1145
00:47:00,470 --> 00:47:02,980
NICK BRAY: Define the "whole
process simpler."

1146
00:47:02,980 --> 00:47:04,300
AUDIENCE: The verification
process.

1147
00:47:04,300 --> 00:47:09,900
I mean, since you control the
intermediate format, is there

1148
00:47:09,900 --> 00:47:12,760
some way to--

1149
00:47:12,760 --> 00:47:16,460
will it become simpler when
you get to the LLVM model?

1150
00:47:16,460 --> 00:47:17,480
NICK BRAY: The big problem
is that we

1151
00:47:17,480 --> 00:47:19,620
can't trust the compiler.

1152
00:47:19,620 --> 00:47:21,110
So we can't audit it.

1153
00:47:21,110 --> 00:47:23,120
We can't verify that it's--

1154
00:47:23,120 --> 00:47:25,240
you know, it should generate
the code we want.

1155
00:47:25,240 --> 00:47:27,630
But at the end of the day, what
we do is, we have to have

1156
00:47:27,630 --> 00:47:29,810
validation be the last
line of defense.

1157
00:47:29,810 --> 00:47:32,860
So if the code doesn't look
safe, we don't run it.

1158
00:47:32,860 --> 00:47:36,500
And we make no assumptions
about its providence.

1159
00:47:36,500 --> 00:47:42,000
So what LLVM would allow us to
do is do more creative things.

1160
00:47:42,000 --> 00:47:44,460
Right now, the binary that's
shipped across the wire is

1161
00:47:44,460 --> 00:47:46,830
something that we've stabilized
and we said this is

1162
00:47:46,830 --> 00:47:48,610
what we're going to support.

1163
00:47:48,610 --> 00:47:50,880
Once we start supporting bit
code, then we can generate

1164
00:47:50,880 --> 00:47:52,340
other sandboxing models.

1165
00:47:52,340 --> 00:47:54,940
We can generate other
interesting low-level things.

1166
00:47:54,940 --> 00:47:57,690
And it decouples us and gives
us a lot of flexibility.

1167
00:47:57,690 --> 00:48:00,040
But at the bottom level, there's
going to have to be

1168
00:48:00,040 --> 00:48:03,010
some algorithm that goes through
and says does this

1169
00:48:03,010 --> 00:48:04,690
native code look right?

1170
00:48:04,690 --> 00:48:06,620
And if it doesn't,
out of there.

1171
00:48:06,620 --> 00:48:08,320
And once LLVM's in
the picture, it

1172
00:48:08,320 --> 00:48:10,070
should always look right.

1173
00:48:10,070 --> 00:48:11,410
But we are going to
bank on that.

1174
00:48:11,410 --> 00:48:12,810
We're going to always
have the last line.

1175
00:48:12,810 --> 00:48:15,790
AUDIENCE: Will the bit code be
actual LLVM byte code, or will

1176
00:48:15,790 --> 00:48:19,250
you have something of
your own nature?

1177
00:48:19,250 --> 00:48:21,790
NICK BRAY: I think the plan
is actual LLVM byte code.

1178
00:48:21,790 --> 00:48:25,050

1179
00:48:25,050 --> 00:48:28,057
AUDIENCE: That was actually very
similar to the question I

1180
00:48:28,057 --> 00:48:29,360
was going to ask.

1181
00:48:29,360 --> 00:48:32,705
When you're going through the
initial design for NaCl, why

1182
00:48:32,705 --> 00:48:38,042
did you choose native code
versus LLVM or comparing it to

1183
00:48:38,042 --> 00:48:40,630
the JVMs and what they do?

1184
00:48:40,630 --> 00:48:42,100
NICK BRAY: Why choose
native code instead

1185
00:48:42,100 --> 00:48:45,340
of everything else?

1186
00:48:45,340 --> 00:48:48,360
AUDIENCE: Was it to have a
simpler just run- time

1187
00:48:48,360 --> 00:48:51,030
environment, not have to
have an actual JIT?

1188
00:48:51,030 --> 00:48:52,280
NICK BRAY: Yep.

1189
00:48:52,280 --> 00:48:54,060

1190
00:48:54,060 --> 00:48:57,340
Part of the view was
compatibility, because we have

1191
00:48:57,340 --> 00:48:59,470
a lot of infrastructure
for native code.

1192
00:48:59,470 --> 00:49:02,150
So if we're just running native
code, a lot of that

1193
00:49:02,150 --> 00:49:06,160
should be analogous, fairly
straightforward.

1194
00:49:06,160 --> 00:49:07,980
Less overhead.

1195
00:49:07,980 --> 00:49:09,700
You can access certain
intrinsic

1196
00:49:09,700 --> 00:49:11,350
instructions directly.

1197
00:49:11,350 --> 00:49:12,570
You can do threads.

1198
00:49:12,570 --> 00:49:15,250
You don't have to solve
all these ugly

1199
00:49:15,250 --> 00:49:16,940
issues at the VM level.

1200
00:49:16,940 --> 00:49:20,130
Instead, you can just validate
it and let it rip instead of

1201
00:49:20,130 --> 00:49:22,730
trying to have a larger surface
area, which you are

1202
00:49:22,730 --> 00:49:25,270
trying to prove is safe.

1203
00:49:25,270 --> 00:49:28,230
Part of it was also
a technical issue.

1204
00:49:28,230 --> 00:49:30,280
We realized, hey,
we CAN do this.

1205
00:49:30,280 --> 00:49:32,630
So how can we bring
it to the web?

1206
00:49:32,630 --> 00:49:34,750
So we finally realized
native code

1207
00:49:34,750 --> 00:49:36,420
doesn't have to be unsafe.

1208
00:49:36,420 --> 00:49:38,060
And what are the
opportunities?

1209
00:49:38,060 --> 00:49:39,170
So we've been seeing
a lot of people

1210
00:49:39,170 --> 00:49:40,590
port games, for instance.

1211
00:49:40,590 --> 00:49:43,250
And when you spend how many
years writing native code, and

1212
00:49:43,250 --> 00:49:46,510
you want to port it, well, you
don't want to jump through too

1213
00:49:46,510 --> 00:49:47,920
many hoops.

1214
00:49:47,920 --> 00:49:51,520
You can try to do weird cross
compiles into JavaScript VMs,

1215
00:49:51,520 --> 00:49:54,640
but, it works some
of the time.

1216
00:49:54,640 --> 00:49:57,630
Instead, why don't you just run
the native code, and call

1217
00:49:57,630 --> 00:49:59,520
the browser instead of the OS.

1218
00:49:59,520 --> 00:50:01,400
That's the general philosophy,
is trying to keep the surface

1219
00:50:01,400 --> 00:50:05,090
area small and trying to make
it as close to other native

1220
00:50:05,090 --> 00:50:07,680
code development as possible.

1221
00:50:07,680 --> 00:50:08,130
AUDIENCE: Cool.

1222
00:50:08,130 --> 00:50:09,630
Thanks.

1223
00:50:09,630 --> 00:50:10,560
AUDIENCE: I've got
two questions.

1224
00:50:10,560 --> 00:50:12,790
I think they're both small.

1225
00:50:12,790 --> 00:50:14,940
Trampolines got me thinking.

1226
00:50:14,940 --> 00:50:17,840
Do you have any dev tools that
would de-bug what's going on,

1227
00:50:17,840 --> 00:50:20,330
so that you can see in the
inspector that, OK, it's

1228
00:50:20,330 --> 00:50:23,600
making it HTTP requests
and so on?

1229
00:50:23,600 --> 00:50:25,500
NICK BRAY: De-buggers are
something we're working on.

1230
00:50:25,500 --> 00:50:27,320
They're harder than
you'd expect.

1231
00:50:27,320 --> 00:50:30,420
Because they've made many silly
assumptions that native

1232
00:50:30,420 --> 00:50:33,180
code just happens to work the
way native code does.

1233
00:50:33,180 --> 00:50:36,300
So the moment we start adding
this R15 register to offset

1234
00:50:36,300 --> 00:50:39,500
everything, there's been a lot
of work to try to get the

1235
00:50:39,500 --> 00:50:40,750
de-buggers to get all
the right symbols.

1236
00:50:40,750 --> 00:50:42,530
AUDIENCE: I'm thinking on a much
higher level actually.

1237
00:50:42,530 --> 00:50:45,220
If you're coming as a web
developer looking at things in

1238
00:50:45,220 --> 00:50:47,780
the inspector, what's going
on in this web page?

1239
00:50:47,780 --> 00:50:49,180
What is it doing?

1240
00:50:49,180 --> 00:50:53,080
Can I see what stuff is it
requesting on the web?

1241
00:50:53,080 --> 00:50:56,650
NICK BRAY: At the moment,
half and half.

1242
00:50:56,650 --> 00:50:59,970
So whenever you're doing
a Pepper call, that

1243
00:50:59,970 --> 00:51:00,930
usually gets traced.

1244
00:51:00,930 --> 00:51:05,570
So every time you see a URL
load, Chrome has the console

1245
00:51:05,570 --> 00:51:06,900
of all network activity.

1246
00:51:06,900 --> 00:51:08,080
And it will get logged
in that.

1247
00:51:08,080 --> 00:51:10,470
So you're mediating through
the browser, so all the

1248
00:51:10,470 --> 00:51:11,820
instrumentation the
browser has.

1249
00:51:11,820 --> 00:51:14,275
What's actually going on inside
the native process is a

1250
00:51:14,275 --> 00:51:16,200
little more opaque than I'd
like at this point.

1251
00:51:16,200 --> 00:51:19,880
And we're thinking about ways
to expose health and metrics

1252
00:51:19,880 --> 00:51:21,450
and pull that out
of the process.

1253
00:51:21,450 --> 00:51:22,560
AUDIENCE: That's awesome.

1254
00:51:22,560 --> 00:51:25,410
The second question is, so
you're defending against all

1255
00:51:25,410 --> 00:51:28,090
these things that are unsafe
from the system's perspective.

1256
00:51:28,090 --> 00:51:32,150
But are you having any checks
and bounds on stuff that's

1257
00:51:32,150 --> 00:51:35,800
causing infinite loops that
just eat the CPU?

1258
00:51:35,800 --> 00:51:36,510
That kind of stuff.

1259
00:51:36,510 --> 00:51:36,800
NICK BRAY: Nope.

1260
00:51:36,800 --> 00:51:39,220
AUDIENCE: OK.

1261
00:51:39,220 --> 00:51:41,640
Thanks.

1262
00:51:41,640 --> 00:51:43,820
AUDIENCE: This is similar to
the question before last.

1263
00:51:43,820 --> 00:51:47,270
Once you move into the LLVM
world and you're sending

1264
00:51:47,270 --> 00:51:50,290
basically Virtual Machine
instructions and calling a

1265
00:51:50,290 --> 00:51:54,660
limited API, how would you say
that PNaCl would compare to

1266
00:51:54,660 --> 00:51:58,390
Java or dot-net?

1267
00:51:58,390 --> 00:52:02,560
NICK BRAY: One thing about LLVM
is it's a bit misnamed.

1268
00:52:02,560 --> 00:52:05,230
So the Virtual Machine
name came

1269
00:52:05,230 --> 00:52:07,290
earlier in its life cycle.

1270
00:52:07,290 --> 00:52:10,270
And it's more a compiler
IR than it is,

1271
00:52:10,270 --> 00:52:12,270
strictly speaking, a VM.

1272
00:52:12,270 --> 00:52:13,990
There's some
architecture-specific things

1273
00:52:13,990 --> 00:52:16,640
that have got leaked into it,
which have had to be hammered

1274
00:52:16,640 --> 00:52:19,420
out in order to use it as
an interchange format.

1275
00:52:19,420 --> 00:52:22,800
So how would byte code
compare against VMs?

1276
00:52:22,800 --> 00:52:26,480

1277
00:52:26,480 --> 00:52:28,380
It's an interesting question.

1278
00:52:28,380 --> 00:52:30,530
I think the only real answer
I would add to

1279
00:52:30,530 --> 00:52:32,430
that is surface area.

1280
00:52:32,430 --> 00:52:36,260
Securing a VM is going to be
much harder than validating

1281
00:52:36,260 --> 00:52:38,780
native code and just use
the model that's there.

1282
00:52:38,780 --> 00:52:41,550
And the VM will likely be
slower, give or take

1283
00:52:41,550 --> 00:52:45,520
just-in-time compilers,
how well those do.

1284
00:52:45,520 --> 00:52:49,330
AUDIENCE: So does the validator
in PNaCl work on

1285
00:52:49,330 --> 00:52:50,110
native code still?

1286
00:52:50,110 --> 00:52:53,280
Or is it still validating
LLVM code?

1287
00:52:53,280 --> 00:52:56,010
NICK BRAY: We validate all
native code before we run it.

1288
00:52:56,010 --> 00:53:00,170
So PNaCl you can think of as
largely a translator, which is

1289
00:53:00,170 --> 00:53:02,330
I'm going to take this bit
code, then turn it into

1290
00:53:02,330 --> 00:53:04,460
machine code.

1291
00:53:04,460 --> 00:53:05,960
And then we pass it off
to the validator.

1292
00:53:05,960 --> 00:53:08,490
The validator says, OK, you
did your job right.

1293
00:53:08,490 --> 00:53:10,540
You're good to go.

1294
00:53:10,540 --> 00:53:11,790
AUDIENCE: Thanks.

1295
00:53:11,790 --> 00:53:17,120

1296
00:53:17,120 --> 00:53:19,960
AUDIENCE: Have you done any
benchmarking on the difference

1297
00:53:19,960 --> 00:53:24,820
between the unmodified code
that you do, like adding

1298
00:53:24,820 --> 00:53:27,620
padding and replacing things
with pseudo-instructions,

1299
00:53:27,620 --> 00:53:30,380
versus the modified version?

1300
00:53:30,380 --> 00:53:31,160
NICK BRAY: Yes.

1301
00:53:31,160 --> 00:53:34,640
AUDIENCE: And what
are the results?

1302
00:53:34,640 --> 00:53:35,910
NICK BRAY: It depends.

1303
00:53:35,910 --> 00:53:37,470
Also, one of these
horrible answers.

1304
00:53:37,470 --> 00:53:38,710
I'm not trying to weasel
out, but the

1305
00:53:38,710 --> 00:53:40,780
truth is, it does depend.

1306
00:53:40,780 --> 00:53:43,900
So if you're doing a numerical
application, for instance,

1307
00:53:43,900 --> 00:53:46,180
you're not going to have
a lot of jumps.

1308
00:53:46,180 --> 00:53:47,360
You're not going to have
a lot of calls.

1309
00:53:47,360 --> 00:53:49,460
So you can usually rip through
those instructions.

1310
00:53:49,460 --> 00:53:51,790
But certain benchmarks which are
doing indirect jumps all

1311
00:53:51,790 --> 00:53:55,220
over the place, you're going
to get no-op padding.

1312
00:53:55,220 --> 00:53:57,750
You're going to get a bunch
of guard instructions.

1313
00:53:57,750 --> 00:54:00,370
And on 32-bit, because we're
using segment registers, it's

1314
00:54:00,370 --> 00:54:01,600
actually more efficient.

1315
00:54:01,600 --> 00:54:06,190
So I think on 32-bit, it's like
10 20% slowdown compared

1316
00:54:06,190 --> 00:54:07,960
to full native speed.

1317
00:54:07,960 --> 00:54:11,630
On 64-bit, our guard sequences
are a little more complex.

1318
00:54:11,630 --> 00:54:13,110
They take up more bytes,
a few more

1319
00:54:13,110 --> 00:54:14,610
instructions here and there.

1320
00:54:14,610 --> 00:54:17,520
And I'm not exactly sure what
the benchmarks are.

1321
00:54:17,520 --> 00:54:21,680
Again, I say rule of thumb,
20%, although on some

1322
00:54:21,680 --> 00:54:25,510
degenerate benchmarks, it's down
40, 50% just because of

1323
00:54:25,510 --> 00:54:27,560
the way the code works out.

1324
00:54:27,560 --> 00:54:30,540
Again, the answer is that, no
one's complained yet either.

1325
00:54:30,540 --> 00:54:32,909
So it works as intended.

1326
00:54:32,909 --> 00:54:34,159
AUDIENCE: Thanks.

1327
00:54:34,159 --> 00:54:37,310

1328
00:54:37,310 --> 00:54:39,730
AUDIENCE: Another
PNaCl question.

1329
00:54:39,730 --> 00:54:45,590
Since you're going to have
LLVM living in PNaCl to

1330
00:54:45,590 --> 00:54:48,440
generate the instructions, you
mentioned earlier that you can

1331
00:54:48,440 --> 00:54:52,345
still do JITs in
Native Client.

1332
00:54:52,345 --> 00:54:55,610
I'm thinking about some ways
in which you could do that.

1333
00:54:55,610 --> 00:55:00,420
Are you going to expose
the LLVM translator to

1334
00:55:00,420 --> 00:55:03,400
applications so they can just
use that instead of having

1335
00:55:03,400 --> 00:55:06,850
another copy of LLVM inside
to do JIT-ing?

1336
00:55:06,850 --> 00:55:07,600
NICK BRAY: Interesting
question.

1337
00:55:07,600 --> 00:55:09,680
Very interesting question that
I can't answer, because I'm

1338
00:55:09,680 --> 00:55:11,500
not working on the
PNaCl project.

1339
00:55:11,500 --> 00:55:12,730
So what they're working
on there.

1340
00:55:12,730 --> 00:55:15,120
But you can imagine all the
complexities of, well, since

1341
00:55:15,120 --> 00:55:18,880
we can't trust the translator,
how do we fit it in so we can

1342
00:55:18,880 --> 00:55:20,790
run it in an untrusted
capacity.

1343
00:55:20,790 --> 00:55:24,370
So one neat thing I didn't
mention is that the actual

1344
00:55:24,370 --> 00:55:27,250
ahead-of-time time translator
is implemented inside of

1345
00:55:27,250 --> 00:55:29,060
Native Client.

1346
00:55:29,060 --> 00:55:31,860
So we have the LLVM compiler
running inside the Native

1347
00:55:31,860 --> 00:55:35,200
Client sandbox to produce code
that then we run inside the

1348
00:55:35,200 --> 00:55:38,260
Native Client sandbox.

1349
00:55:38,260 --> 00:55:39,510
AUDIENCE: Thanks.

1350
00:55:39,510 --> 00:55:46,690

1351
00:55:46,690 --> 00:55:48,660
NICK BRAY: Standard technique
for presentations is wait a

1352
00:55:48,660 --> 00:55:49,820
few seconds.

1353
00:55:49,820 --> 00:55:52,085
Usually someone gets
uncomfortable, stands up, and

1354
00:55:52,085 --> 00:55:54,995
ask another question.

1355
00:55:54,995 --> 00:55:57,920
If that doesn't work, then you
say, OK, thanks for coming.

1356
00:55:57,920 --> 00:56:01,193

