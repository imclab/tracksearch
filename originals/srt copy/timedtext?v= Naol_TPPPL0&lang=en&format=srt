1
00:00:01,167 --> 00:00:03,067
Fisher: Gonna talk to you
about Chrome internals.

2
00:00:03,067 --> 00:00:05,200
So I'm Darin Fisher.

3
00:00:05,200 --> 00:00:06,701
I'm a member
of the Chrome team.

4
00:00:06,701 --> 00:00:08,534
I've actually been with
the project since inception,

5
00:00:08,534 --> 00:00:10,734
back in 2006.

6
00:00:10,734 --> 00:00:12,601
And today is just
an opportunity to go through

7
00:00:12,601 --> 00:00:16,334
all of the stuff that's
underneath the hood.

8
00:00:16,334 --> 00:00:18,467
And so there'll be things
that you may

9
00:00:18,467 --> 00:00:20,434
have heard about before
if you've read the comic.

10
00:00:20,434 --> 00:00:22,100
But, you know,
I just wanted to cover

11
00:00:22,100 --> 00:00:23,400
as much ground as I could

12
00:00:23,400 --> 00:00:25,334
and discuss
all the different things

13
00:00:25,334 --> 00:00:29,000
that go into
Chrome's architecture.

14
00:00:29,000 --> 00:00:32,067
So this was our guiding
principle from day one.

15
00:00:32,067 --> 00:00:33,701
We really wanted
to make sure

16
00:00:33,701 --> 00:00:36,701
that we were stressing a very
simple interface to Chrome.

17
00:00:36,701 --> 00:00:40,067
And, you know,
that would allow people

18
00:00:40,067 --> 00:00:41,767
to very easily and naturally

19
00:00:41,767 --> 00:00:44,267
get to a very fast browser,
a very powerful browser,

20
00:00:44,267 --> 00:00:46,334
leveraging this, you know,
powerful architecture,

21
00:00:46,334 --> 00:00:48,000
but they don't see
or be burdened

22
00:00:48,000 --> 00:00:50,234
by the architecture.

23
00:00:50,234 --> 00:00:53,133
This sort of reminded us

24
00:00:53,133 --> 00:00:56,234
of the way Google.com's
search experience was,

25
00:00:56,234 --> 00:00:59,100
and so here's just
a little image of Chrome,

26
00:00:59,100 --> 00:01:00,934
very simple Chrome
that you've all seen

27
00:01:00,934 --> 00:01:02,267
in a little photo of--

28
00:01:02,267 --> 00:01:03,934
taken off of
one of the design docs of--

29
00:01:03,934 --> 00:01:07,067
for Chrome's architecture.

30
00:01:07,067 --> 00:01:09,234
Just a little aside,

31
00:01:09,234 --> 00:01:12,467
this is actually rendered
using HTML.

32
00:01:12,467 --> 00:01:14,501
Actually thought I would
just quickly show this,

33
00:01:14,501 --> 00:01:16,133
because it's interesting.

34
00:01:16,133 --> 00:01:18,167
It's using
a WebKit gradient effect

35
00:01:18,167 --> 00:01:20,200
on a straight-off image.

36
00:01:20,200 --> 00:01:23,300
So it's kind of neat

37
00:01:23,300 --> 00:01:26,334
that you can do all this
kinds of stuff in WebKit,

38
00:01:26,334 --> 00:01:30,434
which Chrome is based on.

39
00:01:30,434 --> 00:01:32,934
Okay, so here's
a little quote

40
00:01:32,934 --> 00:01:34,901
that I'm not really sure
who to attribute it to,

41
00:01:34,901 --> 00:01:37,100
but back in 2006
it was something

42
00:01:37,100 --> 00:01:38,868
that we were all thinking
about it at the time.

43
00:01:38,868 --> 00:01:40,567
"Modern browsers
really resemble

44
00:01:40,567 --> 00:01:43,300
co-operatively multi-tasked
operating systems of the past."

45
00:01:43,300 --> 00:01:44,701
So what do I mean?

46
00:01:44,701 --> 00:01:47,934
You can think back to
older versions of Windows,

47
00:01:47,934 --> 00:01:51,234
older versions of Mac OS,
where if any process,

48
00:01:51,234 --> 00:01:53,734
any application
on your system

49
00:01:53,734 --> 00:01:56,901
decided to go into
an infinite loop or crashed,

50
00:01:56,901 --> 00:01:58,667
it could bring down your
whole entire operating system,

51
00:01:58,667 --> 00:02:00,501
and you'd lose
all your applications.

52
00:02:00,501 --> 00:02:04,367
And this was what the state
of browsers were back then.

53
00:02:04,367 --> 00:02:06,300
And it seemed
very unfortunate,

54
00:02:06,300 --> 00:02:08,334
especially as web applications
were getting larger

55
00:02:08,334 --> 00:02:09,667
and more complicated.

56
00:02:09,667 --> 00:02:11,501
I mean, oftentimes
you'd have the experience

57
00:02:11,501 --> 00:02:15,501
of going--composing an e-mail
and suddenly deciding,

58
00:02:15,501 --> 00:02:16,734
you know, I want
to go do a search,

59
00:02:16,734 --> 00:02:18,200
I want to go do something else,

60
00:02:18,200 --> 00:02:20,567
and branching off
to go get some information

61
00:02:20,567 --> 00:02:22,968
and venturing to a website
that maybe somehow

62
00:02:22,968 --> 00:02:24,968
unfortunately triggers
a browser bug,

63
00:02:24,968 --> 00:02:27,267
and then you completely lose
what you were working on

64
00:02:27,267 --> 00:02:28,701
in that other tab.

65
00:02:28,701 --> 00:02:30,701
This just seemed like a very
unfortunate situation to us,

66
00:02:30,701 --> 00:02:32,167
and we were just thinking,
you know,

67
00:02:32,167 --> 00:02:33,667
modern operating systems
solved this

68
00:02:33,667 --> 00:02:36,968
by separation of applications
into different processes.

69
00:02:36,968 --> 00:02:40,200
So couldn't we exploit that?

70
00:02:40,200 --> 00:02:42,300
And the goals of--

71
00:02:42,300 --> 00:02:44,934
Speaking more about goals
for Chrome back in the day,

72
00:02:44,934 --> 00:02:47,501
beyond just a simple interface,
we really wanted to see

73
00:02:47,501 --> 00:02:49,100
what we could do
to really move the bar

74
00:02:49,100 --> 00:02:51,267
in terms of speed,
stability, and security.

75
00:02:51,267 --> 00:02:54,000
We felt like, as applications
were getting more complicated,

76
00:02:54,000 --> 00:02:56,133
you know,
speed was very important.

77
00:02:56,133 --> 00:02:57,901
As applications
were getting more complicated,

78
00:02:57,901 --> 00:03:00,367
it was more likely that you
could have instability issues

79
00:03:00,367 --> 00:03:01,701
causing problems,

80
00:03:01,701 --> 00:03:03,167
and so how could we solve
all these problems?

81
00:03:03,167 --> 00:03:05,634
Again, multi-process
architecture.

82
00:03:05,634 --> 00:03:07,534
If we could divide
the application

83
00:03:07,534 --> 00:03:09,100
over multiple processes,
you know,

84
00:03:09,100 --> 00:03:11,067
it'd be great
if you could have web apps

85
00:03:11,067 --> 00:03:12,701
each having their own thread,
and you get this

86
00:03:12,701 --> 00:03:14,334
if each web app
has its own process.

87
00:03:14,334 --> 00:03:15,868
Separate address spaces.

88
00:03:15,868 --> 00:03:18,434
If each web application
has its own address space,

89
00:03:18,434 --> 00:03:20,801
its own process,
then there's some insulation

90
00:03:20,801 --> 00:03:23,667
in case one of the applications
happens to trigger a bug

91
00:03:23,667 --> 00:03:25,100
and cause a crash.

92
00:03:25,100 --> 00:03:28,234
Similarly, if your applications
are consuming a lot of memory

93
00:03:28,234 --> 00:03:31,367
and they're all sharing
one giant heap together,

94
00:03:31,367 --> 00:03:33,167
you can have
performance problems.

95
00:03:33,167 --> 00:03:35,767
But with separate app processes
and separate address spaces,

96
00:03:35,767 --> 00:03:37,467
each one having
its own memory pools,

97
00:03:37,467 --> 00:03:38,868
you have a lot
of smaller memory pools,

98
00:03:38,868 --> 00:03:40,701
and better performance ensues.

99
00:03:40,701 --> 00:03:42,067
Security.

100
00:03:42,067 --> 00:03:44,767
So given that we were
actually leveraging

101
00:03:44,767 --> 00:03:46,234
operating system processes,

102
00:03:46,234 --> 00:03:48,567
and operating systems
already have the idea

103
00:03:48,567 --> 00:03:52,300
that a process might have
certain capabilities

104
00:03:52,300 --> 00:03:55,634
based on the use
associated with that process.

105
00:03:55,634 --> 00:03:59,701
Seems like we could leverage
the operating system's support

106
00:03:59,701 --> 00:04:02,067
for taking away privileges
from a process

107
00:04:02,067 --> 00:04:04,067
or limiting the privileges
of a process,

108
00:04:04,067 --> 00:04:07,834
and thereby achieve a sandbox
to run web applications.

109
00:04:07,834 --> 00:04:10,767
And this would be great
because, well,

110
00:04:10,767 --> 00:04:13,501
we know that software
is just enormously complicated.

111
00:04:13,501 --> 00:04:15,334
And if there's
any kind of bug,

112
00:04:15,334 --> 00:04:17,968
and that bug
allows an attacker

113
00:04:17,968 --> 00:04:21,367
to get code running with
the privileges of the user,

114
00:04:21,367 --> 00:04:22,968
then they can do things

115
00:04:22,968 --> 00:04:24,467
that would potentially
harm the user,

116
00:04:24,467 --> 00:04:25,968
'cause they have
the power of the user.

117
00:04:25,968 --> 00:04:27,300
And so we really
liked the idea

118
00:04:27,300 --> 00:04:29,200
of there being
this belt and suspenders,

119
00:04:29,200 --> 00:04:32,067
this secondary level
of protection, the sandbox.

120
00:04:32,067 --> 00:04:34,000
And we get all this,
it's all possible

121
00:04:34,000 --> 00:04:36,734
because we can divide
the application, the browser

122
00:04:36,734 --> 00:04:38,901
into multiple processes.

123
00:04:38,901 --> 00:04:40,834
Okay, but I mentioned before
speed.

124
00:04:40,834 --> 00:04:42,300
Speed is very important.

125
00:04:42,300 --> 00:04:44,667
And so in the early days
we were thinking

126
00:04:44,667 --> 00:04:46,968
it's one thing
to divide the browser

127
00:04:46,968 --> 00:04:48,434
into multiple processes,

128
00:04:48,434 --> 00:04:49,968
and that allows
the applications

129
00:04:49,968 --> 00:04:51,200
to not stomp on one another

130
00:04:51,200 --> 00:04:52,534
and to achieve
good performance there,

131
00:04:52,534 --> 00:04:54,100
good scaling
across multiple cores.

132
00:04:54,100 --> 00:04:56,100
But we just want
the rendering engine

133
00:04:56,100 --> 00:04:57,934
to be very fast as well.

134
00:04:57,934 --> 00:05:00,000
So that informed our choice
of rendering engine,

135
00:05:00,000 --> 00:05:03,467
and we went with WebKit
because it was, well--

136
00:05:03,467 --> 00:05:04,734
We really wanted to--

137
00:05:04,734 --> 00:05:06,467
We knew that Chrome
was going to be open source,

138
00:05:06,467 --> 00:05:08,267
and we chose upon--

139
00:05:08,267 --> 00:05:10,834
took a look at all
the open source options

140
00:05:10,834 --> 00:05:12,901
and WebKit was just
really fast,

141
00:05:12,901 --> 00:05:14,567
and it has
a very small footprint.

142
00:05:14,567 --> 00:05:16,400
Back in '06,
you could see that WebKit

143
00:05:16,400 --> 00:05:18,033
was starting to become
the popular choice

144
00:05:18,033 --> 00:05:19,634
amongst mobile browsers.

145
00:05:19,634 --> 00:05:21,100
And this all had to do
with, you know,

146
00:05:21,100 --> 00:05:22,367
just how good WebKit is.

147
00:05:22,367 --> 00:05:23,834
But there was one thing
that we saw

148
00:05:23,834 --> 00:05:25,033
as a big opportunity,

149
00:05:25,033 --> 00:05:26,834
and that was
JavaScript performance.

150
00:05:26,834 --> 00:05:29,000
Back in '06, the JavaScript
engine in WebKit

151
00:05:29,000 --> 00:05:32,167
was a very straightforward,
simple interpreted

152
00:05:32,167 --> 00:05:33,801
JavaScript engine.

153
00:05:33,801 --> 00:05:37,133
And we had a team at Google
who recognized

154
00:05:37,133 --> 00:05:38,634
that there was
this great opportunity

155
00:05:38,634 --> 00:05:40,234
to apply some of
the more modern approaches

156
00:05:40,234 --> 00:05:44,000
to BM technology, BMs,
to build a JavaScript engine

157
00:05:44,000 --> 00:05:45,968
that was GIT-based

158
00:05:45,968 --> 00:05:48,534
and leveraged a lot
of other techniques

159
00:05:48,534 --> 00:05:50,467
to make
dynamic programs like--

160
00:05:50,467 --> 00:05:52,534
Dynamic programming languages,
like JavaScript,

161
00:05:52,534 --> 00:05:54,367
run so much faster.

162
00:05:54,367 --> 00:05:57,367
And the V8 team was very
successful, in my opinion.

163
00:05:57,367 --> 00:05:58,934
I mean, compared to where
we were in '06,

164
00:05:58,934 --> 00:06:00,601
they've come
order of magnitude,

165
00:06:00,601 --> 00:06:02,467
or one or two
orders of magnitude

166
00:06:02,467 --> 00:06:05,367
depending on what kinds of tests
you're talking about.

167
00:06:05,367 --> 00:06:08,467
And that's just outstanding.

168
00:06:08,467 --> 00:06:12,200
Don't you just love
silent auto-update?

169
00:06:12,200 --> 00:06:15,467
I do.

170
00:06:15,467 --> 00:06:19,100
Okay, so under the hood.

171
00:06:19,100 --> 00:06:21,534
The major components
of Chrome.

172
00:06:21,534 --> 00:06:25,067
So this is sort of--

173
00:06:25,067 --> 00:06:28,334
gives you a big picture
of some of the major modules.

174
00:06:28,334 --> 00:06:30,167
And Chromium
is the source base

175
00:06:30,167 --> 00:06:32,067
from which Chrome is derived,

176
00:06:32,067 --> 00:06:33,767
Chrome being the application.

177
00:06:33,767 --> 00:06:36,067
And Chromium depends
on WebKit.

178
00:06:36,067 --> 00:06:38,734
I've mentioned
WebKit already and V8.

179
00:06:38,734 --> 00:06:40,534
And Skia,
Skia's our graphics engine.

180
00:06:40,534 --> 00:06:42,167
This actually comes
from the android project.

181
00:06:42,167 --> 00:06:43,701
It's a 2-D graphics engine

182
00:06:43,701 --> 00:06:45,801
that's highly optimized
for mobile environments.

183
00:06:45,801 --> 00:06:49,367
And so it really runs well
on a desktop system.

184
00:06:49,367 --> 00:06:52,300
And so
in the Chromium world,

185
00:06:52,300 --> 00:06:54,334
how these
are all glued together,

186
00:06:54,334 --> 00:06:55,601
Chromium embeds WebKit.

187
00:06:55,601 --> 00:06:57,367
WebKit renders to Skia.

188
00:06:57,367 --> 00:07:00,133
Chromium also renders
its own UI to Skia.

189
00:07:00,133 --> 00:07:03,667
And WebKit talks to V8
to run JavaScript.

190
00:07:03,667 --> 00:07:05,434
But Chromium also talks
directly to V8

191
00:07:05,434 --> 00:07:07,334
for things
like proxy auto-config

192
00:07:07,334 --> 00:07:09,667
and other usages
of JavaScript in a browser

193
00:07:09,667 --> 00:07:12,667
besides just that
related to web content.

194
00:07:12,667 --> 00:07:14,534
So Chromium itself,
the code base,

195
00:07:14,534 --> 00:07:16,367
includes all the other stuff
that's not WebKit

196
00:07:16,367 --> 00:07:18,067
that's not V8, not Skia,

197
00:07:18,067 --> 00:07:20,067
and other libraries
that we incorporate.

198
00:07:20,067 --> 00:07:23,067
But it includes
things like the UI,

199
00:07:23,067 --> 00:07:24,434
the tab strip,
and the Omnibox--

200
00:07:24,434 --> 00:07:26,834
these are all
native UI elements.

201
00:07:26,834 --> 00:07:29,701
We chose to go
with a native UI for Chrome

202
00:07:29,701 --> 00:07:31,467
because we really wanted
to make sure

203
00:07:31,467 --> 00:07:35,267
that we could get all of
the look and feel just right.

204
00:07:35,267 --> 00:07:37,734
We wanted to have a very
lightweight, fast browser.

205
00:07:37,734 --> 00:07:40,334
We wanted to have a browser
that was highly tuned

206
00:07:40,334 --> 00:07:42,200
for Windows
and then again for Mac

207
00:07:42,200 --> 00:07:44,067
and then again for Linux.

208
00:07:44,067 --> 00:07:47,334
And so for Windows,
we went about--

209
00:07:47,334 --> 00:07:49,200
we went about building
this native tab strip,

210
00:07:49,200 --> 00:07:50,534
this native Omnibox.

211
00:07:50,534 --> 00:07:54,434
And, however, not all
of our UI is native.

212
00:07:54,434 --> 00:07:56,367
The new tab page,
the downloads page,

213
00:07:56,367 --> 00:07:58,067
the history panel,

214
00:07:58,067 --> 00:08:00,634
these appear
in the tab contents area.

215
00:08:00,634 --> 00:08:04,267
And so they are naturally
HTML-based

216
00:08:04,267 --> 00:08:06,167
so that you get
the same look and feel

217
00:08:06,167 --> 00:08:07,734
that you would
for a web app.

218
00:08:07,734 --> 00:08:10,767
And this turned out
to work very well for us.

219
00:08:10,767 --> 00:08:12,868
So basically,
the amount of native code

220
00:08:12,868 --> 00:08:14,601
is minimized to just that

221
00:08:14,601 --> 00:08:17,467
of the frame
or the window manager.

222
00:08:17,467 --> 00:08:19,067
So that's pretty much
all I'm gonna talk about

223
00:08:19,067 --> 00:08:21,200
as far as UI is concerned.

224
00:08:21,200 --> 00:08:23,100
The other main components
in Chromium though

225
00:08:23,100 --> 00:08:24,634
are multi-process
architecture.

226
00:08:24,634 --> 00:08:27,634
That's sort of the thing that--
the goop that binds

227
00:08:27,634 --> 00:08:31,000
this whole collection
of processes together.

228
00:08:31,000 --> 00:08:33,667
And they history system
is fairly complicated,

229
00:08:33,667 --> 00:08:35,033
based around Sequel Light,

230
00:08:35,033 --> 00:08:37,300
and there's
a full text index there.

231
00:08:37,300 --> 00:08:39,734
The network stack
runs in the main process.

232
00:08:39,734 --> 00:08:42,434
I'll actually talk more
about processes in detail later.

233
00:08:42,434 --> 00:08:45,701
And then there's a sandbox
piece of module

234
00:08:45,701 --> 00:08:48,033
within
the Chromium source base.

235
00:08:48,033 --> 00:08:49,868
So moving on.

236
00:08:49,868 --> 00:08:52,000
Multi-process architecture.

237
00:08:52,000 --> 00:08:53,767
Just getting into this
a little bit more.

238
00:08:53,767 --> 00:08:55,367
So I've been talking
about processes.

239
00:08:55,367 --> 00:08:56,868
So this is what I mean.

240
00:08:56,868 --> 00:08:58,100
This picture here shows

241
00:08:58,100 --> 00:09:00,167
that this main coordinating
browser process

242
00:09:00,167 --> 00:09:03,434
that all of the child processes
talk to.

243
00:09:03,434 --> 00:09:06,334
And we have a sequence--
a set of different renderers.

244
00:09:06,334 --> 00:09:08,100
Each of the rendering processes

245
00:09:08,100 --> 00:09:09,701
are the processes
that embed WebKit

246
00:09:09,701 --> 00:09:11,634
to render web pages,

247
00:09:11,634 --> 00:09:12,901
and they talk back
to the browser

248
00:09:12,901 --> 00:09:14,567
for things like IO.

249
00:09:14,567 --> 00:09:15,801
So because of the sandbox,

250
00:09:15,801 --> 00:09:17,467
the renderers
actually don't have access

251
00:09:17,467 --> 00:09:19,367
to direct--direct access
to the system,

252
00:09:19,367 --> 00:09:21,033
and they must proxy through
the browser for everything.

253
00:09:21,033 --> 00:09:23,334
So this is sort of
a hub and spoke design.

254
00:09:23,334 --> 00:09:25,100
I've shown some other
processes here--

255
00:09:25,100 --> 00:09:27,801
worker processes,
plug-in processes.

256
00:09:27,801 --> 00:09:31,634
So worker processes are
the new web workers coming of--

257
00:09:31,634 --> 00:09:34,534
that you start to see
various browsers implementing.

258
00:09:34,534 --> 00:09:38,200
These allow for a web page
to have a background thread

259
00:09:38,200 --> 00:09:40,534
or a background set of threads
that do work.

260
00:09:40,534 --> 00:09:43,334
And there's
a very asynchronous way

261
00:09:43,334 --> 00:09:45,067
of communicating to those
background threads,

262
00:09:45,067 --> 00:09:47,067
which lends itself
very naturally

263
00:09:47,067 --> 00:09:51,267
to having those workers
be out of process.

264
00:09:51,267 --> 00:09:53,267
And there can be
many of them.

265
00:09:53,267 --> 00:09:55,634
Plug-ins--Plug-ins actually
run outside the sandbox

266
00:09:55,634 --> 00:09:57,200
in their own process.

267
00:09:57,200 --> 00:09:59,400
So when I say plug-ins here,
I don't mean, like,

268
00:09:59,400 --> 00:10:01,200
Firefox extensions
or things like that.

269
00:10:01,200 --> 00:10:02,634
I mean the traditional
browser plug-ins

270
00:10:02,634 --> 00:10:05,234
like Flash, Java,
Silverlight, and so on

271
00:10:05,234 --> 00:10:07,701
that use things like NPAPI
or ActiveX.

272
00:10:07,701 --> 00:10:10,734
And so for these--
for each of these plug-ins,

273
00:10:10,734 --> 00:10:12,901
we load them
in their own process,

274
00:10:12,901 --> 00:10:17,467
so there's a Flash process
and a Java process and so on.

275
00:10:17,467 --> 00:10:19,133
Now I've made
some mention here

276
00:10:19,133 --> 00:10:20,801
of trust, untrusted,
and so on.

277
00:10:20,801 --> 00:10:23,067
So it's important to note

278
00:10:23,067 --> 00:10:27,033
that we really would like
to have sandboxed plug-ins.

279
00:10:27,033 --> 00:10:28,834
We would liked to have
included them in the sandbox,

280
00:10:28,834 --> 00:10:32,434
but because they are
basically already software

281
00:10:32,434 --> 00:10:35,334
that's on the system,
they have dependencies

282
00:10:35,334 --> 00:10:37,801
on being able to actually
access the system directly.

283
00:10:37,801 --> 00:10:40,067
They just can't be
included in the sandbox.

284
00:10:40,067 --> 00:10:41,901
A good example is Flash.

285
00:10:41,901 --> 00:10:44,000
It actually needs to be able
to auto-update itself.

286
00:10:44,000 --> 00:10:46,567
Well, if we denied its ability
to access your system,

287
00:10:46,567 --> 00:10:49,501
it wouldn't be able
to update itself.

288
00:10:49,501 --> 00:10:52,000
So it has to run
outside of the sandbox.

289
00:10:52,000 --> 00:10:53,901
But it still runs
in its own process

290
00:10:53,901 --> 00:10:56,067
so that we get some insulation
from, you know,

291
00:10:56,067 --> 00:11:01,534
page faults and so on.

292
00:11:01,534 --> 00:11:03,200
So inter-process
communication,

293
00:11:03,200 --> 00:11:06,200
just a few words
about that.

294
00:11:06,200 --> 00:11:08,934
We decided early on
that we really--

295
00:11:08,934 --> 00:11:10,634
You know, there were
many applications

296
00:11:10,634 --> 00:11:14,567
that you could point to that
were multi-process already,

297
00:11:14,567 --> 00:11:16,601
on your Windows desktop
or wherever.

298
00:11:16,601 --> 00:11:19,567
And a lot of times,
performance can--

299
00:11:19,567 --> 00:11:21,400
It's very easy to build
a multi-process application

300
00:11:21,400 --> 00:11:23,067
that doesn't perform well.

301
00:11:23,067 --> 00:11:24,901
And one of the key things
we really went for

302
00:11:24,901 --> 00:11:26,534
was this so-called
a permanent model,

303
00:11:26,534 --> 00:11:28,868
where we want to make sure
that individual processes

304
00:11:28,868 --> 00:11:30,133
or really individual threads

305
00:11:30,133 --> 00:11:31,767
really can run
as independently as possible

306
00:11:31,767 --> 00:11:35,400
and rely on more of
an asynchronous communication,

307
00:11:35,400 --> 00:11:36,934
locking between
the processes,

308
00:11:36,934 --> 00:11:40,033
locking between the threads
as minimally as possible.

309
00:11:40,033 --> 00:11:42,667
So we went for an asynchronous
communication system.

310
00:11:42,667 --> 00:11:46,667
Early on, we tried using
existing systems on Windows,

311
00:11:46,667 --> 00:11:48,501
like Windows messages that--

312
00:11:48,501 --> 00:11:50,601
You can so asynchronous
Windows messages.

313
00:11:50,601 --> 00:11:52,501
We looked at using comm.

314
00:11:52,501 --> 00:11:54,934
All these systems
were fairly complicated,

315
00:11:54,934 --> 00:11:56,901
and in order to achieve--

316
00:11:56,901 --> 00:11:58,834
In order to get the kind
of control we wanted

317
00:11:58,834 --> 00:12:00,601
over the IPC,
we went with named pipes.

318
00:12:00,601 --> 00:12:02,667
Plus named pipes
are much more portable.

319
00:12:02,667 --> 00:12:05,100
And we knew we would
eventually be bringing this

320
00:12:05,100 --> 00:12:06,567
to Mac and Linux,
and so it made sense

321
00:12:06,567 --> 00:12:08,300
to go with named pipes.

322
00:12:08,300 --> 00:12:10,234
We do have some support
for limited blocking calls,

323
00:12:10,234 --> 00:12:12,734
because that's required
for some of the--

324
00:12:12,734 --> 00:12:14,467
to support some of
the web interfaces

325
00:12:14,467 --> 00:12:16,334
that we need to support.

326
00:12:16,334 --> 00:12:18,501
And I can talk
about that more later.

327
00:12:18,501 --> 00:12:20,000
There's some use
of shared memory,

328
00:12:20,000 --> 00:12:21,868
but we basically
don't use shared memory

329
00:12:21,868 --> 00:12:23,534
unless it really
gives a big benefit,

330
00:12:23,534 --> 00:12:26,701
because it just adds
complexity to the system.

331
00:12:26,701 --> 00:12:29,000
So basically you can imagine,
if you will,

332
00:12:29,000 --> 00:12:31,267
these different processes

333
00:12:31,267 --> 00:12:34,868
that are basically having
a stream of events

334
00:12:34,868 --> 00:12:37,701
asynchronously flowing
to one process or the other.

335
00:12:37,701 --> 00:12:42,567
And it's sort of like
a big interconnected network

336
00:12:42,567 --> 00:12:45,667
of data being passed around.

337
00:12:45,667 --> 00:12:47,100
And we're trying
to keep this thing

338
00:12:47,100 --> 00:12:49,434
running as smoothly as possible
and avoiding hiccups.

339
00:12:49,434 --> 00:12:51,834
That's basically the goal

340
00:12:51,834 --> 00:12:54,067
of the inter-process
communication.

341
00:12:54,067 --> 00:12:55,934
This diagram here just shows

342
00:12:55,934 --> 00:12:57,734
that in order to keep things
running smoothly,

343
00:12:57,734 --> 00:12:59,567
we dedicate a thread
in each process

344
00:12:59,567 --> 00:13:01,801
to run and service the IPC.

345
00:13:01,801 --> 00:13:05,567
That way, if the UI thread,
T(UI), in the browser,

346
00:13:05,567 --> 00:13:09,067
were to go off
and produce a whole bunch

347
00:13:09,067 --> 00:13:11,067
of IPCs that he wants
to send to the renderer

348
00:13:11,067 --> 00:13:14,300
but then not yield control
to the system

349
00:13:14,300 --> 00:13:16,167
that actually sends
the IPCs,

350
00:13:16,167 --> 00:13:17,667
that could be bad.

351
00:13:17,667 --> 00:13:19,133
So instead,
there's a background thread

352
00:13:19,133 --> 00:13:20,801
who picks up that queue
of outbound requests

353
00:13:20,801 --> 00:13:22,167
and sends them along.

354
00:13:22,167 --> 00:13:23,667
Meanwhile, the browser's
doing other things,

355
00:13:23,667 --> 00:13:26,234
possibly expensive things,
but the IPC is flowing.

356
00:13:26,234 --> 00:13:27,734
And then the renderer,
the same deal.

357
00:13:27,734 --> 00:13:31,868
JavaScript application could be
consuming T(WebKit),

358
00:13:31,868 --> 00:13:33,634
but we still have
an IO thread

359
00:13:33,634 --> 00:13:35,100
that's pumping events
and doing things

360
00:13:35,100 --> 00:13:36,701
and keeping things
running smoothly.

361
00:13:36,701 --> 00:13:39,100
That's just sort of
a bird's-eye view

362
00:13:39,100 --> 00:13:42,234
of what the inter-process
communication looks like.

363
00:13:42,234 --> 00:13:46,133
Process assignments.

364
00:13:46,133 --> 00:13:48,367
What do I mean by this?

365
00:13:48,367 --> 00:13:51,467
Given that Chrome
has many rendering processes

366
00:13:51,467 --> 00:13:53,834
and we really would love,
ideally,

367
00:13:53,834 --> 00:13:55,901
to be able to assign
a single web application

368
00:13:55,901 --> 00:13:58,033
to a single process,
thereby giving

369
00:13:58,033 --> 00:14:00,467
the best separation
between web applications.

370
00:14:00,467 --> 00:14:02,200
There's some realities
to the web

371
00:14:02,200 --> 00:14:07,200
that force us to group
some applications or some--

372
00:14:07,200 --> 00:14:08,767
What do I mean by applications?
Web pages.

373
00:14:08,767 --> 00:14:13,033
Some web pages have to be
grouped together in processes.

374
00:14:13,033 --> 00:14:15,100
And then there's
opportunities to decide

375
00:14:15,100 --> 00:14:17,801
when we should actually
create a new process.

376
00:14:17,801 --> 00:14:19,367
And coming up with
a good formula here

377
00:14:19,367 --> 00:14:20,734
is a little tricky,

378
00:14:20,734 --> 00:14:22,634
'cause there's
some realistic limitations.

379
00:14:22,634 --> 00:14:24,601
Like we don't want to have
too many processes.

380
00:14:24,601 --> 00:14:26,400
At some point,
you start to pay a cost

381
00:14:26,400 --> 00:14:28,234
by having many processes.

382
00:14:28,234 --> 00:14:29,701
So we have a process limit.

383
00:14:29,701 --> 00:14:32,267
If that limit's reached,
we'll start reusing processes.

384
00:14:32,267 --> 00:14:34,300
If there's a potential
script connection

385
00:14:34,300 --> 00:14:35,567
between two web pages,

386
00:14:35,567 --> 00:14:37,300
well, they need to be
in the same process.

387
00:14:37,300 --> 00:14:39,601
We could have built
the system

388
00:14:39,601 --> 00:14:44,033
so that there was
a complex way of--

389
00:14:44,033 --> 00:14:46,200
a bridge or so
between the script

390
00:14:46,200 --> 00:14:48,167
running in one page
and the script in another page,

391
00:14:48,167 --> 00:14:49,801
but that seemed like it would
be overly complicated

392
00:14:49,801 --> 00:14:52,100
and potentially lead to a lot
of performance problems.

393
00:14:52,100 --> 00:14:54,667
So instead we thought,
well, a web application--

394
00:14:54,667 --> 00:14:56,534
Well, if we think
of a web application

395
00:14:56,534 --> 00:14:58,801
that might have many pages

396
00:14:58,801 --> 00:15:01,067
as probably sharing
script connections,

397
00:15:01,067 --> 00:15:03,801
then it kind of makes sense
for those many pages

398
00:15:03,801 --> 00:15:05,467
to all be grouped
in the same process.

399
00:15:05,467 --> 00:15:09,434
And so this idea of just
looking at any page

400
00:15:09,434 --> 00:15:13,868
that's open from WebKit
as potentially being a page

401
00:15:13,868 --> 00:15:16,367
that should be
in the same process,

402
00:15:16,367 --> 00:15:17,767
that seemed to make sense.

403
00:15:17,767 --> 00:15:20,801
And it works out pretty well
for a lot of applications.

404
00:15:20,801 --> 00:15:22,467
You'd think,
interestingly enough,

405
00:15:22,467 --> 00:15:24,067
Target blank--
I put this up here

406
00:15:24,067 --> 00:15:26,467
'cause you'd think that when
a user clicks on target blank,

407
00:15:26,467 --> 00:15:28,167
and that means
open a new window,

408
00:15:28,167 --> 00:15:29,834
that there should be
no script connection

409
00:15:29,834 --> 00:15:32,801
between that and the page
that you opened

410
00:15:32,801 --> 00:15:34,234
that the link was clicked on.

411
00:15:34,234 --> 00:15:35,467
Well, it turns out

412
00:15:35,467 --> 00:15:37,601
that there is
a very real script connection.

413
00:15:37,601 --> 00:15:39,467
When that new page
is opened,

414
00:15:39,467 --> 00:15:42,200
it's actually got
a dot opener property,

415
00:15:42,200 --> 00:15:44,701
and the dot opener property
allows it to see the guy--

416
00:15:44,701 --> 00:15:48,601
the page from which
he was opened.

417
00:15:48,601 --> 00:15:51,701
Now that's okay.

418
00:15:51,701 --> 00:15:53,467
So okay, well,
then in that case,

419
00:15:53,467 --> 00:15:55,200
if it's the same origin,
you know,

420
00:15:55,200 --> 00:15:57,367
'cause JavaScript allows
scripting

421
00:15:57,367 --> 00:16:00,100
provided origin A
and origin B are the same,

422
00:16:00,100 --> 00:16:02,734
then they--
they then, you know--

423
00:16:02,734 --> 00:16:06,267
Okay, we would only group them
in the same process if--

424
00:16:06,267 --> 00:16:10,067
if the new page
is of the same origin.

425
00:16:10,067 --> 00:16:11,834
And that's actually
not good enough,

426
00:16:11,834 --> 00:16:14,567
because it might be that
you are clicking a link from--

427
00:16:14,567 --> 00:16:17,868
opening a new window
from origin A to origin B,

428
00:16:17,868 --> 00:16:20,200
but origin B
might have a sub frame

429
00:16:20,200 --> 00:16:21,901
that's also on origin A.

430
00:16:21,901 --> 00:16:23,634
And origin--
the page over here

431
00:16:23,634 --> 00:16:26,100
can actually find
that frame by name.

432
00:16:26,100 --> 00:16:29,367
And so sort of after the fact,
after a window's created,

433
00:16:29,367 --> 00:16:30,734
there might be
a script connection

434
00:16:30,734 --> 00:16:32,133
that become established.

435
00:16:32,133 --> 00:16:34,000
So we need to keep those
in the same process.

436
00:16:34,000 --> 00:16:36,534
Okay, but then there's
some heuristics

437
00:16:36,534 --> 00:16:40,400
to try to get out of
these sort of situations.

438
00:16:40,400 --> 00:16:42,501
Turns out that a lot
of web applications

439
00:16:42,501 --> 00:16:46,767
use window.open
to navigate

440
00:16:46,767 --> 00:16:50,701
from the application
to a new page.

441
00:16:50,701 --> 00:16:52,601
For example, Gmail,
when you click a link,

442
00:16:52,601 --> 00:16:56,067
it wants to take you
to a new page for that link.

443
00:16:56,067 --> 00:16:58,968
And the thing though
is that Gmail

444
00:16:58,968 --> 00:17:01,334
really has no interest in there
being a script connection

445
00:17:01,334 --> 00:17:04,200
between Gmail
and that new page.

446
00:17:04,200 --> 00:17:08,100
It even goes so far
to set the opener property

447
00:17:08,100 --> 00:17:10,067
of that new page
to null

448
00:17:10,067 --> 00:17:12,601
before navigating
that new page

449
00:17:12,601 --> 00:17:14,234
to the URL
that you clicked on.

450
00:17:14,234 --> 00:17:15,901
Those kinds
of tricks are done

451
00:17:15,901 --> 00:17:17,501
to sort of sever
the script connection,

452
00:17:17,501 --> 00:17:20,534
at least as far as
that rendering process

453
00:17:20,534 --> 00:17:21,934
would be concerned.

454
00:17:21,934 --> 00:17:24,400
Well, we sort of use that
as a clue, as a heuristic

455
00:17:24,400 --> 00:17:26,534
to determine that--
Oh, I see.

456
00:17:26,534 --> 00:17:28,868
There's no script connection
because it's been removed.

457
00:17:28,868 --> 00:17:31,734
We can just fork that off
into another process.

458
00:17:31,734 --> 00:17:34,133
And so that's the kind
of heuristic that we've applied

459
00:17:34,133 --> 00:17:36,901
to get sort of a good
distribution of processes

460
00:17:36,901 --> 00:17:40,300
when, say, Gmail is the source
of all your new tabs,

461
00:17:40,300 --> 00:17:42,334
because you're
clicking links there,

462
00:17:42,334 --> 00:17:44,434
or other applications
like Gmail.

463
00:17:44,434 --> 00:17:47,400
All right, another topic
about process assignments.

464
00:17:47,400 --> 00:17:51,667
When you are just typing
a URL in the location bar,

465
00:17:51,667 --> 00:17:55,267
you're saying,
"Replace the current tab

466
00:17:55,267 --> 00:17:57,901
with new contents
from this new location."

467
00:17:57,901 --> 00:18:00,601
And we recognize
that if what you're typing

468
00:18:00,601 --> 00:18:04,033
is a URL with a new domain,

469
00:18:04,033 --> 00:18:07,701
effectively it's
an opportunity for us to say,

470
00:18:07,701 --> 00:18:11,434
"It's like closing the tab
and opening a new tab."

471
00:18:11,434 --> 00:18:14,901
And so what you achieve there
is an opportunity

472
00:18:14,901 --> 00:18:17,567
to switch processes
out from under the system

473
00:18:17,567 --> 00:18:19,200
without the user
really being aware

474
00:18:19,200 --> 00:18:20,567
that there was
a process switch.

475
00:18:20,567 --> 00:18:22,267
And this becomes a really
natural and nice point

476
00:18:22,267 --> 00:18:24,968
for garbage collection.

477
00:18:24,968 --> 00:18:27,067
So frequently in Chrome,

478
00:18:27,067 --> 00:18:28,734
you're just typing
in the location bar,

479
00:18:28,734 --> 00:18:31,501
you go to a--
enter a new URL up there,

480
00:18:31,501 --> 00:18:33,434
and unbeknownst to you,

481
00:18:33,434 --> 00:18:37,767
we're actually swapping
processes underneath.

482
00:18:37,767 --> 00:18:40,267
Oh, yes,
process per domain.

483
00:18:40,267 --> 00:18:42,167
So some people
might have heard

484
00:18:42,167 --> 00:18:45,133
about the research project,
the Gisele browser,

485
00:18:45,133 --> 00:18:48,400
which basically
implemented this idea

486
00:18:48,400 --> 00:18:51,033
of actually having a separate
rendering process per domain,

487
00:18:51,033 --> 00:18:53,234
rather than a separate
rendering process per tab.

488
00:18:53,234 --> 00:18:56,534
This was something that
we looked at very hard as well,

489
00:18:56,534 --> 00:18:58,534
because it seems
very attractive.

490
00:18:58,534 --> 00:19:00,968
And our conclusions
were very similar to theirs--

491
00:19:00,968 --> 00:19:02,634
that you suffer some--

492
00:19:02,634 --> 00:19:05,133
It turns out, you suffer
some web compatibility hit

493
00:19:05,133 --> 00:19:07,200
for trying to make
this kind of change.

494
00:19:07,200 --> 00:19:09,033
But it still seems
so attractive.

495
00:19:09,033 --> 00:19:10,801
Wouldn't it be nice
if you could have

496
00:19:10,801 --> 00:19:13,367
one rendering engine
dedicated for one domain?

497
00:19:13,367 --> 00:19:14,767
And then you could
start to apply

498
00:19:14,767 --> 00:19:17,667
some of these
multi-process benefits

499
00:19:17,667 --> 00:19:19,501
to actual domains.

500
00:19:19,501 --> 00:19:23,100
You could say, "All the data
associated to Food.com

501
00:19:23,100 --> 00:19:26,000
would only be available
to that rendering process."

502
00:19:26,000 --> 00:19:28,801
And you wouldn't be able
to ever see data for Bar.com.

503
00:19:28,801 --> 00:19:31,234
That's sort of the holy grail
of multi-process architecture.

504
00:19:31,234 --> 00:19:33,567
But there's some real
web compat challenges

505
00:19:33,567 --> 00:19:36,334
that we face with that.

506
00:19:36,334 --> 00:19:38,501
For example,
third-party cookies

507
00:19:38,501 --> 00:19:39,734
are a big problem.

508
00:19:39,734 --> 00:19:44,868
It turns out the web page
can dabble with cookies

509
00:19:44,868 --> 00:19:50,601
that are not its own.

510
00:19:50,601 --> 00:19:51,934
All right, so sandbox.

511
00:19:51,934 --> 00:19:53,834
So I've been talking
about the sandbox,

512
00:19:53,834 --> 00:19:56,901
but here's a little more
detail about it.

513
00:19:56,901 --> 00:19:58,534
Primary goal of the sandbox

514
00:19:58,534 --> 00:20:02,234
was really all about protecting
the user against malware.

515
00:20:02,234 --> 00:20:04,567
There's so many things
that you might wish to sandbox.

516
00:20:04,567 --> 00:20:06,300
Like you might wish to,
as I was just saying,

517
00:20:06,300 --> 00:20:10,033
you might wish to protect
one origin from another origin--

518
00:20:10,033 --> 00:20:11,667
Food.com from Bar.com.

519
00:20:11,667 --> 00:20:14,968
But that wasn't something
we strove to achieve initially.

520
00:20:14,968 --> 00:20:16,534
The first goal of the sandbox

521
00:20:16,534 --> 00:20:19,200
was really just
as a catchall

522
00:20:19,200 --> 00:20:22,033
to protect the user
against malware.

523
00:20:22,033 --> 00:20:23,734
If somehow there was a bug

524
00:20:23,734 --> 00:20:25,868
exploited
in the renderering engine,

525
00:20:25,868 --> 00:20:28,267
it should not turn itself
into a vehicle

526
00:20:28,267 --> 00:20:31,100
to allow people
to distribute malware.

527
00:20:31,100 --> 00:20:32,634
So Chrome
has several features,

528
00:20:32,634 --> 00:20:34,200
several anti-malware features.

529
00:20:34,200 --> 00:20:35,801
It has the sandbox,
of course,

530
00:20:35,801 --> 00:20:38,100
but it also has
the safe browsing feature,

531
00:20:38,100 --> 00:20:41,100
much like what you find
in other browsers,

532
00:20:41,100 --> 00:20:43,901
where once you venture
onto a URL or a page

533
00:20:43,901 --> 00:20:47,801
that contains content
known to be bad,

534
00:20:47,801 --> 00:20:49,767
we'll show an interstitial,
an error,

535
00:20:49,767 --> 00:20:51,667
allowing the user
to go through or not.

536
00:20:51,667 --> 00:20:53,601
That's sort of a first cut.

537
00:20:53,601 --> 00:20:55,234
You know, obviously
if we don't know--

538
00:20:55,234 --> 00:20:57,067
If the service
that you're using

539
00:20:57,067 --> 00:20:59,100
to supply that data
doesn't know about the bad URL,

540
00:20:59,100 --> 00:21:00,434
it's not gonna work.

541
00:21:00,434 --> 00:21:02,634
So you need some kind
of extra protection.

542
00:21:02,634 --> 00:21:05,067
It was very interesting--
a very interesting story.

543
00:21:05,067 --> 00:21:07,033
One of our engineers
was tracking down a crash

544
00:21:07,033 --> 00:21:08,934
that he saw in Chrome
in the renderer,

545
00:21:08,934 --> 00:21:12,067
and he was like,
"Oh, it's hard to reproduce--"

546
00:21:12,067 --> 00:21:14,434
It's hard to debug
when he has the sandbox engaged.

547
00:21:14,434 --> 00:21:17,067
So he thought, "I'll just
take off the sandbox,

548
00:21:17,067 --> 00:21:19,868
"and then I'll load this page up
in my debugger,

549
00:21:19,868 --> 00:21:21,501
and go to town
trying to figure it out."

550
00:21:21,501 --> 00:21:23,634
Well, it turns out that
that was actually

551
00:21:23,634 --> 00:21:25,934
a site serving malware
that exploited his system

552
00:21:25,934 --> 00:21:28,667
and corrupted his XP.

553
00:21:28,667 --> 00:21:30,834
And he was like, "Oh, crap,
now I have to re-image,"

554
00:21:30,834 --> 00:21:32,767
just 'cause he was trying
to debug this problem.

555
00:21:32,767 --> 00:21:35,834
So sandbox
is a really nice tool.

556
00:21:35,834 --> 00:21:38,367
What are we trying
to restrict?

557
00:21:38,367 --> 00:21:40,567
Well, trying to restrict

558
00:21:40,567 --> 00:21:43,067
the processes' access
to the file system and network

559
00:21:43,067 --> 00:21:45,067
and other kinds of devices
on the system.

560
00:21:45,067 --> 00:21:46,968
We're also trying
to restrict his access

561
00:21:46,968 --> 00:21:48,434
to the windowing system.

562
00:21:48,434 --> 00:21:49,968
So he shouldn't be able to mess
around with your desktop,

563
00:21:49,968 --> 00:21:51,400
shouldn't be able
to mess around

564
00:21:51,400 --> 00:21:54,000
with any of the hardware,
your keyboard or your mouse

565
00:21:54,000 --> 00:21:55,567
and so on.

566
00:21:55,567 --> 00:21:57,167
The mechanisms
to achieve this--

567
00:21:57,167 --> 00:22:01,267
Well, as I said, every process
has some associated user,

568
00:22:01,267 --> 00:22:03,133
and the user has
a certain set of capabilities.

569
00:22:03,133 --> 00:22:06,000
Under Windows, this is
represented by a user token.

570
00:22:06,000 --> 00:22:08,534
And we can strip
all of the rights

571
00:22:08,534 --> 00:22:10,667
off of that user token,
thereby denying things

572
00:22:10,667 --> 00:22:13,734
like system access
and file system access.

573
00:22:13,734 --> 00:22:15,901
And there's other techniques
in Windows,

574
00:22:15,901 --> 00:22:17,567
including job objects
that can be used

575
00:22:17,567 --> 00:22:19,801
to further restrict
the capabilities of a process.

576
00:22:19,801 --> 00:22:21,868
And even just running it
on a separate virtual desktop,

577
00:22:21,868 --> 00:22:24,200
this is a great way
to sort of limit

578
00:22:24,200 --> 00:22:26,400
the processes' ability
to get access

579
00:22:26,400 --> 00:22:31,267
to some of the input devices.

580
00:22:31,267 --> 00:22:34,200
Okay, but sandbox
doesn't actually--

581
00:22:34,200 --> 00:22:36,534
A browser actually needs
to be able to load file URLs.

582
00:22:36,534 --> 00:22:38,200
So how do we achieve that
given that sandbox

583
00:22:38,200 --> 00:22:40,667
doesn't allow you
to access file URLs?

584
00:22:40,667 --> 00:22:42,601
Well, two big examples
of this

585
00:22:42,601 --> 00:22:44,534
are A,
loading file colon URLs,

586
00:22:44,534 --> 00:22:47,367
and the other one is actually
being able to upload a file

587
00:22:47,367 --> 00:22:49,934
that is specified
in a web form.

588
00:22:49,934 --> 00:22:53,100
So to deal with file uploads,
what we do

589
00:22:53,100 --> 00:22:58,367
is when the WebKit
wants to show a file picker,

590
00:22:58,367 --> 00:23:00,968
it actually just asks
the browser,

591
00:23:00,968 --> 00:23:02,501
"Please show a file picker."

592
00:23:02,501 --> 00:23:04,200
Or a rendering process
asks the browser,

593
00:23:04,200 --> 00:23:05,434
"Please show a file picker."

594
00:23:05,434 --> 00:23:06,534
The browser
shows a file picker.

595
00:23:06,534 --> 00:23:08,000
The user makes their selection.

596
00:23:08,000 --> 00:23:10,501
And then what we do
before we return that result

597
00:23:10,501 --> 00:23:12,767
to the rendering engine
is we put it on a whitelist

598
00:23:12,767 --> 00:23:14,200
associated
with that rendering engine.

599
00:23:14,200 --> 00:23:16,234
And now that rendering engine
is allowed to say

600
00:23:16,234 --> 00:23:18,100
that he wants
to upload that file.

601
00:23:18,100 --> 00:23:20,534
It's pretty simple.

602
00:23:20,534 --> 00:23:22,467
File colon URLs, well,
what is this?

603
00:23:22,467 --> 00:23:25,033
This is, you know,
the rendering engine

604
00:23:25,033 --> 00:23:26,767
being able to load
any file URL,

605
00:23:26,767 --> 00:23:30,167
because if you go to some
Food.HTML on your hard drive,

606
00:23:30,167 --> 00:23:33,434
it can load images from
anywhere else on the hard drive.

607
00:23:33,434 --> 00:23:35,968
To make that work,
what we do is we actually

608
00:23:35,968 --> 00:23:38,667
just dedicate a separate
process for file colon URLs.

609
00:23:38,667 --> 00:23:42,634
So we're never mixing
web content and file colon URLs

610
00:23:42,634 --> 00:23:45,267
in the same process.

611
00:23:45,267 --> 00:23:47,801
For example, if you go
into the location bar

612
00:23:47,801 --> 00:23:49,167
and you type file colon,

613
00:23:49,167 --> 00:23:51,067
and you're sitting
on a web page somewhere,

614
00:23:51,067 --> 00:23:53,167
what we'll actually do
is leverage that technique

615
00:23:53,167 --> 00:23:55,667
I mentioned before of swapping
the rendering engine out

616
00:23:55,667 --> 00:23:56,934
underneath the hood,

617
00:23:56,934 --> 00:23:58,300
so that really
what we're doing

618
00:23:58,300 --> 00:24:01,167
is loading it
in a fresh rendering engine

619
00:24:01,167 --> 00:24:05,868
that is now just dedicated
to local files.

620
00:24:05,868 --> 00:24:07,901
Okay, so what isn't protected?

621
00:24:07,901 --> 00:24:10,067
I talked a little bit before
about, like,

622
00:24:10,067 --> 00:24:11,901
we're not separating origins.

623
00:24:11,901 --> 00:24:14,234
So what that means
is that cookies--

624
00:24:14,234 --> 00:24:15,634
A rendering engine can read

625
00:24:15,634 --> 00:24:17,133
all of your cookies
from anywhere.

626
00:24:17,133 --> 00:24:19,634
So if somehow there was
a bug in the rendering engine,

627
00:24:19,634 --> 00:24:21,334
that guy could then
go and ask for cookies

628
00:24:21,334 --> 00:24:22,801
from any domain.

629
00:24:22,801 --> 00:24:26,100
And this is just--this is
something we have to support

630
00:24:26,100 --> 00:24:27,801
because of document.cookie.

631
00:24:27,801 --> 00:24:29,968
There's a JavaScript API
to allow the web page

632
00:24:29,968 --> 00:24:31,734
to read your cookies.

633
00:24:31,734 --> 00:24:34,467
The one exception here
is the HTTP-only cookies.

634
00:24:34,467 --> 00:24:37,234
We actually don't have to allow
the renderer to see those.

635
00:24:37,234 --> 00:24:39,000
He can make HTTP requests,

636
00:24:39,000 --> 00:24:40,667
and then the network stack
running in the browser

637
00:24:40,667 --> 00:24:44,400
will add those
HTTP-only cookies.

638
00:24:44,400 --> 00:24:45,601
Passwords.

639
00:24:45,601 --> 00:24:46,934
Passwords,
much like cookies,

640
00:24:46,934 --> 00:24:48,868
it turns out that the web page
can read the passwords.

641
00:24:48,868 --> 00:24:50,801
So if you have an input type,
people's password,

642
00:24:50,801 --> 00:24:53,234
and the user enters
a value there,

643
00:24:53,234 --> 00:24:54,834
it's actually supported
by the web

644
00:24:54,834 --> 00:24:56,334
that the web page
should be able

645
00:24:56,334 --> 00:24:58,300
to actually read that value out
and do something with it.

646
00:24:58,300 --> 00:25:00,000
It's just the way

647
00:25:00,000 --> 00:25:01,567
the input type,
people's password,

648
00:25:01,567 --> 00:25:04,067
it's just a mechanism
for having some sort of secret

649
00:25:04,067 --> 00:25:05,901
that's entered into
the web page.

650
00:25:05,901 --> 00:25:08,100
And so this generic mechanism
allows web pages

651
00:25:08,100 --> 00:25:11,801
to do things like
do client-side authentication.

652
00:25:11,801 --> 00:25:13,767
So it's not
necessarily the case

653
00:25:13,767 --> 00:25:16,767
that this password field
corresponds to data

654
00:25:16,767 --> 00:25:18,701
that will be in a forum post.

655
00:25:18,701 --> 00:25:20,100
The reason why
that's interesting,

656
00:25:20,100 --> 00:25:21,434
'cause you might
imagine a system

657
00:25:21,434 --> 00:25:24,300
where the browser returns
a dummy password

658
00:25:24,300 --> 00:25:25,801
to the web page.

659
00:25:25,801 --> 00:25:27,400
And then
when the dummy password

660
00:25:27,400 --> 00:25:28,901
appears in the form post,

661
00:25:28,901 --> 00:25:31,000
the browser transparently
replaces it

662
00:25:31,000 --> 00:25:32,667
with the real password.

663
00:25:32,667 --> 00:25:35,200
That's a very clever way
to avoid exposing

664
00:25:35,200 --> 00:25:36,767
the real password
to the web page.

665
00:25:36,767 --> 00:25:38,234
But again,
because the web page

666
00:25:38,234 --> 00:25:40,067
has the power
to read that value

667
00:25:40,067 --> 00:25:42,234
and so some computation on it,

668
00:25:42,234 --> 00:25:44,267
it's--there's a potential--

669
00:25:44,267 --> 00:25:46,767
there's a huge web
compatibility problem there.

670
00:25:46,767 --> 00:25:48,968
So we end up
exposing the passwords

671
00:25:48,968 --> 00:25:51,167
to the rendering engine.

672
00:25:51,167 --> 00:25:52,968
Other things like
HTML 5 database,

673
00:25:52,968 --> 00:25:54,567
local store, session store,
they're much like cookies--

674
00:25:54,567 --> 00:25:55,667
same kind of deal.

675
00:25:55,667 --> 00:25:56,934
They're origin-based,

676
00:25:56,934 --> 00:25:58,400
and the renderer
gets access to them.

677
00:25:58,400 --> 00:26:00,434
Cross-site attacks,
user data in the cloud,

678
00:26:00,434 --> 00:26:02,100
that kind of stuff
is not what the sandbox

679
00:26:02,100 --> 00:26:03,734
is trying to protect against.

680
00:26:03,734 --> 00:26:05,367
You could imagine
a better sandbox

681
00:26:05,367 --> 00:26:09,400
that did do that kind
of stuff.

682
00:26:09,400 --> 00:26:11,968
Okay, so moving on
to rendering in a sandbox.

683
00:26:11,968 --> 00:26:13,968
So given that we have, like,
almost no access to the system,

684
00:26:13,968 --> 00:26:15,767
how do we render?

685
00:26:15,767 --> 00:26:17,501
Normally,
a web rendering engine

686
00:26:17,501 --> 00:26:19,367
is designed to render
to a native widget,

687
00:26:19,367 --> 00:26:21,667
like an hWnd
or an NSView

688
00:26:21,667 --> 00:26:24,133
or an X Window.

689
00:26:24,133 --> 00:26:25,901
And that kind of thing
doesn't work

690
00:26:25,901 --> 00:26:28,067
in a sandbox renderer
because we literally

691
00:26:28,067 --> 00:26:29,934
are trying to deny
access to hWnds.

692
00:26:29,934 --> 00:26:31,734
HWnds are in
the Windows desktop.

693
00:26:31,734 --> 00:26:33,200
We're trying to deny that.

694
00:26:33,200 --> 00:26:35,334
So instead, very simply,
render to a bitmap.

695
00:26:35,334 --> 00:26:37,267
Send the bitmap
to the browser process.

696
00:26:37,267 --> 00:26:39,501
The browser puts that bitmap
on the screen.

697
00:26:39,501 --> 00:26:42,734
So it's like
a glorified image viewer.

698
00:26:42,734 --> 00:26:44,133
Complexities.

699
00:26:44,133 --> 00:26:47,200
Well, the rendering engine

700
00:26:47,200 --> 00:26:50,701
can't get away without
using some system calls.

701
00:26:50,701 --> 00:26:53,367
For example, we need a way
to render fonts.

702
00:26:53,367 --> 00:26:55,634
And on Windows, to get
the best sort of fidelity

703
00:26:55,634 --> 00:26:58,033
and the best sort of
native look and feel,

704
00:26:58,033 --> 00:27:00,767
you really need to use
the Windows GDI APIs

705
00:27:00,767 --> 00:27:02,801
to render fonts.

706
00:27:02,801 --> 00:27:04,434
Well,
an interesting story here.

707
00:27:04,434 --> 00:27:06,300
This turned out to be
really challenging,

708
00:27:06,300 --> 00:27:09,534
'cause once you take away
the rendering engine's ability

709
00:27:09,534 --> 00:27:12,000
to access the file system,

710
00:27:12,000 --> 00:27:15,767
well, what this actually means
is that you can't load fonts.

711
00:27:15,767 --> 00:27:18,234
And all the font APIs,
transparently under the hood,

712
00:27:18,234 --> 00:27:19,901
will load fonts.

713
00:27:19,901 --> 00:27:22,767
Interestingly enough,
they don't do it in user land.

714
00:27:22,767 --> 00:27:24,334
They do it in kernel mode.

715
00:27:24,334 --> 00:27:25,801
But they use the token

716
00:27:25,801 --> 00:27:27,467
of the process
that was calling them

717
00:27:27,467 --> 00:27:29,868
to actually decide
whether or not

718
00:27:29,868 --> 00:27:32,434
the kernel should load
that font.

719
00:27:32,434 --> 00:27:36,234
Well, our token doesn't have
those privileges.

720
00:27:36,234 --> 00:27:39,300
So it turns out that Chrome
implements a glorious hack

721
00:27:39,300 --> 00:27:42,567
of when we encounter
a font API call that fails,

722
00:27:42,567 --> 00:27:44,934
we pause and let the browser
repeat the API

723
00:27:44,934 --> 00:27:46,267
and load the font,

724
00:27:46,267 --> 00:27:48,834
thereby populating the kernel's
cache of all fonts,

725
00:27:48,834 --> 00:27:51,734
and then we repeat the exercise
of calling that API

726
00:27:51,734 --> 00:27:53,234
in the renderer

727
00:27:53,234 --> 00:27:54,901
and this time
hope it succeeds

728
00:27:54,901 --> 00:27:56,834
because it hits some cache

729
00:27:56,834 --> 00:27:59,033
that the kernel maintains.

730
00:27:59,033 --> 00:28:01,501
So fascinating complexities
just trying to deal

731
00:28:01,501 --> 00:28:03,767
with some OS APIs.

732
00:28:03,767 --> 00:28:05,167
Other things
that we really wanted

733
00:28:05,167 --> 00:28:06,734
to try to achieve
with this--

734
00:28:06,734 --> 00:28:08,801
We really wanted to make sure
that there's no way

735
00:28:08,801 --> 00:28:10,868
that a hung renderer
can screw up the browser.

736
00:28:10,868 --> 00:28:13,367
This really impacts
the rendering model,

737
00:28:13,367 --> 00:28:15,467
which I'll talk about
a little more in detail later.

738
00:28:15,467 --> 00:28:17,467
But fundamentally, you don't
want to be in a situation

739
00:28:17,467 --> 00:28:19,133
where the renderer
is acquiring a lock

740
00:28:19,133 --> 00:28:21,234
that the browser
then has to also acquire,

741
00:28:21,234 --> 00:28:23,634
because the renderer
might never release it.

742
00:28:23,634 --> 00:28:26,200
And that--
As an end result, you know,

743
00:28:26,200 --> 00:28:28,601
a bad renderer might
bring down the whole browser,

744
00:28:28,601 --> 00:28:30,501
and we just really don't want
to be in that situation.

745
00:28:30,501 --> 00:28:33,334
And of course
it needs to be really fast.

746
00:28:33,334 --> 00:28:35,000
So speed is very important

747
00:28:35,000 --> 00:28:37,834
and somehow there should not
be any situations

748
00:28:37,834 --> 00:28:42,367
where the renderer
can lock up the browser.

749
00:28:42,367 --> 00:28:44,267
So painting and scrolling,

750
00:28:44,267 --> 00:28:45,901
lock free
painting and scrolling.

751
00:28:45,901 --> 00:28:47,834
This is a system
that we implement

752
00:28:47,834 --> 00:28:50,601
of maintaining
a backingstore in the browser.

753
00:28:50,601 --> 00:28:54,367
A recent Pixmap
of what the tab looks like.

754
00:28:54,367 --> 00:28:55,901
Very simple idea.

755
00:28:55,901 --> 00:28:57,200
And then the renderer,

756
00:28:57,200 --> 00:28:59,033
whenever he needs
to update a region,

757
00:28:59,033 --> 00:29:01,100
he sends a bitmap
over shared memory

758
00:29:01,100 --> 00:29:02,868
to the browser
and he blits that in

759
00:29:02,868 --> 00:29:04,100
to his backingstore

760
00:29:04,100 --> 00:29:08,100
and then blits that result
onto the screen.

761
00:29:08,100 --> 00:29:09,400
Very straightforward.

762
00:29:09,400 --> 00:29:10,868
And then when the browser

763
00:29:10,868 --> 00:29:12,267
is finished
putting pixels on the screen,

764
00:29:12,267 --> 00:29:13,534
he acknowledges
to the renderer,

765
00:29:13,534 --> 00:29:14,968
"Hey, look, and now
it's a good time

766
00:29:14,968 --> 00:29:16,801
to produce another bitmap."

767
00:29:16,801 --> 00:29:19,367
So this turns out to work
fairly well,

768
00:29:19,367 --> 00:29:22,601
except that, you know,
we recognize

769
00:29:22,601 --> 00:29:25,033
that you end up
in this sort of staggering

770
00:29:25,033 --> 00:29:26,834
kind of situation

771
00:29:26,834 --> 00:29:28,868
where the renderer paints,
then the browser paints,

772
00:29:28,868 --> 00:29:30,801
then the renderer paints,
browser paints.

773
00:29:30,801 --> 00:29:32,701
And in order to get
better performance,

774
00:29:32,701 --> 00:29:34,767
we allow the renderer
to sort of prefetch

775
00:29:34,767 --> 00:29:37,934
or do one additional render
ahead of the next--

776
00:29:37,934 --> 00:29:40,133
in parallel
to the browser painting.

777
00:29:40,133 --> 00:29:41,701
So if you're on
a multi-core system,

778
00:29:41,701 --> 00:29:43,667
you would be able
to light up both CPUs,

779
00:29:43,667 --> 00:29:45,167
one of them is the renderer

780
00:29:45,167 --> 00:29:46,868
producing the next
rendered output,

781
00:29:46,868 --> 00:29:48,133
and the other one
is the browser

782
00:29:48,133 --> 00:29:49,834
putting the pixels
from the previous rendering

783
00:29:49,834 --> 00:29:51,501
on the screen.

784
00:29:51,501 --> 00:29:53,501
Scrolling works
very similarly.

785
00:29:53,501 --> 00:29:55,734
In order to achieve
very good scrolling performance,

786
00:29:55,734 --> 00:29:58,200
you don't want to just
repaint the whole thing.

787
00:29:58,200 --> 00:30:00,334
You want to tell
the windowing system,

788
00:30:00,334 --> 00:30:01,968
"Hey, look,
move your pixels down

789
00:30:01,968 --> 00:30:03,868
and backfill
this exposed region."

790
00:30:03,868 --> 00:30:06,567
So we send commands
from the renderer

791
00:30:06,567 --> 00:30:09,767
to scroll the backingstore
and fill the exposed region,

792
00:30:09,767 --> 00:30:11,868
the then the browser
repeats the exercise

793
00:30:11,868 --> 00:30:13,334
of commanding
the windowing system

794
00:30:13,334 --> 00:30:15,601
to scroll the pixels and then
backfill the exposed region.

795
00:30:15,601 --> 00:30:21,367
And again, it acknowledges
once that's been done.

796
00:30:21,367 --> 00:30:24,167
Actually one more comment
about painting.

797
00:30:24,167 --> 00:30:27,234
So whenever you need
to resize the browser window,

798
00:30:27,234 --> 00:30:31,400
because we have a backingstore
of the old rendering,

799
00:30:31,400 --> 00:30:33,901
we don't necessarily have--
that backingstore

800
00:30:33,901 --> 00:30:35,834
is not the right size
when you resize.

801
00:30:35,834 --> 00:30:37,634
And so it turns out
to be necessary

802
00:30:37,634 --> 00:30:40,968
to play some games to try
to get good performance there,

803
00:30:40,968 --> 00:30:43,367
because we're in a situation
where a resize happened

804
00:30:43,367 --> 00:30:46,634
and we want to update
the backingstore,

805
00:30:46,634 --> 00:30:49,033
and we obviously
don't have it yet.

806
00:30:49,033 --> 00:30:51,434
But we have asked the renderer
to produce the data,

807
00:30:51,434 --> 00:30:53,167
and we're just waiting
for the renderer

808
00:30:53,167 --> 00:30:55,167
to produce the data,
but Windows has asked us

809
00:30:55,167 --> 00:30:57,567
to paint right now,
because it just resized.

810
00:30:57,567 --> 00:31:00,267
So we do implement
a little bit of a pause

811
00:31:00,267 --> 00:31:02,767
to allow the renderer
to produce pixels.

812
00:31:02,767 --> 00:31:04,701
If it can produce them
fast enough,

813
00:31:04,701 --> 00:31:06,934
then on resize we will
paint the correct pixels

814
00:31:06,934 --> 00:31:09,400
and not the old pixels.

815
00:31:09,400 --> 00:31:11,501
But it's fairly common
in Chrome when you use it,

816
00:31:11,501 --> 00:31:14,167
if you resize very quickly,
you will see a little gutter,

817
00:31:14,167 --> 00:31:18,434
and that's
what's going on there.

818
00:31:18,434 --> 00:31:19,968
Resource loading.

819
00:31:19,968 --> 00:31:21,367
So as I mentioned before,

820
00:31:21,367 --> 00:31:23,434
the browser's this proxy
for all the IO.

821
00:31:23,434 --> 00:31:27,400
He takes great care
to restrict the types of URLs

822
00:31:27,400 --> 00:31:29,534
that can be loaded
based on protocols.

823
00:31:29,534 --> 00:31:33,467
So if a rendering process
was not asked by the browser

824
00:31:33,467 --> 00:31:36,133
to load a file URL,
then the rendering process

825
00:31:36,133 --> 00:31:38,801
shall not request file URLs.

826
00:31:38,801 --> 00:31:40,667
And if he does,
they're denied.

827
00:31:40,667 --> 00:31:42,934
Chrome colon URLs
are like file colon URLs

828
00:31:42,934 --> 00:31:44,634
in that they're trusted.

829
00:31:44,634 --> 00:31:46,901
Chrome colon URLs
are used to load things

830
00:31:46,901 --> 00:31:49,234
like the new tab page,
the downloads panel,

831
00:31:49,234 --> 00:31:53,934
and other web content
that part of Chrome's UI.

832
00:31:53,934 --> 00:31:58,968
This browser network code
will actually perform

833
00:31:58,968 --> 00:32:01,067
all the safe browsing checks
I talked about.

834
00:32:01,067 --> 00:32:03,367
He'll do all kinds of things
like vending the cookies

835
00:32:03,367 --> 00:32:04,567
to the renderers
and managing all the data

836
00:32:04,567 --> 00:32:07,467
associated
with resource loading.

837
00:32:07,467 --> 00:32:09,934
Finally, before WebKit
sees any data,

838
00:32:09,934 --> 00:32:12,133
the browser's actually performed
a lot of different things.

839
00:32:12,133 --> 00:32:14,167
He's handled
HTTP authentication

840
00:32:14,167 --> 00:32:15,734
if prompting was necessary.

841
00:32:15,734 --> 00:32:18,000
He's done all
the SSL verification

842
00:32:18,000 --> 00:32:20,667
and potentially put up UI

843
00:32:20,667 --> 00:32:22,868
to ask users if they're--

844
00:32:22,868 --> 00:32:24,934
You know, put a warning dialog
that's like,

845
00:32:24,934 --> 00:32:26,434
"This, you know--

846
00:32:26,434 --> 00:32:28,634
This certificate
is not necessarily valid."

847
00:32:28,634 --> 00:32:29,968
He's done all these things

848
00:32:29,968 --> 00:32:31,934
by the time
WebKit sees any data.

849
00:32:31,934 --> 00:32:34,200
He's also potentially
handled downloads,

850
00:32:34,200 --> 00:32:36,067
so content sniffing
happens in the browser.

851
00:32:36,067 --> 00:32:41,000
MIME detection happens there
if necessary and so on.

852
00:32:41,000 --> 00:32:42,868
Some of the things that's
interesting about downloads

853
00:32:42,868 --> 00:32:45,901
is that if you imagine
a scenario

854
00:32:45,901 --> 00:32:48,567
where you were
returning data to WebKit

855
00:32:48,567 --> 00:32:49,901
or to the rendering process,

856
00:32:49,901 --> 00:32:51,434
and that process
was to determine

857
00:32:51,434 --> 00:32:53,734
whether or not the data
should be treated as a download,

858
00:32:53,734 --> 00:32:56,434
well, you would be
in an unfortunate situation

859
00:32:56,434 --> 00:32:58,100
of having to echo that data
back to the browser

860
00:32:58,100 --> 00:33:00,000
so that he could
save it to disk.

861
00:33:00,000 --> 00:33:01,934
And so moving the detection
into the browser

862
00:33:01,934 --> 00:33:03,467
allows for better performance.

863
00:33:03,467 --> 00:33:05,167
All the decisions
happen there,

864
00:33:05,167 --> 00:33:06,567
and it can either go--

865
00:33:06,567 --> 00:33:08,267
it could either decide
at that time

866
00:33:08,267 --> 00:33:13,033
to T it to disk
instead of to the renderer.

867
00:33:13,033 --> 00:33:14,968
The history system.

868
00:33:14,968 --> 00:33:20,200
So...much like painting,

869
00:33:20,200 --> 00:33:22,701
it was important to us
that we could achieve

870
00:33:22,701 --> 00:33:26,367
a good way to manage
visited links

871
00:33:26,367 --> 00:33:28,267
without locking.

872
00:33:28,267 --> 00:33:31,901
We wanted to make sure that--

873
00:33:31,901 --> 00:33:35,834
so that the renderer
could very quickly check

874
00:33:35,834 --> 00:33:37,400
whether or not
a link was visited

875
00:33:37,400 --> 00:33:39,300
so it could color it
as visited or not,

876
00:33:39,300 --> 00:33:40,901
and do so in a way
that didn't require

877
00:33:40,901 --> 00:33:42,634
acquiring any kind of lock.

878
00:33:42,634 --> 00:33:44,834
So there's sort of simple idea
of shared memory

879
00:33:44,834 --> 00:33:46,767
containing a bitmap

880
00:33:46,767 --> 00:33:48,801
that's treated like
a hash table.

881
00:33:48,801 --> 00:33:50,834
We apply a crypto hash
to the URL,

882
00:33:50,834 --> 00:33:53,734
take 64 bits of that,
index this bitmap,

883
00:33:53,734 --> 00:33:58,234
and then see if
the link's visited or not.

884
00:33:58,234 --> 00:33:59,767
And then the browser,

885
00:33:59,767 --> 00:34:01,334
whenever he needs
to update this thing,

886
00:34:01,334 --> 00:34:02,801
he's either setting the bits,

887
00:34:02,801 --> 00:34:04,334
or if he finds that
he needs to grow the table,

888
00:34:04,334 --> 00:34:05,767
he creates a whole new table,

889
00:34:05,767 --> 00:34:07,267
sends the new table
down to the renderer.

890
00:34:07,267 --> 00:34:08,734
The renderers
drop the old table

891
00:34:08,734 --> 00:34:10,067
and then pick up
the new one.

892
00:34:10,067 --> 00:34:12,267
Works great
with the minor exception

893
00:34:12,267 --> 00:34:15,067
that it causes us to fail
one of the Acid3 tests.

894
00:34:15,067 --> 00:34:18,534
This is why Chrome gets
that link test error in Acid3,

895
00:34:18,534 --> 00:34:21,267
because it turns out that this
is a very asynchronous model,

896
00:34:21,267 --> 00:34:22,767
of the browser's the only one

897
00:34:22,767 --> 00:34:24,300
who writes
to the visited link table.

898
00:34:24,300 --> 00:34:25,801
The renderer's
the one who reads,

899
00:34:25,801 --> 00:34:28,534
but this Acid3 test
actually requires the renderer

900
00:34:28,534 --> 00:34:32,234
to have visited
and be able to check right away

901
00:34:32,234 --> 00:34:35,734
that this link
is actually visited.

902
00:34:35,734 --> 00:34:37,767
But we're working
on a fix.

903
00:34:37,767 --> 00:34:39,501
So after a page loads,

904
00:34:39,501 --> 00:34:41,634
data is actually extracted
from the page

905
00:34:41,634 --> 00:34:43,267
so that it can be sent
into the full text index,

906
00:34:43,267 --> 00:34:45,868
and that's what drives
things like the Omnibox

907
00:34:45,868 --> 00:34:48,601
and the whole history search
mechanism in Chrome.

908
00:34:48,601 --> 00:34:50,701
And new tab is populated
with thumbnails.

909
00:34:50,701 --> 00:34:54,501
Those thumbnails are captured
at this time and so on.

910
00:34:54,501 --> 00:34:56,667
And this data is collected,
sent up to the browser.

911
00:34:56,667 --> 00:35:00,767
All this history management
happens up there.

912
00:35:00,767 --> 00:35:03,033
Plug-ins.

913
00:35:03,033 --> 00:35:04,968
This is probably--Plug-ins--

914
00:35:04,968 --> 00:35:07,467
Support Netscape
style plug-ins

915
00:35:07,467 --> 00:35:11,267
and even ActiveX controls
through a shim.

916
00:35:11,267 --> 00:35:12,734
Talk a little bit more
about that.

917
00:35:12,734 --> 00:35:14,167
Supporting plug-ins
turns out to be

918
00:35:14,167 --> 00:35:15,934
probably one of the hardest
things about doing Chrome,

919
00:35:15,934 --> 00:35:18,734
because we knew
they could not run

920
00:35:18,734 --> 00:35:20,100
in the sandbox renderer

921
00:35:20,100 --> 00:35:21,567
because they required
a lot of privileges,

922
00:35:21,567 --> 00:35:23,367
and we knew that we wanted
to have a sandbox

923
00:35:23,367 --> 00:35:25,100
that was very aggressive.

924
00:35:25,100 --> 00:35:26,968
And so that meant
pushing the plug-in

925
00:35:26,968 --> 00:35:28,634
outside of
the rendering engine,

926
00:35:28,634 --> 00:35:32,234
which meant taking an API
that was synchronous

927
00:35:32,234 --> 00:35:34,834
and designed to run
inside of a rendering engine

928
00:35:34,834 --> 00:35:37,300
and forcing it out of process.

929
00:35:37,300 --> 00:35:40,200
This turned out to be
very complicated.

930
00:35:40,200 --> 00:35:41,834
But what we tried to do here

931
00:35:41,834 --> 00:35:44,767
by allocating a single
plug-in process per plug-in

932
00:35:44,767 --> 00:35:48,334
was to give plug-ins sort of
this environment to run in

933
00:35:48,334 --> 00:35:52,033
that looked to them much like
an ordinary browser environment.

934
00:35:52,033 --> 00:35:54,334
So unbeknownst to them,
hopefully,

935
00:35:54,334 --> 00:35:56,000
they don't realize
that they're actually

936
00:35:56,000 --> 00:35:57,701
in a separate process.

937
00:35:57,701 --> 00:35:59,634
And this works--

938
00:35:59,634 --> 00:36:03,000
Through a lot of
sweat, tears, and toil,

939
00:36:03,000 --> 00:36:05,167
we've gotten this to work.

940
00:36:05,167 --> 00:36:08,234
So there's two types
of plug-ins,

941
00:36:08,234 --> 00:36:09,968
two modes of rendering
for plug-ins.

942
00:36:09,968 --> 00:36:12,467
One is called windowless
and one is windowed.

943
00:36:12,467 --> 00:36:14,200
Windowed means that
you actually get--

944
00:36:14,200 --> 00:36:16,200
the plug-in actually
has its own native widget,

945
00:36:16,200 --> 00:36:17,634
like its own hWnd.

946
00:36:17,634 --> 00:36:20,000
And then once it has
its own hWnd,

947
00:36:20,000 --> 00:36:24,467
it has its own
render loop basically.

948
00:36:24,467 --> 00:36:27,200
And it has a lot of control
and access to the system.

949
00:36:27,200 --> 00:36:29,133
But we're running
that hWnd out of process,

950
00:36:29,133 --> 00:36:31,334
and so we are managing
a windowing hierarchy

951
00:36:31,334 --> 00:36:32,868
that spans processes,

952
00:36:32,868 --> 00:36:34,934
and windows
outside of our control

953
00:36:34,934 --> 00:36:38,400
will be doing IPCs
between those windows,

954
00:36:38,400 --> 00:36:41,968
and that leads to a lot
of complexity.

955
00:36:41,968 --> 00:36:43,868
So we do
some interesting tricks

956
00:36:43,868 --> 00:36:46,701
to try to minimize
the synchronous communication

957
00:36:46,701 --> 00:36:48,167
that Windows does
underneath the hood

958
00:36:48,167 --> 00:36:49,834
so that scrolling a page
with plug-ins

959
00:36:49,834 --> 00:36:51,801
will actually perform okay.

960
00:36:51,801 --> 00:36:54,200
I think we still have
room to improve here,

961
00:36:54,200 --> 00:36:56,000
but it's gotten
a lot better

962
00:36:56,000 --> 00:36:57,734
since the Chrome 1 days.

963
00:36:57,734 --> 00:37:00,467
Or I should say
since our initial launch.

964
00:37:00,467 --> 00:37:02,634
Caching the rendering
of windowless plug-ins.

965
00:37:02,634 --> 00:37:04,534
What we do when there's
a windowless plug-in--

966
00:37:04,534 --> 00:37:05,868
This is a plug-in type

967
00:37:05,868 --> 00:37:08,100
that has no hWnd
associated with it, no window.

968
00:37:08,100 --> 00:37:10,100
Instead the rendering engine
just asks it,

969
00:37:10,100 --> 00:37:12,000
"Please paint
into this buffer."

970
00:37:12,000 --> 00:37:14,167
And it turns out
that windowless plug-ins

971
00:37:14,167 --> 00:37:15,801
do something interesting.

972
00:37:15,801 --> 00:37:17,734
They actually
do the compositing

973
00:37:17,734 --> 00:37:19,367
inside the plug-in.

974
00:37:19,367 --> 00:37:20,701
What this means is--

975
00:37:20,701 --> 00:37:23,067
And they can be
in the Z-order of CSS.

976
00:37:23,067 --> 00:37:26,367
And so what this means
is that as WebKit is painting

977
00:37:26,367 --> 00:37:28,067
and it encounters a plug-in,

978
00:37:28,067 --> 00:37:29,634
it sort of stops,
asks the plug-in,

979
00:37:29,634 --> 00:37:30,934
"Now please draw your pixels,"

980
00:37:30,934 --> 00:37:32,701
and then WebKit
continues painting on top.

981
00:37:32,701 --> 00:37:34,400
So you get
this interesting stack.

982
00:37:34,400 --> 00:37:36,000
And so if we were
trying to achieve,

983
00:37:36,000 --> 00:37:39,467
as I mentioned earlier on,
good asynchronous communication

984
00:37:39,467 --> 00:37:42,000
between our processes
and asynchronous separation,

985
00:37:42,000 --> 00:37:43,734
here, rendering
windowless plug-ins,

986
00:37:43,734 --> 00:37:45,734
is a case
where we don't have that.

987
00:37:45,734 --> 00:37:47,501
So our solution
was to keep a cache

988
00:37:47,501 --> 00:37:50,467
or what the windowless
plug-in rendered last time

989
00:37:50,467 --> 00:37:51,934
in the rendering process,

990
00:37:51,934 --> 00:37:53,868
so that when we're painting
in WebKit,

991
00:37:53,868 --> 00:37:56,334
he can quickly just paint
from that cached representation

992
00:37:56,334 --> 00:37:57,968
of the plug-in.

993
00:37:57,968 --> 00:38:00,133
And once we implemented this,
we got a much better performance

994
00:38:00,133 --> 00:38:01,701
for windowless plug-ins.

995
00:38:01,701 --> 00:38:03,634
Of course you suffer
a frame rate hit

996
00:38:03,634 --> 00:38:05,267
for windowless animations,

997
00:38:05,267 --> 00:38:08,667
but overall the results
are much better.

998
00:38:08,667 --> 00:38:11,501
Another big challenge
with all of this is porting,

999
00:38:11,501 --> 00:38:14,934
because NPAPI is not
a platform-independent API.

1000
00:38:14,934 --> 00:38:17,701
It's really just glue,
bridging glue,

1001
00:38:17,701 --> 00:38:21,767
binding the browser
to other native APIs

1002
00:38:21,767 --> 00:38:23,467
for rendering.

1003
00:38:23,467 --> 00:38:27,400
And so the work required
to support Mac and Linux

1004
00:38:27,400 --> 00:38:29,367
is similar magnitude
to the work

1005
00:38:29,367 --> 00:38:30,701
that was required
to support Windows,

1006
00:38:30,701 --> 00:38:33,234
and it's very challenging.

1007
00:38:33,234 --> 00:38:34,467
But it's coming along.

1008
00:38:34,467 --> 00:38:36,300
The current Chromium
Max and Linux builds

1009
00:38:36,300 --> 00:38:38,667
do not yet have plug-ins
enabled for this reason,

1010
00:38:38,667 --> 00:38:40,868
but they're in development

1011
00:38:40,868 --> 00:38:44,167
and can be enabled
through a switch, I believe.

1012
00:38:44,167 --> 00:38:49,200
So I want to talk
a little bit about WebKit,

1013
00:38:49,200 --> 00:38:51,467
just briefly about WebKit.

1014
00:38:51,467 --> 00:38:53,367
So WebKit,
for those who don't know,

1015
00:38:53,367 --> 00:38:55,601
is comprised of,
what I'd say,

1016
00:38:55,601 --> 00:38:57,400
is about three major modules.

1017
00:38:57,400 --> 00:38:58,701
There's JavaScriptCore,

1018
00:38:58,701 --> 00:39:00,167
the WebKit's
JavaScript engine.

1019
00:39:00,167 --> 00:39:02,033
This is obviously
what Chrome doesn't use.

1020
00:39:02,033 --> 00:39:03,801
We use V8 instead.

1021
00:39:03,801 --> 00:39:06,267
WebCore represents
all of the code

1022
00:39:06,267 --> 00:39:09,033
to do the HTML, CSS,
and DOM rendering.

1023
00:39:09,033 --> 00:39:12,167
SVG is at this layer
and other features.

1024
00:39:12,167 --> 00:39:16,000
A lot of the new
API's database and so on

1025
00:39:16,000 --> 00:39:18,501
are at this layer.

1026
00:39:18,501 --> 00:39:20,400
And then there's
the WebKit layer to WebKit,

1027
00:39:20,400 --> 00:39:22,334
which is the API layer.

1028
00:39:22,334 --> 00:39:25,634
And we don't use this because
the layers that exist here

1029
00:39:25,634 --> 00:39:27,267
in the WebKit repository

1030
00:39:27,267 --> 00:39:30,033
are things like
a COM API to WebKit,

1031
00:39:30,033 --> 00:39:32,267
an objective CAPI
to WebKit,

1032
00:39:32,267 --> 00:39:34,200
a GDK API to WebKit,

1033
00:39:34,200 --> 00:39:35,234
a QT API to WebKit,

1034
00:39:35,234 --> 00:39:37,767
wxWidgets API to WebKit.

1035
00:39:37,767 --> 00:39:39,467
None of those
are really appropriate

1036
00:39:39,467 --> 00:39:41,267
for our use case

1037
00:39:41,267 --> 00:39:43,200
where we need it
to run the renderer

1038
00:39:43,200 --> 00:39:45,467
in this insulated world
in the sandbox

1039
00:39:45,467 --> 00:39:47,334
where it really doesn't
have access to the system.

1040
00:39:47,334 --> 00:39:49,534
And so there's any native
toolkit you can imagine,

1041
00:39:49,534 --> 00:39:51,334
or any even
cross-platform toolkit,

1042
00:39:51,334 --> 00:39:53,534
that, under the hood,
really deals in native widgets

1043
00:39:53,534 --> 00:39:55,033
just wouldn't work.

1044
00:39:55,033 --> 00:39:56,701
So, for us,
we were not able to use

1045
00:39:56,701 --> 00:39:58,100
the existing embedding APIs,

1046
00:39:58,100 --> 00:39:59,601
but we had to have our own.

1047
00:39:59,601 --> 00:40:01,167
And so we're
building out own

1048
00:40:01,167 --> 00:40:03,067
that we will be putting into
the WebKit repository

1049
00:40:03,067 --> 00:40:06,801
in good time.

1050
00:40:06,801 --> 00:40:09,067
So if you were to look
into the WebCore reposit--

1051
00:40:09,067 --> 00:40:11,100
WebCore directory today,

1052
00:40:11,100 --> 00:40:13,434
you would see some
interesting pound defines.

1053
00:40:13,434 --> 00:40:15,734
Things for, like,
PLATFORM(CHROMIUM)

1054
00:40:15,734 --> 00:40:20,701
which represents changes
that we made to WebKit

1055
00:40:20,701 --> 00:40:23,133
to support
Chromium-specific things.

1056
00:40:23,133 --> 00:40:24,400
PLATFORM(SKIA),

1057
00:40:24,400 --> 00:40:26,601
again for Skia-specific
things.

1058
00:40:26,601 --> 00:40:30,133
Basically WebCore
has a graphics layer

1059
00:40:30,133 --> 00:40:32,667
where you are to implement
a graphics context.

1060
00:40:32,667 --> 00:40:34,200
And so we have
a Skia implementation

1061
00:40:34,200 --> 00:40:35,634
to graphics contexts.

1062
00:40:35,634 --> 00:40:38,234
USE(V8) is the pound defined
to select V8.

1063
00:40:38,234 --> 00:40:42,567
The V8 bindings
all live inside of WebCore.

1064
00:40:42,567 --> 00:40:44,234
Mostly.

1065
00:40:44,234 --> 00:40:46,167
WebKit versions.

1066
00:40:46,167 --> 00:40:50,100
So for when we shipped
Chrome 1,

1067
00:40:50,100 --> 00:40:51,901
when we did
our initial launch,

1068
00:40:51,901 --> 00:40:53,901
we were very nervous
about our selection

1069
00:40:53,901 --> 00:40:55,801
of the version of WebKit.

1070
00:40:55,801 --> 00:40:58,801
We wanted to make sure
that we didn't inadvertently

1071
00:40:58,801 --> 00:41:01,400
introduce web compatibility
issues.

1072
00:41:01,400 --> 00:41:04,667
So Safari 3 had shipped
earlier in the year,

1073
00:41:04,667 --> 00:41:07,534
and we chose to continue
shipping WebKit

1074
00:41:07,534 --> 00:41:10,300
based on the version of WebKit
that Safari 3 shipped,

1075
00:41:10,300 --> 00:41:12,300
mostly just to achieve
compatibility.

1076
00:41:12,300 --> 00:41:15,300
We didn't want to worry about
being on a different WebKit

1077
00:41:15,300 --> 00:41:17,467
that had changed.

1078
00:41:17,467 --> 00:41:18,834
Again for Chrome 2,

1079
00:41:18,834 --> 00:41:20,901
we're pretty lined up
with Safari 4's WebKit.

1080
00:41:20,901 --> 00:41:22,934
I think we've taken
a slightly older--

1081
00:41:22,934 --> 00:41:25,868
a slightly newer version
of WebKit than they shipped.

1082
00:41:25,868 --> 00:41:31,100
And one of the big hurdles
for Chrome 2

1083
00:41:31,100 --> 00:41:34,067
was actually moving
from this older WebKit

1084
00:41:34,067 --> 00:41:35,901
to the newer WebKit.

1085
00:41:35,901 --> 00:41:37,667
And so that has a lot to do

1086
00:41:37,667 --> 00:41:40,634
with what I want
to talk about next.

1087
00:41:40,634 --> 00:41:42,601
It's WebKit development.

1088
00:41:42,601 --> 00:41:44,534
So members
of the Chromium team

1089
00:41:44,534 --> 00:41:48,400
are very active
in the WebKit community now.

1090
00:41:48,400 --> 00:41:51,234
We have a number of reviewers,
a number of contributors,

1091
00:41:51,234 --> 00:41:55,501
and we're just trying
to increase our presence

1092
00:41:55,501 --> 00:41:58,133
and increase our contribution
to the WebKit project.

1093
00:41:58,133 --> 00:42:02,200
So we believe strongly
in WebKit being--

1094
00:42:02,200 --> 00:42:04,834
We're very happy
to have used WebKit.

1095
00:42:04,834 --> 00:42:08,934
We're just very much enjoying
all the things it does for us,

1096
00:42:08,934 --> 00:42:11,701
and we want to continue
to contribute to it.

1097
00:42:11,701 --> 00:42:13,400
I say status: unforked.

1098
00:42:13,400 --> 00:42:15,868
So when we initially launched,

1099
00:42:15,868 --> 00:42:19,067
because we were on
an older version of WebKit

1100
00:42:19,067 --> 00:42:21,601
and we needed
to fix problems,

1101
00:42:21,601 --> 00:42:25,701
we accumulated a large number
of forks to WebKit.

1102
00:42:25,701 --> 00:42:28,467
And indeed to even
support V8 in WebKit,

1103
00:42:28,467 --> 00:42:31,400
we needed to make
modifications.

1104
00:42:31,400 --> 00:42:34,200
So in order to get
to a point where we could

1105
00:42:34,200 --> 00:42:35,767
actually work
directly on WebKit

1106
00:42:35,767 --> 00:42:38,300
and be a first-class citizen
in the WebKit world,

1107
00:42:38,300 --> 00:42:39,834
we needed to unfork.

1108
00:42:39,834 --> 00:42:42,734
And so we went through
this massive,

1109
00:42:42,734 --> 00:42:44,434
I call massive, undertaking

1110
00:42:44,434 --> 00:42:46,567
to sort of push all
of our changes into WebKit

1111
00:42:46,567 --> 00:42:49,767
and refactor things so that
our changes could live there

1112
00:42:49,767 --> 00:42:52,968
and finally end up in a world
where we're able to work

1113
00:42:52,968 --> 00:42:54,667
with Chrome,
develop Chrome,

1114
00:42:54,667 --> 00:42:56,734
on the tip of tree
of WebKit

1115
00:42:56,734 --> 00:42:58,601
alongside of other developers

1116
00:42:58,601 --> 00:43:00,234
who are developing
tip of tree WebKit

1117
00:43:00,234 --> 00:43:02,934
using Safari.

1118
00:43:02,934 --> 00:43:05,067
So our focus of WebKit
development going forward

1119
00:43:05,067 --> 00:43:06,367
is, as I mentioned before,

1120
00:43:06,367 --> 00:43:09,300
we want to establish
a WebKit API for Chromium.

1121
00:43:09,300 --> 00:43:12,000
Our goals here
are very simple

1122
00:43:12,000 --> 00:43:15,701
We want to build a very simple
C++ API to WebKit

1123
00:43:15,701 --> 00:43:19,734
that is not dependent
on any other toolkit

1124
00:43:19,734 --> 00:43:21,267
other than WebCore,
all right?

1125
00:43:21,267 --> 00:43:25,167
That's basically just about
a very thin layer to WebKit

1126
00:43:25,167 --> 00:43:27,467
so that if anybody else
wants to embed WebKit,

1127
00:43:27,467 --> 00:43:29,000
they have
an easy path forward.

1128
00:43:29,000 --> 00:43:32,033
It's not a matter of picking
a certain flavor of toolkit

1129
00:43:32,033 --> 00:43:33,834
that is compatible
with your world,

1130
00:43:33,834 --> 00:43:35,501
but here,
suppose you just want

1131
00:43:35,501 --> 00:43:40,767
a simple API
that's not particular,

1132
00:43:40,767 --> 00:43:42,901
you could use this as well.

1133
00:43:42,901 --> 00:43:45,400
We have a lot of folks
working on open web platform,

1134
00:43:45,400 --> 00:43:46,667
HTML 5, et cetera.

1135
00:43:46,667 --> 00:43:48,000
Web workers
is included in that

1136
00:43:48,000 --> 00:43:49,367
and a number of other things,

1137
00:43:49,367 --> 00:43:51,667
like the video feature
that was just recently launched

1138
00:43:51,667 --> 00:43:54,300
in the Chrome developer
channel.

1139
00:43:54,300 --> 00:43:56,801
And of course
we're very interested

1140
00:43:56,801 --> 00:43:58,300
in improving web compat.

1141
00:43:58,300 --> 00:44:00,667
I think web compat is probably
one of the number one challenges

1142
00:44:00,667 --> 00:44:03,167
for any fledging browser,

1143
00:44:03,167 --> 00:44:05,033
certainly for
any rendering engine

1144
00:44:05,033 --> 00:44:06,601
that doesn't have
the kind of market share

1145
00:44:06,601 --> 00:44:09,701
that MSHTML has
or Gekko has.

1146
00:44:09,701 --> 00:44:11,567
And so the things
that we can do here

1147
00:44:11,567 --> 00:44:13,968
to make a difference
I think would go a long way.

1148
00:44:13,968 --> 00:44:16,400
I think WebKit is fortunately
getting to the point now

1149
00:44:16,400 --> 00:44:17,834
where it's--

1150
00:44:17,834 --> 00:44:20,200
you know, it's approaching
10% market share

1151
00:44:20,200 --> 00:44:22,601
if you add up all the browser,
mobile included,

1152
00:44:22,601 --> 00:44:24,100
that embed WebKit.

1153
00:44:24,100 --> 00:44:27,567
And so once--
my experience with Firefox

1154
00:44:27,567 --> 00:44:30,234
tells me that, you know,
once you get to that 10% point,

1155
00:44:30,234 --> 00:44:33,334
that's when people
don't have a choice but to care.

1156
00:44:33,334 --> 00:44:36,968
Because if one out of ten
users to their website

1157
00:44:36,968 --> 00:44:38,734
can't view their website

1158
00:44:38,734 --> 00:44:41,033
or can't purchase something
off of their site,

1159
00:44:41,033 --> 00:44:43,400
well, then they'll feel that

1160
00:44:43,400 --> 00:44:45,067
in a financial manner
at least.

1161
00:44:45,067 --> 00:44:48,267
And so the hope is that
once you reach that threshold,

1162
00:44:48,267 --> 00:44:49,834
suddenly it'll be
a snowball effect

1163
00:44:49,834 --> 00:44:51,701
and people will care
and people will--

1164
00:44:51,701 --> 00:44:56,133
and compatibility problems
will disappear faster.

1165
00:44:56,133 --> 00:44:58,601
And of course we continue
to be very interested

1166
00:44:58,601 --> 00:45:00,534
in how we can
improve performance.

1167
00:45:00,534 --> 00:45:02,000
Performance is--

1168
00:45:02,000 --> 00:45:03,501
Speed is important

1169
00:45:03,501 --> 00:45:07,133
to the whole essence
of Chrome.

1170
00:45:07,133 --> 00:45:08,334
Open web platform.

1171
00:45:08,334 --> 00:45:09,701
Just a few
more notes about that,

1172
00:45:09,701 --> 00:45:11,701
some of the things
that are in progress.

1173
00:45:11,701 --> 00:45:14,701
Audio/video, well,
you saw the recent release.

1174
00:45:14,701 --> 00:45:17,701
And we're very excited
about that.

1175
00:45:17,701 --> 00:45:19,000
There's lots more
that can be done

1176
00:45:19,000 --> 00:45:22,300
to improve HTML 5
video support in Chrome.

1177
00:45:22,300 --> 00:45:23,601
So we'll be working on that.

1178
00:45:23,601 --> 00:45:25,267
Application cache,
database,

1179
00:45:25,267 --> 00:45:26,734
local storage,
session storage.

1180
00:45:26,734 --> 00:45:29,801
These are all features about
enabling offline applications.

1181
00:45:29,801 --> 00:45:32,834
So very excited to adopt
the same APIs

1182
00:45:32,834 --> 00:45:35,133
as all the other
major browsers.

1183
00:45:35,133 --> 00:45:36,634
Some of these things are
already enabled in WebKit.

1184
00:45:36,634 --> 00:45:38,000
So you might say,

1185
00:45:38,000 --> 00:45:39,834
"Well, how come Chrome
doesn't have them already?

1186
00:45:39,834 --> 00:45:41,501
Safari 4 has it."

1187
00:45:41,501 --> 00:45:43,100
And, you know,
it turns out

1188
00:45:43,100 --> 00:45:45,467
that when you throw a sandbox
around a rendering engine

1189
00:45:45,467 --> 00:45:47,534
and you divide it up
into multiple processes,

1190
00:45:47,534 --> 00:45:50,133
that some of these things
become much more complicated

1191
00:45:50,133 --> 00:45:52,234
to support.

1192
00:45:52,234 --> 00:45:53,934
What do these have in common?

1193
00:45:53,934 --> 00:45:56,100
Well, application cache,
database, local storage,

1194
00:45:56,100 --> 00:45:57,934
they're all touching
the disk.

1195
00:45:57,934 --> 00:45:59,467
So there's file system access.

1196
00:45:59,467 --> 00:46:01,367
File system access
that needs to be proxied

1197
00:46:01,367 --> 00:46:03,033
or managed in some way

1198
00:46:03,033 --> 00:46:05,100
so that these
rendering processes

1199
00:46:05,100 --> 00:46:08,934
can securely access
these APIs.

1200
00:46:08,934 --> 00:46:11,033
So these are all
in development.

1201
00:46:11,033 --> 00:46:14,200
And the way we tend to develop
new features in Chrome

1202
00:46:14,200 --> 00:46:17,400
is that we put them
into the main line

1203
00:46:17,400 --> 00:46:19,200
but behind a command line flag

1204
00:46:19,200 --> 00:46:21,567
so that they're not
actually enabled by default

1205
00:46:21,567 --> 00:46:23,000
until they're ready.

1206
00:46:23,000 --> 00:46:24,467
But by having them
in the main line,

1207
00:46:24,467 --> 00:46:26,968
it means that as Dev Channel
releases go out,

1208
00:46:26,968 --> 00:46:28,868
Beta channel releases go out,

1209
00:46:28,868 --> 00:46:31,367
or stable pushes even happen,
these features are there,

1210
00:46:31,367 --> 00:46:33,200
and people who are interested

1211
00:46:33,200 --> 00:46:35,200
can set
the command line option

1212
00:46:35,200 --> 00:46:37,000
to turn it on to try it out
to give us feedback.

1213
00:46:37,000 --> 00:46:38,834
So we don't have
to require people

1214
00:46:38,834 --> 00:46:41,234
to do custom builds in order
to try out new features

1215
00:46:41,234 --> 00:46:42,400
and give us feedback.

1216
00:46:42,400 --> 00:46:44,534
They can just take
the standard build,

1217
00:46:44,534 --> 00:46:45,868
try it out,
give us feedback.

1218
00:46:45,868 --> 00:46:50,968
And this is huge for supporting
a community of testers.

1219
00:46:50,968 --> 00:46:52,734
Notifications
is a new thing

1220
00:46:52,734 --> 00:46:54,634
that has a lot of interest.

1221
00:46:54,634 --> 00:46:57,434
It's all about trying
to make it possible

1222
00:46:57,434 --> 00:47:00,968
for web applications
to do better notifications

1223
00:47:00,968 --> 00:47:04,634
to the user,
better than window.alert.

1224
00:47:04,634 --> 00:47:06,200
Window.alert
is very, you know,

1225
00:47:06,200 --> 00:47:08,434
a very unfortunate API.

1226
00:47:08,434 --> 00:47:10,434
It sure would be nice
if Calendar could have

1227
00:47:10,434 --> 00:47:12,701
a less annoying,
a less obtrusive way

1228
00:47:12,701 --> 00:47:15,434
of notifying the user that
there is a meeting coming up,

1229
00:47:15,434 --> 00:47:17,534
but a notification
that is still effective

1230
00:47:17,534 --> 00:47:20,934
at getting your attention.

1231
00:47:20,934 --> 00:47:23,501
So that's the kind of stuff
that we're working on.

1232
00:47:23,501 --> 00:47:25,767
And of course web workers
I talked about before.

1233
00:47:25,767 --> 00:47:27,334
There's this idea
of shared workers,

1234
00:47:27,334 --> 00:47:29,701
which is really interesting
that's still being worked out,

1235
00:47:29,701 --> 00:47:32,200
details are being worked out,
but sure would be--

1236
00:47:32,200 --> 00:47:35,467
It would be very powerful
if you could have a worker

1237
00:47:35,467 --> 00:47:38,734
that lives on beyond--

1238
00:47:38,734 --> 00:47:40,501
Well, I should back up
and make sure everybody's

1239
00:47:40,501 --> 00:47:41,767
familiar with workers.

1240
00:47:41,767 --> 00:47:43,801
This is the idea
of background threads

1241
00:47:43,801 --> 00:47:45,667
where you can run
JavaScript on.

1242
00:47:45,667 --> 00:47:48,167
A dedicated worker
is one that a web page

1243
00:47:48,167 --> 00:47:49,467
just creates for itself.

1244
00:47:49,467 --> 00:47:50,634
So it wants
a background thread,

1245
00:47:50,634 --> 00:47:52,000
he can create
a dedicated worker.

1246
00:47:52,000 --> 00:47:54,200
When the page goes away,
the dedicated worker goes away.

1247
00:47:54,200 --> 00:47:55,634
Persistent workers.

1248
00:47:55,634 --> 00:47:58,400
Well, there the worker
can live on a little longer.

1249
00:47:58,400 --> 00:48:01,634
But shared workers are kind of
like persistent workers,

1250
00:48:01,634 --> 00:48:04,267
but different
in that they have a name.

1251
00:48:04,267 --> 00:48:06,367
And you can find them lazily.

1252
00:48:06,367 --> 00:48:08,067
You can find them
and connect to them.

1253
00:48:08,067 --> 00:48:10,200
And so it could give
web applications

1254
00:48:10,200 --> 00:48:12,434
a very powerful way
to have a context,

1255
00:48:12,434 --> 00:48:13,968
a JavaScript context

1256
00:48:13,968 --> 00:48:15,968
that's hidden
and off to the side

1257
00:48:15,968 --> 00:48:17,467
that they can
later connect to.

1258
00:48:17,467 --> 00:48:19,100
So you can imagine
a web application

1259
00:48:19,100 --> 00:48:22,634
might run a portion
of its back end there

1260
00:48:22,634 --> 00:48:24,234
in a shared worker

1261
00:48:24,234 --> 00:48:27,100
and let the actual web pages
just be front ends

1262
00:48:27,100 --> 00:48:30,767
that render the data that
that shared worker manages.

1263
00:48:30,767 --> 00:48:34,033
There's a lot of really
interesting ideas in HTML 5

1264
00:48:34,033 --> 00:48:35,434
and an open web platform

1265
00:48:35,434 --> 00:48:40,234
that we're very excited
to be implementing.

1266
00:48:40,234 --> 00:48:42,734
So I just want to briefly
talk about the network stack

1267
00:48:42,734 --> 00:48:44,300
since I mentioned before

1268
00:48:44,300 --> 00:48:46,200
that that's
a very important element

1269
00:48:46,200 --> 00:48:48,033
of browser architecture.

1270
00:48:48,033 --> 00:48:50,234
Making a better wheel.

1271
00:48:50,234 --> 00:48:52,734
So one wonders,

1272
00:48:52,734 --> 00:48:55,567
why go and invent
another networking stack?

1273
00:48:55,567 --> 00:48:57,000
There's so many out there.

1274
00:48:57,000 --> 00:48:59,033
Indeed, when we first
started the project,

1275
00:48:59,033 --> 00:49:00,901
we thought, well,
let's not do this--

1276
00:49:00,901 --> 00:49:03,701
let's not write this code
if we don't have to.

1277
00:49:03,701 --> 00:49:06,734
In fact, can't we just use
the networking stacks

1278
00:49:06,734 --> 00:49:08,400
that ship with
the various operating systems

1279
00:49:08,400 --> 00:49:10,000
that we wish to target?

1280
00:49:10,000 --> 00:49:11,467
So on Windows,
the natural choice

1281
00:49:11,467 --> 00:49:12,567
was probably Wininet.

1282
00:49:12,567 --> 00:49:14,033
That's the networking stack

1283
00:49:14,033 --> 00:49:15,868
under the hood
of Internet Explorer.

1284
00:49:15,868 --> 00:49:18,534
And there's an API to that
that's well established,

1285
00:49:18,534 --> 00:49:20,767
and, well, let's use that.

1286
00:49:20,767 --> 00:49:22,400
And we started
down that path.

1287
00:49:22,400 --> 00:49:25,501
And interestingly enough,
we learned that

1288
00:49:25,501 --> 00:49:27,267
we really needed
to have control

1289
00:49:27,267 --> 00:49:30,200
over our own web cache
and our own cookie store.

1290
00:49:30,200 --> 00:49:31,934
Okay, so Wininet,
you tell it,

1291
00:49:31,934 --> 00:49:34,534
"Don't use your cookies.
We'll supply our own."

1292
00:49:34,534 --> 00:49:36,100
Turning off the cache though

1293
00:49:36,100 --> 00:49:37,901
turned out to be
kind of difficult.

1294
00:49:37,901 --> 00:49:40,400
Well, we wanted to be able
to turn off the cache

1295
00:49:40,400 --> 00:49:42,834
because we needed to be able
to support incognito mode.

1296
00:49:42,834 --> 00:49:44,400
We didn't want it to be able
to turn off the cache

1297
00:49:44,400 --> 00:49:47,033
because if the cache
contained data

1298
00:49:47,033 --> 00:49:49,100
that was fetched
by Internet Explorer,

1299
00:49:49,100 --> 00:49:51,467
then it might be data
specific to Internet Explorer's

1300
00:49:51,467 --> 00:49:53,667
user agent string.

1301
00:49:53,667 --> 00:49:55,167
And so that
could be a problem.

1302
00:49:55,167 --> 00:49:57,133
So we really are in
a situation

1303
00:49:57,133 --> 00:50:00,133
where we have to manage
our own cache.

1304
00:50:00,133 --> 00:50:01,734
And it turns out
that there was no way

1305
00:50:01,734 --> 00:50:03,734
to tell Wininet,
"Hey, look,

1306
00:50:03,734 --> 00:50:07,434
I don't want you to supply
data from your cache."

1307
00:50:07,434 --> 00:50:09,734
And so we then switched
to Winhttp,

1308
00:50:09,734 --> 00:50:11,767
which is another library
that Microsoft ships

1309
00:50:11,767 --> 00:50:14,167
that just provides
the HTTP layer.

1310
00:50:14,167 --> 00:50:15,934
You bring your own cache.
You bring your own cookies.

1311
00:50:15,934 --> 00:50:18,300
Okay, that sounds great.

1312
00:50:18,300 --> 00:50:21,734
And that's actually what
we shipped with in Chrome 1.

1313
00:50:21,734 --> 00:50:24,300
But, you know,
we recognized that there's--

1314
00:50:24,300 --> 00:50:26,534
we were missing opportunities
to improve performance,

1315
00:50:26,534 --> 00:50:31,934
missing opportunities
to improve this layer

1316
00:50:31,934 --> 00:50:34,400
and even to fix
certain bugs.

1317
00:50:34,400 --> 00:50:37,133
And so we set about
developing our own library,

1318
00:50:37,133 --> 00:50:39,601
and that now lives
in src/net/http/

1319
00:50:39,601 --> 00:50:42,200
in the Chromium code base.

1320
00:50:42,200 --> 00:50:45,267
And that's what shipped
in Chrome 2.

1321
00:50:45,267 --> 00:50:47,968
So DNS prefetching is something
we shipped in Chrome 1,

1322
00:50:47,968 --> 00:50:51,801
you've probably heard about,
which is all about predicting

1323
00:50:51,801 --> 00:50:54,033
which host names
you might visit

1324
00:50:54,033 --> 00:50:56,868
so that we can get
the DNS results started earlier.

1325
00:50:56,868 --> 00:51:00,701
This has a very measurable
impact on performance.

1326
00:51:00,701 --> 00:51:03,901
And we've been spending
a lot of energy--

1327
00:51:03,901 --> 00:51:05,701
You know, whenever anybody
checks the little thing,

1328
00:51:05,701 --> 00:51:07,934
helps supply anonymous
usage data to Google

1329
00:51:07,934 --> 00:51:10,501
to make Google Chrome better,

1330
00:51:10,501 --> 00:51:14,200
that anonymous data
is used to help support

1331
00:51:14,200 --> 00:51:16,167
tailoring these kinds
of algorithms,

1332
00:51:16,167 --> 00:51:17,767
understanding
when this is working,

1333
00:51:17,767 --> 00:51:19,734
when it's not working,

1334
00:51:19,734 --> 00:51:22,267
and various other aspects
of Chrome as well.

1335
00:51:22,267 --> 00:51:24,400
So in development,
there's lots of things

1336
00:51:24,400 --> 00:51:25,767
still to be done
for the new network stack--

1337
00:51:25,767 --> 00:51:27,100
feature parity.

1338
00:51:27,100 --> 00:51:28,601
And there's things missing
like sock support,

1339
00:51:28,601 --> 00:51:30,434
IPv6 literals.

1340
00:51:30,434 --> 00:51:32,367
Regular IPv6,
if a host name results,

1341
00:51:32,367 --> 00:51:33,901
IPv6 would work fine,

1342
00:51:33,901 --> 00:51:35,868
but if you actually use
an IPv6 literal,

1343
00:51:35,868 --> 00:51:37,467
there's some little,
subtle bugs.

1344
00:51:37,467 --> 00:51:38,801
We're working out
all those kinks

1345
00:51:38,801 --> 00:51:42,567
or things that are happening
for future releases.

1346
00:51:42,567 --> 00:51:44,834
Other cool new features
that might help--

1347
00:51:44,834 --> 00:51:46,400
that will have a big impact
on performance.

1348
00:51:46,400 --> 00:51:47,801
Sparse caching.

1349
00:51:47,801 --> 00:51:50,167
So video support
really demands the idea

1350
00:51:50,167 --> 00:51:52,167
that you should be able
to advance the movie

1351
00:51:52,167 --> 00:51:53,734
to a certain location

1352
00:51:53,734 --> 00:51:55,067
and start downloading
from there

1353
00:51:55,067 --> 00:51:56,567
and cache all that data.

1354
00:51:56,567 --> 00:51:58,200
Well, we want to still
be able to jump back

1355
00:51:58,200 --> 00:52:00,901
to the old location
and hit the cache again.

1356
00:52:00,901 --> 00:52:04,000
Sparse caching is gonna help
with this a lot.

1357
00:52:04,000 --> 00:52:06,467
This will also improve the way
Acrobat Reader runs

1358
00:52:06,467 --> 00:52:08,467
inside of Chrome,
because Acrobat Reader,

1359
00:52:08,467 --> 00:52:11,934
when you advance to a page,
like the 27th page,

1360
00:52:11,934 --> 00:52:13,534
Acrobat Reader
will ask the browser,

1361
00:52:13,534 --> 00:52:15,901
"Please fetch me the data
at this range."

1362
00:52:15,901 --> 00:52:17,834
And so we want to be able
to cache that.

1363
00:52:17,834 --> 00:52:20,334
Other browsers don't cache
the ranges like that

1364
00:52:20,334 --> 00:52:21,968
because managing
a sparse cache

1365
00:52:21,968 --> 00:52:24,100
is actually
pretty complicated.

1366
00:52:24,100 --> 00:52:26,400
There's a bunch of other ideas
we have that we're brewing

1367
00:52:26,400 --> 00:52:29,100
and trying to actually
test out.

1368
00:52:29,100 --> 00:52:30,767
Looking at ways
that we can actually employ

1369
00:52:30,767 --> 00:52:32,968
HTTP pipelining
in a manner that's safe.

1370
00:52:32,968 --> 00:52:34,567
Looking at ways
that we can improve

1371
00:52:34,567 --> 00:52:36,234
the establishment
of TCP connections,

1372
00:52:36,234 --> 00:52:37,868
'cause these are--

1373
00:52:37,868 --> 00:52:40,601
TCP connection establishment
is a point at which

1374
00:52:40,601 --> 00:52:42,267
you can really lose
a lot of time.

1375
00:52:42,267 --> 00:52:45,434
And if anything you can do
to kinda like hide that time

1376
00:52:45,434 --> 00:52:48,734
or avoid paying that cost,
you know, when the user

1377
00:52:48,734 --> 00:52:50,968
actually tries to go somewhere
would be beneficial.

1378
00:52:50,968 --> 00:52:52,501
But of course
we have to be very careful

1379
00:52:52,501 --> 00:52:55,000
not to put too much burden
on servers and things like that.

1380
00:52:55,000 --> 00:52:59,601
So parallel proxy auto-config.

1381
00:52:59,601 --> 00:53:02,167
Well, if you're ever using
proxy auto-config,

1382
00:53:02,167 --> 00:53:04,200
you know that performance
can be a real problem with it.

1383
00:53:04,200 --> 00:53:07,300
And so all of us at Google
use a proxy auto-config,

1384
00:53:07,300 --> 00:53:09,100
and so we feel this pain
every day,

1385
00:53:09,100 --> 00:53:10,567
and so we really want
to do something about it.

1386
00:53:10,567 --> 00:53:14,000
And hopefully it benefits
other people as well.

1387
00:53:14,000 --> 00:53:15,434
And that's it.

1388
00:53:15,434 --> 00:53:18,601
I want to open
the floor to questions.

1389
00:53:18,601 --> 00:53:23,734
And let me know
what you're interested in.

1390
00:53:23,734 --> 00:53:25,467
man: Hi.

1391
00:53:25,467 --> 00:53:28,634
As a script developer
in JavaScript,

1392
00:53:28,634 --> 00:53:31,400
I'm not that familiar
with the Chrome yet.

1393
00:53:31,400 --> 00:53:34,133
When I write
an XML HTTP request,

1394
00:53:34,133 --> 00:53:36,400
I can do it synchronous
or asynchronous.

1395
00:53:36,400 --> 00:53:38,501
And the synchronous
is usually blocking

1396
00:53:38,501 --> 00:53:40,834
based on IE.

1397
00:53:40,834 --> 00:53:44,634
The new Firefox, I realized,
it's non-blocking.

1398
00:53:44,634 --> 00:53:46,434
Is it the same with Chrome?

1399
00:53:46,434 --> 00:53:47,734
Fisher:
So it turns out that

1400
00:53:47,734 --> 00:53:49,634
that's a very interesting
thing you mentioned.

1401
00:53:49,634 --> 00:53:51,467
I'm actually the developer
who implemented

1402
00:53:51,467 --> 00:53:53,267
Firefox's behavior.

1403
00:53:53,267 --> 00:53:56,501
And I kind of regret it,
and I'll explain why.

1404
00:53:56,501 --> 00:53:59,033
Because JavaScript
has the assumption

1405
00:53:59,033 --> 00:54:01,968
of run to completion,
being single-threaded.

1406
00:54:01,968 --> 00:54:03,200
But if you--

1407
00:54:03,200 --> 00:54:06,634
If JavaScript blocks on
XML HTTP requests

1408
00:54:06,634 --> 00:54:09,000
to do a synchronous network IO,

1409
00:54:09,000 --> 00:54:11,868
it still looks like
a function call to JavaScript.

1410
00:54:11,868 --> 00:54:13,968
And if you interrupt
that function call

1411
00:54:13,968 --> 00:54:16,567
with, like, running
another JavaScript--

1412
00:54:16,567 --> 00:54:18,701
some other thread
of JavaScript somewhere--

1413
00:54:18,701 --> 00:54:20,267
I mean, it's all
on the same real thread,

1414
00:54:20,267 --> 00:54:22,601
but to the programmer it looks
like somehow JavaScript,

1415
00:54:22,601 --> 00:54:24,501
in another context,
was running

1416
00:54:24,501 --> 00:54:26,467
in the middle
of this function call.

1417
00:54:26,467 --> 00:54:28,634
And so it breaks
the run to completion behavior

1418
00:54:28,634 --> 00:54:30,734
that you come to expect.

1419
00:54:30,734 --> 00:54:35,501
And so really I worry that
the Firefox implementation--

1420
00:54:35,501 --> 00:54:38,300
You know, I was a fan of it
at the time,

1421
00:54:38,300 --> 00:54:42,434
because it frees the UI
from being locked up.

1422
00:54:42,434 --> 00:54:44,234
But I worry
that it would result

1423
00:54:44,234 --> 00:54:47,467
in some very strange bugs
for web developers,

1424
00:54:47,467 --> 00:54:49,968
because when
they expect their program

1425
00:54:49,968 --> 00:54:51,467
to just run
like a sequential program,

1426
00:54:51,467 --> 00:54:53,067
it's suddenly not.

1427
00:54:53,067 --> 00:54:56,400
And so it is
a very big concern to me.

1428
00:54:56,400 --> 00:54:58,100
In Chrome,
we took the approach of,

1429
00:54:58,100 --> 00:55:01,434
well, the rendering engine
is a child process,

1430
00:55:01,434 --> 00:55:02,734
and we have a bitmap

1431
00:55:02,734 --> 00:55:04,701
of the recent
representation of it.

1432
00:55:04,701 --> 00:55:06,667
So when the web page says

1433
00:55:06,667 --> 00:55:09,734
XML HTTP request send,
in a synchronous manner,

1434
00:55:09,734 --> 00:55:12,234
we just let that process
suspend itself.

1435
00:55:12,234 --> 00:55:13,834
And during that IO time,

1436
00:55:13,834 --> 00:55:16,634
we show the old representation
of the page.

1437
00:55:16,634 --> 00:55:19,801
Of course the page is not
interactive at this time.

1438
00:55:19,801 --> 00:55:22,033
But I feel like that's
probably the right way

1439
00:55:22,033 --> 00:55:23,434
for it to behave.

1440
00:55:23,434 --> 00:55:27,067
And basically my belief
is that synchronous XHR

1441
00:55:27,067 --> 00:55:29,234
is really a pretty evil API.

1442
00:55:29,234 --> 00:55:31,067
It's not one that works well
with the web.

1443
00:55:31,067 --> 00:55:32,167
The web is asynchronous.

1444
00:55:32,167 --> 00:55:34,467
Asynchronous APIs
work much more naturally

1445
00:55:34,467 --> 00:55:37,267
in a browser environment.

1446
00:55:37,267 --> 00:55:39,100
So--So that's--

1447
00:55:39,100 --> 00:55:41,300
I can imagine Chrome
doing smarter things though

1448
00:55:41,300 --> 00:55:42,501
in the future.

1449
00:55:42,501 --> 00:55:44,467
Like, for example,
giving the user some UI

1450
00:55:44,467 --> 00:55:46,834
so that they could interrupt
a synchronous XHR

1451
00:55:46,834 --> 00:55:48,434
that's taking too long.

1452
00:55:48,434 --> 00:55:50,067
Today, the only way
to interrupt

1453
00:55:50,067 --> 00:55:51,934
a synchronous XHR in Chrome
that's taking too long

1454
00:55:51,934 --> 00:55:53,334
is to close the tab.

1455
00:55:53,334 --> 00:55:55,400
Close the tab,
you kill the process.

1456
00:55:55,400 --> 00:55:56,734
But if you could interrupt it

1457
00:55:56,734 --> 00:55:58,834
and return control
to a JavaScript with an error,

1458
00:55:58,834 --> 00:56:02,300
that seems like it'd be better.

1459
00:56:02,300 --> 00:56:05,267
Any other questions?

1460
00:56:05,267 --> 00:56:06,868
man: You know,
I almost want to encourage you

1461
00:56:06,868 --> 00:56:09,901
to do some alternative
to NPAPI.

1462
00:56:09,901 --> 00:56:12,267
I've struggled
with trying to port across

1463
00:56:12,267 --> 00:56:15,367
the different browsers
on PGP.

1464
00:56:15,367 --> 00:56:17,634
And we've been trying
to do something

1465
00:56:17,634 --> 00:56:22,000
to look at secure text,
encrypted text, encrypted--

1466
00:56:22,000 --> 00:56:24,033
you know, like an embedded
encrypted content

1467
00:56:24,033 --> 00:56:26,033
and display it.

1468
00:56:26,033 --> 00:56:28,100
And it's just--
it's really difficult

1469
00:56:28,100 --> 00:56:30,000
to go across
the different browsers.

1470
00:56:30,000 --> 00:56:31,400
There's a lot
of little fallbacks.

1471
00:56:31,400 --> 00:56:33,267
NPAPI--Well, put it this way.

1472
00:56:33,267 --> 00:56:34,968
If you're gonna do it,
could you, like, at least

1473
00:56:34,968 --> 00:56:37,133
put out some sample code,
one that compiles

1474
00:56:37,133 --> 00:56:38,868
and actually works
in the different browsers

1475
00:56:38,868 --> 00:56:40,100
and does something--

1476
00:56:40,100 --> 00:56:41,367
Fisher: I agree with you.

1477
00:56:41,367 --> 00:56:42,934
NPAPI is really the bane

1478
00:56:42,934 --> 00:56:45,667
of developers
who have to deal with it.

1479
00:56:45,667 --> 00:56:47,701
I wish there was
something better as well.

1480
00:56:47,701 --> 00:56:49,601
man: Well, I mean,
even the Safari--

1481
00:56:49,601 --> 00:56:53,000
The Safari, you know,
WebKit plug-in thing is way--

1482
00:56:53,000 --> 00:56:55,334
at least that works
on Safari.

1483
00:56:55,334 --> 00:56:56,767
Maybe leverage some of that.

1484
00:56:56,767 --> 00:56:58,801
Fisher: Yeah,
I'm very interested

1485
00:56:58,801 --> 00:57:00,334
in a better solution

1486
00:57:00,334 --> 00:57:02,567
and one that is well documented
and full of samples

1487
00:57:02,567 --> 00:57:04,667
that actually make sense.

1488
00:57:04,667 --> 00:57:06,167
Next question.

1489
00:57:06,167 --> 00:57:07,901
man: I have a question
about your strategy

1490
00:57:07,901 --> 00:57:10,167
for increasing compatibility,

1491
00:57:10,167 --> 00:57:11,667
like, with the rendering
in Safari.

1492
00:57:11,667 --> 00:57:13,434
It seems like, in Safari,

1493
00:57:13,434 --> 00:57:14,901
when they're about
to make a release,

1494
00:57:14,901 --> 00:57:16,367
they do, like,
a WebKit tag,

1495
00:57:16,367 --> 00:57:18,334
and then maybe they commit
into that tag.

1496
00:57:18,334 --> 00:57:21,968
What do you do to, like,
ensure that your--

1497
00:57:21,968 --> 00:57:23,934
whatever you do for a release

1498
00:57:23,934 --> 00:57:27,834
is compatible
with their rendering?

1499
00:57:27,834 --> 00:57:29,467
Fisher: If I understood
the question right,

1500
00:57:29,467 --> 00:57:30,801
you're saying what happens
if, like,

1501
00:57:30,801 --> 00:57:33,300
a new tag is introduced
that's sort of half-baked?

1502
00:57:33,300 --> 00:57:35,234
man:
Or what do you do, like--

1503
00:57:35,234 --> 00:57:37,567
I guess what's your strategy
before--

1504
00:57:37,567 --> 00:57:40,400
When you're deciding on,
you know, where to--

1505
00:57:40,400 --> 00:57:42,300
what revision to go off of.

1506
00:57:42,300 --> 00:57:43,634
Fisher: Yes.

1507
00:57:43,634 --> 00:57:45,501
Okay, yeah, so it's
a very tough question.

1508
00:57:45,501 --> 00:57:48,634
Like, because we are trying
to release early release often

1509
00:57:48,634 --> 00:57:51,000
and not just be beholden

1510
00:57:51,000 --> 00:57:53,100
to when Apple decides
to launch WebKit,

1511
00:57:53,100 --> 00:57:55,033
it does mean
that we potentially pick up

1512
00:57:55,033 --> 00:57:57,267
half-baked APIs,
half-baked things.

1513
00:57:57,267 --> 00:57:59,167
But fortunately the way
WebKit community tends to work

1514
00:57:59,167 --> 00:58:01,234
is that they hide those things
behind a pound define.

1515
00:58:01,234 --> 00:58:03,868
And so it's up to us
to decide when to add

1516
00:58:03,868 --> 00:58:06,801
that pound define
so that it's compiled in.

1517
00:58:06,801 --> 00:58:09,534
And that's basically
been our approach.

1518
00:58:09,534 --> 00:58:14,033
So we don't expose them
until we're ready.

1519
00:58:14,033 --> 00:58:15,934
man: I was curious
a little bit more

1520
00:58:15,934 --> 00:58:17,234
about the sandboxing.

1521
00:58:17,234 --> 00:58:18,534
You were saying in Windows

1522
00:58:18,534 --> 00:58:20,501
it kind of strips
the credentials away from it,

1523
00:58:20,501 --> 00:58:22,067
and I was curious
about other operating systems,

1524
00:58:22,067 --> 00:58:24,367
if you're like--
if it would be more of, like,

1525
00:58:24,367 --> 00:58:26,801
a memory bounds checking
at the code level

1526
00:58:26,801 --> 00:58:28,801
or if you're familiar
with, like, Valgrind,

1527
00:58:28,801 --> 00:58:30,734
which is, like, object code.

1528
00:58:30,734 --> 00:58:32,834
Like, how would you
be implementing that?

1529
00:58:32,834 --> 00:58:34,167
Fisher:
There's a lot of--

1530
00:58:34,167 --> 00:58:36,801
a lot of crazy ideas,
you know, afoot

1531
00:58:36,801 --> 00:58:38,601
for how to sandbox
on Linux.

1532
00:58:38,601 --> 00:58:40,200
You have a lot
of traditional tools

1533
00:58:40,200 --> 00:58:42,634
like chroot,
different user--

1534
00:58:42,634 --> 00:58:43,901
totally different user.

1535
00:58:43,901 --> 00:58:45,234
You know, there's a lot
of things.

1536
00:58:45,234 --> 00:58:47,200
But all of those tools
seem to require

1537
00:58:47,200 --> 00:58:49,701
some change or some support
from the host system,

1538
00:58:49,701 --> 00:58:53,167
so something that's installed
by admin or whatnot.

1539
00:58:53,167 --> 00:58:54,901
I would encourage you
to get up on Chromium Dev

1540
00:58:54,901 --> 00:58:56,200
and chat with the engineers

1541
00:58:56,200 --> 00:58:57,634
who are actually looking
into this problem,

1542
00:58:57,634 --> 00:58:59,200
'cause there's just so many
different approaches

1543
00:58:59,200 --> 00:59:00,701
you could take
with sandboxing.

1544
00:59:00,701 --> 00:59:02,801
man: Are you guys interested
in any sort of, like,

1545
00:59:02,801 --> 00:59:05,367
it's not really portable,
but it's, like, an object type--

1546
00:59:05,367 --> 00:59:06,934
like, how Valgrind does it,

1547
00:59:06,934 --> 00:59:08,334
where it just
reads object code

1548
00:59:08,334 --> 00:59:10,200
and just runs that inside
of, like, an emulator,

1549
00:59:10,200 --> 00:59:11,734
like a user space emulation?

1550
00:59:11,734 --> 00:59:13,367
Fisher: Big concern
is performance really

1551
00:59:13,367 --> 00:59:14,968
with anything we do.

1552
00:59:14,968 --> 00:59:16,567
man: Okay, thank you.

1553
00:59:16,567 --> 00:59:18,868
another man:
One more thing about plug-ins.

1554
00:59:18,868 --> 00:59:20,501
You know,
it would also help if maybe

1555
00:59:20,501 --> 00:59:23,634
you streamlined the installation
process a little bit.

1556
00:59:23,634 --> 00:59:27,567
I understand the security
implications of having plug-ins.

1557
00:59:27,567 --> 00:59:29,467
It'd be nice,
from a user's point of view,

1558
00:59:29,467 --> 00:59:31,901
if they could click somewhere
and actually get a plug-in

1559
00:59:31,901 --> 00:59:35,100
without having
to reboot the browser and--

1560
00:59:35,100 --> 00:59:37,100
Fisher: Well, one of the things
we're trying to solve

1561
00:59:37,100 --> 00:59:39,334
with Chrome extension system
is to actually make it easy

1562
00:59:39,334 --> 00:59:42,801
for extensions to deliver
all manner of things

1563
00:59:42,801 --> 00:59:44,434
that extend the browser.

1564
00:59:44,434 --> 00:59:47,601
And so just like an XPI
can be used on Mozilla

1565
00:59:47,601 --> 00:59:49,534
to deliver an NPAPI plug-in,

1566
00:59:49,534 --> 00:59:52,033
a Chrome extension bundle
should be able to do the same

1567
00:59:52,033 --> 00:59:54,300
and give the user
very good control

1568
00:59:54,300 --> 00:59:55,868
over managing
that plug-in.

1569
00:59:55,868 --> 00:59:57,801
man: Yeah,
we'll talk offline.

1570
00:59:57,801 --> 00:59:59,167
Fisher: So anyways,
that's it.

1571
00:59:59,167 --> 01:00:00,734
I'm afraid we're
all out of time for questions,

1572
01:00:00,734 --> 01:00:02,868
but I'm happy to talk
to folks afterwards.

1573
01:00:02,868 --> 01:00:04,367
Thank you so much
for coming,

1574
01:00:04,367 --> 01:00:09,434
and I'm to remind you

1575
01:00:09,434 --> 01:00:10,934
of this.

1576
01:00:10,934 --> 01:00:12,701
Haveasec.com/IO.

1577
01:00:12,701 --> 01:00:14,634
Please leave your comments.

