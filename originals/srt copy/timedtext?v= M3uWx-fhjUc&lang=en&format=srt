1
00:00:00,000 --> 00:00:03,080

2
00:00:03,080 --> 00:00:03,400
MICHAEL BOLIN: Hello.

3
00:00:03,400 --> 00:00:04,550
Good afternoon.

4
00:00:04,550 --> 00:00:05,990
Welcome to, I guess,
what is the last

5
00:00:05,990 --> 00:00:08,170
session of Google I/O.

6
00:00:08,170 --> 00:00:11,070
I'm here to talk to you about
a topic that's near and dear

7
00:00:11,070 --> 00:00:13,570
to my heart, which is JavaScript
programming in the

8
00:00:13,570 --> 00:00:15,920
large with Closure tools.

9
00:00:15,920 --> 00:00:17,170
My name's Michael Bolin.

10
00:00:17,170 --> 00:00:20,170
As you can see I have my
SpeakerMeter URL up there if

11
00:00:20,170 --> 00:00:21,250
you want to give me feedback.

12
00:00:21,250 --> 00:00:25,430
I do talk about Closure a bit,
so feedback would be great.

13
00:00:25,430 --> 00:00:28,540
But let's get started.

14
00:00:28,540 --> 00:00:31,180
So first of all, something I
would actually like to clarify

15
00:00:31,180 --> 00:00:35,990
is who am I and why did
they let me up here?

16
00:00:35,990 --> 00:00:38,780
Because actually, I don't
work at Google.

17
00:00:38,780 --> 00:00:39,940
I used to work at Google.

18
00:00:39,940 --> 00:00:42,620
And while I was there I worked
on Google Calendar.

19
00:00:42,620 --> 00:00:44,600
I did a lot of the front-end
development for that.

20
00:00:44,600 --> 00:00:46,870
And then also then the majority
of the front-end

21
00:00:46,870 --> 00:00:49,390
development on Google Tasks.

22
00:00:49,390 --> 00:00:52,266
And then post-Google I wrote
a book called Closure:The

23
00:00:52,266 --> 00:00:53,410
Definitive Guide.

24
00:00:53,410 --> 00:00:56,220
Maybe some you have it.

25
00:00:56,220 --> 00:00:59,590
And basically around
the time when--

26
00:00:59,590 --> 00:01:01,720
about a year and a half ago--
when Google Open Sourced

27
00:01:01,720 --> 00:01:04,090
Closure, I just felt very
strongly that this is a really

28
00:01:04,090 --> 00:01:05,340
important toolkit.

29
00:01:05,340 --> 00:01:08,990
In terms of moving the web
forward, in terms of enabling

30
00:01:08,990 --> 00:01:12,060
people to make really fast
web applications.

31
00:01:12,060 --> 00:01:13,990
And that's what makes the web
better for everyone, when

32
00:01:13,990 --> 00:01:17,230
people can build higher
quality applications.

33
00:01:17,230 --> 00:01:20,640
So I've done a bit of work in
the realm of doing some large

34
00:01:20,640 --> 00:01:22,020
JavaScript development.

35
00:01:22,020 --> 00:01:25,660
And that's what we're going
to talk about today.

36
00:01:25,660 --> 00:01:27,760
So first I should clarify--

37
00:01:27,760 --> 00:01:30,120
or at least give some sort of
definition-- for what I mean

38
00:01:30,120 --> 00:01:32,130
by programming in the large.

39
00:01:32,130 --> 00:01:32,960
Just to throw out--

40
00:01:32,960 --> 00:01:36,440
I'm just going to make up some
numbers-- but more properties,

41
00:01:36,440 --> 00:01:37,950
let's say 30,000
lines of code.

42
00:01:37,950 --> 00:01:41,260
Let's say that's programming
in the large.

43
00:01:41,260 --> 00:01:43,090
Another aspect is having
a large team.

44
00:01:43,090 --> 00:01:44,920
Once you have more people--

45
00:01:44,920 --> 00:01:46,230
because you need more people
to build a bigger

46
00:01:46,230 --> 00:01:47,270
application--

47
00:01:47,270 --> 00:01:49,140
now you also have this
communication overhead that

48
00:01:49,140 --> 00:01:50,220
you have to think about.

49
00:01:50,220 --> 00:01:52,400
I think that this is really
important in terms of

50
00:01:52,400 --> 00:01:55,200
JavaScript because a lot of
people are used to just

51
00:01:55,200 --> 00:01:58,520
copying and pasting some code
they find on the web to

52
00:01:58,520 --> 00:02:00,940
decorate some page that they
have and that's kind of what

53
00:02:00,940 --> 00:02:03,540
their impression of what
JavaScript programming is.

54
00:02:03,540 --> 00:02:06,550
And they don't really have an
idea of how to get to the 10

55
00:02:06,550 --> 00:02:10,460
lines of code they copied to
the 30,000-line JavaScript

56
00:02:10,460 --> 00:02:12,700
application.

57
00:02:12,700 --> 00:02:15,500
And another aspect of this is
a longer development cycle.

58
00:02:15,500 --> 00:02:18,570
This is significant in terms
of, if you work at a larger

59
00:02:18,570 --> 00:02:21,110
company people may roll
on and off your team.

60
00:02:21,110 --> 00:02:24,260
They're going to have to be able
to pick up and dive into

61
00:02:24,260 --> 00:02:26,910
a large code base that they're
not familiar with.

62
00:02:26,910 --> 00:02:30,130
Also over a six-month period,
you, yourself, may not even

63
00:02:30,130 --> 00:02:32,370
remember what the code that
you did six months ago.

64
00:02:32,370 --> 00:02:35,000
So it needs to be organized.

65
00:02:35,000 --> 00:02:37,200
You need to have some way of
laying it out such that you

66
00:02:37,200 --> 00:02:39,910
can come back to it, anyone else
can come into it because

67
00:02:39,910 --> 00:02:43,970
this is what's going to enable
you to build more complex and

68
00:02:43,970 --> 00:02:45,070
interesting applications.

69
00:02:45,070 --> 00:02:47,150
Not that everything needs
to be complex.

70
00:02:47,150 --> 00:02:48,360
Absolutely not.

71
00:02:48,360 --> 00:02:50,900
But there's a certain class of
applications that are really

72
00:02:50,900 --> 00:02:53,570
interesting that we want to
see brought to the web.

73
00:02:53,570 --> 00:02:56,750
And for that, it just takes a
different, you need to take a

74
00:02:56,750 --> 00:02:59,280
different tack in terms of how
you organize your team and

75
00:02:59,280 --> 00:03:01,180
organize your code to
make sure you can

76
00:03:01,180 --> 00:03:02,650
make interesting progress.

77
00:03:02,650 --> 00:03:05,290
So this the area that I'm
calling JavaScript programming

78
00:03:05,290 --> 00:03:05,940
in the large.

79
00:03:05,940 --> 00:03:08,530
And that's where, I think,
Closure really fits in and

80
00:03:08,530 --> 00:03:10,490
speaks to that.

81
00:03:10,490 --> 00:03:12,670
So today if you wanted to
build a rich internet

82
00:03:12,670 --> 00:03:16,040
application, or an RIA, a lot
of these are thought of a

83
00:03:16,040 --> 00:03:18,110
single-page applications.

84
00:03:18,110 --> 00:03:21,420
Such as Gmail and Calendar,
where you go, you log in, you

85
00:03:21,420 --> 00:03:24,300
actually don't really reload
the page or change URLs.

86
00:03:24,300 --> 00:03:26,990
Maybe the fragment changes and
it keeps track of your state.

87
00:03:26,990 --> 00:03:31,250
But you load a large bundle of
JavaScript at the beginning.

88
00:03:31,250 --> 00:03:33,540
Perhaps you navigate through
the app, exercise certain

89
00:03:33,540 --> 00:03:35,750
features, more JavaScript
gets loaded.

90
00:03:35,750 --> 00:03:38,170
But basically you're using
this one thing where

91
00:03:38,170 --> 00:03:41,860
everything is in memory
on that single page.

92
00:03:41,860 --> 00:03:44,580
So if you wanted to create
this rich experience,

93
00:03:44,580 --> 00:03:47,040
something that's more akin to a
desktop app, obviously we're

94
00:03:47,040 --> 00:03:50,250
doing a lot of stuff with
HTML5 right now.

95
00:03:50,250 --> 00:03:53,510
But let's think about what some
of your options would be.

96
00:03:53,510 --> 00:03:56,890
So the first one is use a
plugin, such as Java or Flash.

97
00:03:56,890 --> 00:04:00,370
Some people may remember Java
applets, which were going to

98
00:04:00,370 --> 00:04:02,590
be the greatest thing and they
were going to save the web and

99
00:04:02,590 --> 00:04:04,710
we were going to be able to
write all our things in Swing

100
00:04:04,710 --> 00:04:06,600
and they were all going to be
purple and gray and it was

101
00:04:06,600 --> 00:04:08,510
going to be great.

102
00:04:08,510 --> 00:04:11,150
But the problem was, it took
like half an hour or something

103
00:04:11,150 --> 00:04:14,190
for that Java plugin to load and
you were looking at that

104
00:04:14,190 --> 00:04:15,520
coffee cup.

105
00:04:15,520 --> 00:04:18,100
Assuming you could even figure
out how to download it.

106
00:04:18,100 --> 00:04:18,920
And then Flash.

107
00:04:18,920 --> 00:04:23,890
Flash is obviously a lot
snappier than Java.

108
00:04:23,890 --> 00:04:25,320
And is very popular today.

109
00:04:25,320 --> 00:04:28,300
Obviously when YouTube first
came out, I don't know if

110
00:04:28,300 --> 00:04:30,290
there would have been a YouTube
if there weren't a

111
00:04:30,290 --> 00:04:31,360
Flash plugin.

112
00:04:31,360 --> 00:04:34,120
But certainly Apple has thrown
down the gauntlet.

113
00:04:34,120 --> 00:04:36,740
An iOS Flash is a non-starter.

114
00:04:36,740 --> 00:04:40,080
So if you want to have a code
base that you can use across

115
00:04:40,080 --> 00:04:42,570
different devices and supporting
iOS is important to

116
00:04:42,570 --> 00:04:48,240
you, than Flash is not really
a reasonable option.

117
00:04:48,240 --> 00:04:52,040
Another option, which is good
for building an RIA, is GWT.

118
00:04:52,040 --> 00:04:53,210
Obviously I'm sure there's
a lot of people

119
00:04:53,210 --> 00:04:55,250
here who use GWT.

120
00:04:55,250 --> 00:04:56,340
Certainly a lot of people at
this conference have been

121
00:04:56,340 --> 00:04:58,920
talking a lot about GWT.

122
00:04:58,920 --> 00:05:01,950
And so, if you're familiar with
it, the idea is basically

123
00:05:01,950 --> 00:05:03,860
that you write your application
in a language

124
00:05:03,860 --> 00:05:04,830
that's more familiar to you.

125
00:05:04,830 --> 00:05:07,190
In the case of GWT, it's Java.

126
00:05:07,190 --> 00:05:12,940
And then the tool takes care of
translating your Java code

127
00:05:12,940 --> 00:05:13,910
into JavaScript.

128
00:05:13,910 --> 00:05:15,600
And certainly a lot of people
have written a lot of

129
00:05:15,600 --> 00:05:17,540
interesting things with GWT.

130
00:05:17,540 --> 00:05:21,140
Even this morning, I believe,
the Angry Birds folks said

131
00:05:21,140 --> 00:05:22,920
that their stuff is
written in GWT.

132
00:05:22,920 --> 00:05:25,700
So clearly you can get
a lot done using it.

133
00:05:25,700 --> 00:05:28,650
But at the same time, there's
actually a lot of really great

134
00:05:28,650 --> 00:05:32,070
things that JavaScript has that
Java doesn't have. Such

135
00:05:32,070 --> 00:05:35,460
as first-order functions, is a
really big one and a really

136
00:05:35,460 --> 00:05:37,420
natural use of Closure's.

137
00:05:37,420 --> 00:05:40,470
Passing a function around as a
parameter in Java is actually

138
00:05:40,470 --> 00:05:42,590
incredibly awkward.

139
00:05:42,590 --> 00:05:45,660
Yet it's also very
straight-forward when you do

140
00:05:45,660 --> 00:05:46,780
it in JavaScript.

141
00:05:46,780 --> 00:05:49,980
Similarly there's APIs of the
browser, with HTML5, new

142
00:05:49,980 --> 00:05:51,450
things are coming out
all the time.

143
00:05:51,450 --> 00:05:55,160
In JavaScript you can use these
things very directly.

144
00:05:55,160 --> 00:05:58,860
In GWT you need to wrap them in
JSNI or someone else has to

145
00:05:58,860 --> 00:06:00,280
do that work for you.

146
00:06:00,280 --> 00:06:03,180
So if you really care about
getting close to the mettle of

147
00:06:03,180 --> 00:06:09,200
the browser, so to speak, GWT
has ways to get to it.

148
00:06:09,200 --> 00:06:11,760
But it's not as natural as if
you were using the language

149
00:06:11,760 --> 00:06:13,230
that the browser speaks,
which is JavaScript.

150
00:06:13,230 --> 00:06:16,760

151
00:06:16,760 --> 00:06:19,850
The way that I propose, and
have built, rich internet

152
00:06:19,850 --> 00:06:22,980
applications is writing
lots of JavaScript.

153
00:06:22,980 --> 00:06:25,530
Because it is awesome.

154
00:06:25,530 --> 00:06:27,120
And when I say lots,
I do mean lots.

155
00:06:27,120 --> 00:06:30,270
The last project I worked on
we wrote 70,000 lines of

156
00:06:30,270 --> 00:06:32,920
JavaScript was our
application.

157
00:06:32,920 --> 00:06:34,775
And we did it using Closure.

158
00:06:34,775 --> 00:06:37,620

159
00:06:37,620 --> 00:06:40,950
As I mentioned, JavaScript has
first-order functions.

160
00:06:40,950 --> 00:06:44,225
It also has regular expression
literal, similar to Perl.

161
00:06:44,225 --> 00:06:49,010
It has a prototype- based
inheritance mechanism that

162
00:06:49,010 --> 00:06:50,640
Java does have and other
languages don't have. It

163
00:06:50,640 --> 00:06:52,255
actually took that-- it was
inspired by this other

164
00:06:52,255 --> 00:06:53,660
language called Self.

165
00:06:53,660 --> 00:06:57,000
So there's a lot of neat things
that you get when you

166
00:06:57,000 --> 00:06:59,640
write in JavaScript, in
addition to being

167
00:06:59,640 --> 00:07:00,390
close to the browser.

168
00:07:00,390 --> 00:07:03,020
But also as a language, it
is a very good language.

169
00:07:03,020 --> 00:07:05,840
People have bad impressions of
it because they only associate

170
00:07:05,840 --> 00:07:08,300
it with browser programming,
which is traditionally

171
00:07:08,300 --> 00:07:10,700
fundamentally difficult
because of things like

172
00:07:10,700 --> 00:07:14,780
Internet Explorer 6 and all the
differences in the DOM.

173
00:07:14,780 --> 00:07:16,870
It's the DOM API that's actually
the source of most

174
00:07:16,870 --> 00:07:18,170
people's frustration.

175
00:07:18,170 --> 00:07:21,790
But JavaScript the language
really takes more of the heat,

176
00:07:21,790 --> 00:07:25,050
whereas it should not.

177
00:07:25,050 --> 00:07:27,340
In case you think I'm the only
person who is crazy, who

178
00:07:27,340 --> 00:07:30,160
thinks we should write a lot
of JavaScript, all these

179
00:07:30,160 --> 00:07:33,885
applications on the bottom that
Google has written, they

180
00:07:33,885 --> 00:07:34,900
are in JavaScript.

181
00:07:34,900 --> 00:07:38,480
A lot of people assume that
the Google Web Toolkit is

182
00:07:38,480 --> 00:07:41,080
responsible for everything
that Google produces.

183
00:07:41,080 --> 00:07:43,380
That's not the case.

184
00:07:43,380 --> 00:07:46,590
Part of it was also just
due to history.

185
00:07:46,590 --> 00:07:48,830
Some of these applications had
already been built up and were

186
00:07:48,830 --> 00:07:51,140
going and rewriting
it in GWT--

187
00:07:51,140 --> 00:07:52,140
doesn't seem like
a good option.

188
00:07:52,140 --> 00:07:57,130
But also, sometimes there
are just performance

189
00:07:57,130 --> 00:07:59,300
characteristics or metrics
that we wanted these

190
00:07:59,300 --> 00:08:00,330
applications to meet.

191
00:08:00,330 --> 00:08:02,570
And it just made a lot of
sense to write them in

192
00:08:02,570 --> 00:08:04,490
JavaScript.

193
00:08:04,490 --> 00:08:08,610
And all these are basically
powered by Closure.

194
00:08:08,610 --> 00:08:12,840
So at the same time I'm telling
you that you should

195
00:08:12,840 --> 00:08:16,280
write a lot of JavaScript, yet
in some ways JavaScript tries

196
00:08:16,280 --> 00:08:20,110
to defeat programming
in the large.

197
00:08:20,110 --> 00:08:23,620
So unlike Java, there's
no namespaces.

198
00:08:23,620 --> 00:08:26,440
There's no import statement that
is part of the language

199
00:08:26,440 --> 00:08:27,430
in JavaScript.

200
00:08:27,430 --> 00:08:30,440
And namespaces are important
because as you build up a lot

201
00:08:30,440 --> 00:08:32,400
of code, you need some
way to modularize it.

202
00:08:32,400 --> 00:08:34,190
You need some way
to organize it.

203
00:08:34,190 --> 00:08:37,900
Namespaces turn out to be a
pretty good mechanism for

204
00:08:37,900 --> 00:08:39,830
doing that sort of thing.

205
00:08:39,830 --> 00:08:43,419
Visibility controls are another
important point.

206
00:08:43,419 --> 00:08:45,640
In particular, in terms of
object oriented programming

207
00:08:45,640 --> 00:08:48,110
you have-- in Java you have
the private public

208
00:08:48,110 --> 00:08:49,450
protected key words.

209
00:08:49,450 --> 00:08:52,950
You're saying, this data should
only be seen by the

210
00:08:52,950 --> 00:08:54,820
methods that belong
to this class.

211
00:08:54,820 --> 00:08:56,740
This also is helpful in
programming in the large.

212
00:08:56,740 --> 00:08:59,830
Because then this further helps
you modularize your

213
00:08:59,830 --> 00:09:01,260
code, modularize data.

214
00:09:01,260 --> 00:09:02,820
And it's enforced
by the compiler.

215
00:09:02,820 --> 00:09:05,860
So you get some static
checking about this

216
00:09:05,860 --> 00:09:11,200
organization and you don't have
to manage it yourself.

217
00:09:11,200 --> 00:09:13,600
Similarly, having
a type system.

218
00:09:13,600 --> 00:09:17,820
A lot of people like the idea
that JavaScript is, what many

219
00:09:17,820 --> 00:09:18,780
people call, duck type.

220
00:09:18,780 --> 00:09:21,420
That if you get an object and it
has the properties that you

221
00:09:21,420 --> 00:09:24,730
want, then you can use it the
way that you want to.

222
00:09:24,730 --> 00:09:30,390
As opposed to having to create
an explicit class and having

223
00:09:30,390 --> 00:09:33,920
methods with strongly typed
signatures saying, this takes

224
00:09:33,920 --> 00:09:36,810
a string, this takes a number
and the compiler won't let you

225
00:09:36,810 --> 00:09:40,690
do anything that violates
that contract.

226
00:09:40,690 --> 00:09:43,490
But as you write more and more
JavaScript and you just pick

227
00:09:43,490 --> 00:09:45,160
up people's code and you're
just trying to look at the

228
00:09:45,160 --> 00:09:47,850
interface, this can actually
be kind of difficult.

229
00:09:47,850 --> 00:09:50,380
I, myself, find this someone
troubling when I look at

230
00:09:50,380 --> 00:09:51,510
Python documentation.

231
00:09:51,510 --> 00:09:53,440
Python's also both not
strongly typed.

232
00:09:53,440 --> 00:09:57,920
A lot of times what the method
does would be more obvious if

233
00:09:57,920 --> 00:10:01,510
I just knew the type signature
that were associated with it.

234
00:10:01,510 --> 00:10:03,520
So as you write more
and more code this

235
00:10:03,520 --> 00:10:04,340
can become a problem.

236
00:10:04,340 --> 00:10:07,070
It's also related to
refactoring, which I will

237
00:10:07,070 --> 00:10:09,840
probably get into later.

238
00:10:09,840 --> 00:10:11,100
Also static checking.

239
00:10:11,100 --> 00:10:14,650
So this is related to having
a type system.

240
00:10:14,650 --> 00:10:17,210
When you have a type system and
you have a compiler that

241
00:10:17,210 --> 00:10:20,590
enforces types that means at
compile time, the compiler can

242
00:10:20,590 --> 00:10:24,090
help you find a whole class of
errors that you might not find

243
00:10:24,090 --> 00:10:25,640
while running your problem.

244
00:10:25,640 --> 00:10:30,310
But similarly if you have an
error in an else branch--

245
00:10:30,310 --> 00:10:32,040
I'm sure many Python
programmers

246
00:10:32,040 --> 00:10:34,500
have hit this problem--

247
00:10:34,500 --> 00:10:36,980
or any branch of code, I should
say, where it's not

248
00:10:36,980 --> 00:10:38,070
executed regularly.

249
00:10:38,070 --> 00:10:40,940
Or say some sort of error
handling code.

250
00:10:40,940 --> 00:10:43,390
Because obviously you want to
test with good inputs and no

251
00:10:43,390 --> 00:10:45,880
one ever tests their
bad inputs.

252
00:10:45,880 --> 00:10:48,450
Because why would we ever
have bad inputs?

253
00:10:48,450 --> 00:10:51,260
But that people don't find out
until run time until someone

254
00:10:51,260 --> 00:10:53,280
finally happens to trigger
that error.

255
00:10:53,280 --> 00:10:55,200
There's a large class pf
problems that happen there

256
00:10:55,200 --> 00:10:57,800
that could be checked statically
if there were a

257
00:10:57,800 --> 00:11:00,347
compiler or some sort of other
static analysis tool to

258
00:11:00,347 --> 00:11:02,920
perform that checking for you.

259
00:11:02,920 --> 00:11:05,620
Again programming in the large,
as your code gets

260
00:11:05,620 --> 00:11:08,580
bigger and bigger it's really
hard to manage all these

261
00:11:08,580 --> 00:11:09,810
things yourself.

262
00:11:09,810 --> 00:11:12,220
Yes, you should be writing
unit tests or integration

263
00:11:12,220 --> 00:11:14,940
tests that actually exercise
all these code paths.

264
00:11:14,940 --> 00:11:18,260
But the reality is that most
people don't, assuming they

265
00:11:18,260 --> 00:11:20,470
write tests at all.

266
00:11:20,470 --> 00:11:22,800
And this last one is not having

267
00:11:22,800 --> 00:11:24,640
built-in support for templates.

268
00:11:24,640 --> 00:11:28,340
So in JavaScript, or any web
application, you're usually

269
00:11:28,340 --> 00:11:30,950
building up large
strings of HTML.

270
00:11:30,950 --> 00:11:34,980
Because this is the thing that
you use to create your user

271
00:11:34,980 --> 00:11:38,780
interface in a web browser,
is basically HTML and CSS.

272
00:11:38,780 --> 00:11:41,450
Unfortunately in JavaScript,
we don't

273
00:11:41,450 --> 00:11:43,140
have multi-line strings.

274
00:11:43,140 --> 00:11:44,880
Yet we want to create large DOM

275
00:11:44,880 --> 00:11:46,510
structures defined in HTML.

276
00:11:46,510 --> 00:11:49,110

277
00:11:49,110 --> 00:11:51,060
And then we would really like
to have placeholders, so we

278
00:11:51,060 --> 00:11:52,890
could basically have
a template and

279
00:11:52,890 --> 00:11:54,460
substitute things in.

280
00:11:54,460 --> 00:11:56,530
If you have a repeated row
in a table, right?

281
00:11:56,530 --> 00:11:59,090
You'd like that row to be a
template that you can just

282
00:11:59,090 --> 00:12:03,310
reuse and pump out the same
structure HTML but with

283
00:12:03,310 --> 00:12:04,500
different variables.

284
00:12:04,500 --> 00:12:06,980
And unfortunately the way
strings work in JavaScript

285
00:12:06,980 --> 00:12:10,150
today, it's not so
straightforward to do that

286
00:12:10,150 --> 00:12:11,930
sort of thing.

287
00:12:11,930 --> 00:12:15,110
So these are some of the ways
that JavaScript tries to

288
00:12:15,110 --> 00:12:19,090
defeat or makes it harder to do
development in the large.

289
00:12:19,090 --> 00:12:23,470

290
00:12:23,470 --> 00:12:26,030
There's a suite of tools Open
Sourced by Google called the

291
00:12:26,030 --> 00:12:26,810
Closure tools.

292
00:12:26,810 --> 00:12:29,640
And that's what the crux
of my talk is about.

293
00:12:29,640 --> 00:12:34,780
And these tools are useful
in general in JavaScript

294
00:12:34,780 --> 00:12:35,470
development.

295
00:12:35,470 --> 00:12:38,060
But I think their true strength
is when you start

296
00:12:38,060 --> 00:12:40,250
doing JavaScript development
in the large.

297
00:12:40,250 --> 00:12:42,430
And that, obviously,
you should start

298
00:12:42,430 --> 00:12:43,750
with a small project.

299
00:12:43,750 --> 00:12:46,010
It's not a good idea to start
with a big project.

300
00:12:46,010 --> 00:12:49,670
So at the outset you may not see
the value in these tools.

301
00:12:49,670 --> 00:12:52,360
But you might then get to a
point where you really wish

302
00:12:52,360 --> 00:12:54,530
you had been using them.

303
00:12:54,530 --> 00:12:57,170
So let's look at
what they are.

304
00:12:57,170 --> 00:12:59,490
The first one is the
Closure Library.

305
00:12:59,490 --> 00:13:04,550
The Closure Library is a library
of common utilities,

306
00:13:04,550 --> 00:13:08,260
widgets, written
in JavaScript.

307
00:13:08,260 --> 00:13:10,580
It works across browsers.

308
00:13:10,580 --> 00:13:14,170
It works back to IE6.

309
00:13:14,170 --> 00:13:16,650
So it's analogous to your
jQueries queries, your

310
00:13:16,650 --> 00:13:19,140
MooTools, your YUI all
that sort of thing.

311
00:13:19,140 --> 00:13:21,830
All these things are JavaScript
libraries that try

312
00:13:21,830 --> 00:13:24,830
to abstract away browser
differences from you and

313
00:13:24,830 --> 00:13:29,130
provide a lot of common
functionality.

314
00:13:29,130 --> 00:13:31,600
The next tool is Closure
Templates.

315
00:13:31,600 --> 00:13:34,800
So Closure Templates is
a templating language.

316
00:13:34,800 --> 00:13:36,790
Because we didn't have enough
templating languages.

317
00:13:36,790 --> 00:13:39,610
But Closure Templates does
have some unique

318
00:13:39,610 --> 00:13:42,250
and important features.

319
00:13:42,250 --> 00:13:44,500
And you can use it to--

320
00:13:44,500 --> 00:13:47,420
as I mentioned, it's hard to
build up strings of HTML in

321
00:13:47,420 --> 00:13:49,320
JavaScript using
raw JavaScript.

322
00:13:49,320 --> 00:13:52,150
But having a separate template
language actually makes this a

323
00:13:52,150 --> 00:13:55,940
lot easier and also less
error-prone, as we'll see.

324
00:13:55,940 --> 00:13:59,312
And the third tool is the
Closure Compiler.

325
00:13:59,312 --> 00:14:02,660
The Closure Compiler is
a JavaScript minifier.

326
00:14:02,660 --> 00:14:05,880
So that means that you may write
your JavaScript full of

327
00:14:05,880 --> 00:14:10,980
comments and white space that
don't actually contribute to

328
00:14:10,980 --> 00:14:12,560
the behavior of your program.

329
00:14:12,560 --> 00:14:15,610
But your users, who download the
JavaScript when they visit

330
00:14:15,610 --> 00:14:19,940
your site, they're paying the
penalty, so to speak, of

331
00:14:19,940 --> 00:14:21,710
download time and parse
time when you

332
00:14:21,710 --> 00:14:23,010
have these extra bytes.

333
00:14:23,010 --> 00:14:27,860
And so you want to use a
JavaScript minifier to reduce

334
00:14:27,860 --> 00:14:29,800
the size of your JavaScript
code.

335
00:14:29,800 --> 00:14:31,020
This saves your bandwidth.

336
00:14:31,020 --> 00:14:32,990
It saves the users' bandwidth.

337
00:14:32,990 --> 00:14:35,820
It starts up-- and the users'
application will start up

338
00:14:35,820 --> 00:14:39,120
faster because there's less
JavaScript to parse and it got

339
00:14:39,120 --> 00:14:43,650
there quicker because it
was a smaller file.

340
00:14:43,650 --> 00:14:45,090
There are other minifiers
out there.

341
00:14:45,090 --> 00:14:47,800
There's like JSMIN
and UglifyJS.

342
00:14:47,800 --> 00:14:50,780
But most of them only focus on
minification, whereas the

343
00:14:50,780 --> 00:14:53,780
Closure compiler also does
add status checking.

344
00:14:53,780 --> 00:14:57,390
And we'll see more of that
in a bit as well.

345
00:14:57,390 --> 00:14:59,810
The most important thing, I
think, about the Closure tools

346
00:14:59,810 --> 00:15:03,030
that people don't realize, is
that the Library, Templates,

347
00:15:03,030 --> 00:15:05,000
and the Compiler, they're
all independent tools.

348
00:15:05,000 --> 00:15:07,600
You can actually use one of the
three on any JavaScript

349
00:15:07,600 --> 00:15:09,920
project if that's all you're
interested in.

350
00:15:09,920 --> 00:15:11,740
But they are, by far
and away, most

351
00:15:11,740 --> 00:15:14,290
compelling when used together.

352
00:15:14,290 --> 00:15:16,550
The results that you get, and
the improvement in your code,

353
00:15:16,550 --> 00:15:18,620
are just much more compelling
when you put all these three

354
00:15:18,620 --> 00:15:19,650
things together.

355
00:15:19,650 --> 00:15:24,350
And I think that this is another
area where Closure is

356
00:15:24,350 --> 00:15:26,720
far beyond a lot of the
other offerings.

357
00:15:26,720 --> 00:15:30,790
There is jQuery, there Is
Mustache.js there is JSMin.

358
00:15:30,790 --> 00:15:34,780
There are analogs for all
three of these tools.

359
00:15:34,780 --> 00:15:37,370
So I can't claim that Closure
invented all these ideas.

360
00:15:37,370 --> 00:15:40,800
However I think that most of
these other projects are done

361
00:15:40,800 --> 00:15:42,150
kind of in a silo.

362
00:15:42,150 --> 00:15:45,820
Whereas the Closure tools are
done knowing the strength of

363
00:15:45,820 --> 00:15:46,770
each other tool in mind.

364
00:15:46,770 --> 00:15:48,975
And that's why it really helps
to put them together.

365
00:15:48,975 --> 00:15:56,860

366
00:15:56,860 --> 00:15:58,990
To really understand and
appreciate the benefit of

367
00:15:58,990 --> 00:16:01,200
Closure Tools, first I think we
should look at some of the

368
00:16:01,200 --> 00:16:03,670
problems that JavaScript
developers face today.

369
00:16:03,670 --> 00:16:06,190
And maybe you don't even realize
that you're having

370
00:16:06,190 --> 00:16:08,130
this problem or that
you should be

371
00:16:08,130 --> 00:16:09,640
doing something better.

372
00:16:09,640 --> 00:16:11,300
So here's the first. People--

373
00:16:11,300 --> 00:16:14,450
I don't know if anyone's used
the Library Prototype JS.

374
00:16:14,450 --> 00:16:16,340
Prototype is a JavaScript
library that

375
00:16:16,340 --> 00:16:18,870
goes way, way back.

376
00:16:18,870 --> 00:16:23,240
And one of its claims to
fame was its terseness.

377
00:16:23,240 --> 00:16:27,440
So this is a function that
Prototype offers.

378
00:16:27,440 --> 00:16:31,140
Does anyone have a guess what
this function does, just by

379
00:16:31,140 --> 00:16:33,600
reading it?

380
00:16:33,600 --> 00:16:34,490
It does white space.

381
00:16:34,490 --> 00:16:34,870
Yeah.

382
00:16:34,870 --> 00:16:36,850
So it actually splits
your code.

383
00:16:36,850 --> 00:16:40,150
It splits your string that you
give it, on white space.

384
00:16:40,150 --> 00:16:42,830
Now if you know that, it's
probably because you've used

385
00:16:42,830 --> 00:16:44,240
Prototype JS before.

386
00:16:44,240 --> 00:16:47,020
But if you have a new person on
your project and they came

387
00:16:47,020 --> 00:16:50,530
upon this function that says
dollar sign W, it's pretty

388
00:16:50,530 --> 00:16:53,890
hard for them to come up with
what it does without, either

389
00:16:53,890 --> 00:16:55,720
running it or looking
at the code.

390
00:16:55,720 --> 00:16:57,030
And for one function
that's fine.

391
00:16:57,030 --> 00:16:59,700
But if this is kind of how you
design your whole library,

392
00:16:59,700 --> 00:17:03,710
basically to be unreadable but
terse, this is going to hurt

393
00:17:03,710 --> 00:17:06,099
you when you're trying to
build a large JavaScript

394
00:17:06,099 --> 00:17:07,960
application.

395
00:17:07,960 --> 00:17:10,170
For a long time people have kind
of gotten away with, or

396
00:17:10,170 --> 00:17:13,640
justified, this type of library
style because of

397
00:17:13,640 --> 00:17:17,240
arguing that, well it's saving
my users' bandwidth because

398
00:17:17,240 --> 00:17:19,369
I'm using fewer bytes for
my function names.

399
00:17:19,369 --> 00:17:22,490
And so it's saving space on the
wire and therefore it's OK

400
00:17:22,490 --> 00:17:25,150
to do things that no one
else understands.

401
00:17:25,150 --> 00:17:27,420
But with things like the Closure
compiler, which will

402
00:17:27,420 --> 00:17:30,050
rename variable for you--
as we'll see in a bit--

403
00:17:30,050 --> 00:17:32,820
that's no longer as compelling
a reason to

404
00:17:32,820 --> 00:17:33,950
do things that way.

405
00:17:33,950 --> 00:17:36,350
So in the Closure world, you're
really going to want to

406
00:17:36,350 --> 00:17:39,255
use names that are readable and
make sense and make sense

407
00:17:39,255 --> 00:17:40,770
to your teammates and are
more self-documenting.

408
00:17:40,770 --> 00:17:44,030

409
00:17:44,030 --> 00:17:46,710
Another thing is building
up strings of HTML.

410
00:17:46,710 --> 00:17:50,230
So the problem is, as I
mentioned, that JavaScript is

411
00:17:50,230 --> 00:17:52,530
not really great at this, when
you want to preserve the

412
00:17:52,530 --> 00:17:56,270
formatting of the HTML and the
structure that you're trying

413
00:17:56,270 --> 00:17:58,670
to produce such that
it's readable.

414
00:17:58,670 --> 00:18:01,390
You want it to be close to what
it would be if you wrote

415
00:18:01,390 --> 00:18:04,390
HTML yourself.

416
00:18:04,390 --> 00:18:06,310
But does anyone know what this
function would return?

417
00:18:06,310 --> 00:18:11,670

418
00:18:11,670 --> 00:18:14,500
So actually, this function, if
you just ran it, regardless of

419
00:18:14,500 --> 00:18:16,900
what inputs you gave
to it, this

420
00:18:16,900 --> 00:18:18,820
function returns undefined.

421
00:18:18,820 --> 00:18:22,120
And the reason is that
JavaScript has this neat

422
00:18:22,120 --> 00:18:25,350
feature called semicolon
insertion.

423
00:18:25,350 --> 00:18:29,990
And basically if you don't use
semicolons everywhere, it

424
00:18:29,990 --> 00:18:32,810
infers for where semicolons
can be placed.

425
00:18:32,810 --> 00:18:37,000
And so, unlike some other
languages you can have logic

426
00:18:37,000 --> 00:18:38,790
after a return statement
in JavaScript.

427
00:18:38,790 --> 00:18:40,405
It's actually kind of helpful
during debugging if you want

428
00:18:40,405 --> 00:18:42,640
to exit out real quick while
testing something.

429
00:18:42,640 --> 00:18:43,750
But in your production
code, this is

430
00:18:43,750 --> 00:18:45,190
actually kind of a disaster.

431
00:18:45,190 --> 00:18:49,910
So what happens is, JavaScript
inserts a semicolon basically

432
00:18:49,910 --> 00:18:52,060
after where that end
character would be.

433
00:18:52,060 --> 00:18:55,560
Or the interpreter or the
run time does this.

434
00:18:55,560 --> 00:18:57,350
It does this because then
there's a new line and then

435
00:18:57,350 --> 00:18:59,440
this whole statement--
this on its own is a

436
00:18:59,440 --> 00:19:02,110
valid JavaScript statement.

437
00:19:02,110 --> 00:19:03,690
So the first line just
becomes return.

438
00:19:03,690 --> 00:19:04,910
It returns undefined.

439
00:19:04,910 --> 00:19:08,430
Actually that statement below
it never gets executed.

440
00:19:08,430 --> 00:19:12,370
There's lots of little bugs,
errors, that people make

441
00:19:12,370 --> 00:19:13,590
around this type of behavior.

442
00:19:13,590 --> 00:19:17,540
And when it comes to things like
formatting HTML, it makes

443
00:19:17,540 --> 00:19:19,980
it particularly worse.

444
00:19:19,980 --> 00:19:23,800
Another problem that people
open themselves up to when

445
00:19:23,800 --> 00:19:26,260
they write code in this manner
is that these arguments are

446
00:19:26,260 --> 00:19:28,320
not HTML escaped.

447
00:19:28,320 --> 00:19:31,130
Meaning that, if the user
is some sort of user and

448
00:19:31,130 --> 00:19:34,610
potentially a malicious user,
is responsible for--

449
00:19:34,610 --> 00:19:39,580
if you read these values out of
a database that that user

450
00:19:39,580 --> 00:19:42,080
chose when they signed up or
filled out a form or something

451
00:19:42,080 --> 00:19:45,430
like that-- if you don't escape
the less than signs and

452
00:19:45,430 --> 00:19:48,780
whatnot before you blitz this
string of HTML into your

453
00:19:48,780 --> 00:19:52,160
application, you could open
yourself up to a across-site

454
00:19:52,160 --> 00:19:54,390
scripting attack.

455
00:19:54,390 --> 00:19:56,400
Which is very embarrassing
for you.

456
00:19:56,400 --> 00:19:58,110
I've done it.

457
00:19:58,110 --> 00:20:00,890
I was very embarrassed
as you might imagine.

458
00:20:00,890 --> 00:20:03,490
But it's better to have a tool
that really makes it harder to

459
00:20:03,490 --> 00:20:04,740
make these kinds of mistakes.

460
00:20:04,740 --> 00:20:09,550

461
00:20:09,550 --> 00:20:14,610
Another issue is managing
dependencies in JavaScript.

462
00:20:14,610 --> 00:20:17,230
I look at a lot of projects, or
even websites I visit, and

463
00:20:17,230 --> 00:20:18,220
I wonder why they're slow.

464
00:20:18,220 --> 00:20:20,540
And then I take a little look
under the hood and a lot of

465
00:20:20,540 --> 00:20:24,580
them manage their dependencies
in this way.

466
00:20:24,580 --> 00:20:27,660
And I can imagine what's going
through the developer's mind

467
00:20:27,660 --> 00:20:28,980
as they come up with HTML.

468
00:20:28,980 --> 00:20:32,060
So they're like, number one,
I'm writing JavaScript.

469
00:20:32,060 --> 00:20:33,060
So I need jQuery.

470
00:20:33,060 --> 00:20:34,370
Because everyone says
jQuery's cool.

471
00:20:34,370 --> 00:20:35,030
So that's what I'm
going to do.

472
00:20:35,030 --> 00:20:38,850
So they put a script tag to
jQuery in their page.

473
00:20:38,850 --> 00:20:40,860
So far that's completely fine.

474
00:20:40,860 --> 00:20:44,590
But then they get to the point
where they have some form that

475
00:20:44,590 --> 00:20:46,260
needs people to input a date.

476
00:20:46,260 --> 00:20:47,910
And they're like, I need
a date picker.

477
00:20:47,910 --> 00:20:50,070
And they go and they download
a date picker library for

478
00:20:50,070 --> 00:20:52,890
somewhere and they just plop
another script tag in there.

479
00:20:52,890 --> 00:20:54,320
So now it's two tags.

480
00:20:54,320 --> 00:20:55,070
Not so bad, right?

481
00:20:55,070 --> 00:20:58,630
Probably going to need a date
picker in other places.

482
00:20:58,630 --> 00:20:59,980
That's OK.

483
00:20:59,980 --> 00:21:03,020
And then they decide that they
want some template solution.

484
00:21:03,020 --> 00:21:04,840
Because actually, that would
kind of help them out.

485
00:21:04,840 --> 00:21:07,840
And they didn't get one out of
box with jQuery or with the

486
00:21:07,840 --> 00:21:10,820
data picker, so they
include that.

487
00:21:10,820 --> 00:21:13,280
And then they started testing
on IE 6 and they're

488
00:21:13,280 --> 00:21:14,440
like, ah, son of a--

489
00:21:14,440 --> 00:21:16,670
Now I've got to add
this workaround.

490
00:21:16,670 --> 00:21:20,100
And it's not that big, so
everyone can just get it.

491
00:21:20,100 --> 00:21:22,510
It's just another script tag
and that type of thing.

492
00:21:22,510 --> 00:21:25,710
And then, oh, actually, I also
forgot I should probably write

493
00:21:25,710 --> 00:21:28,500
my application, too, while
I'm doing all this other

494
00:21:28,500 --> 00:21:29,650
JavaScript development.

495
00:21:29,650 --> 00:21:31,390
And you see lots of pages
like this, where

496
00:21:31,390 --> 00:21:32,520
everything gets built up.

497
00:21:32,520 --> 00:21:35,030
There's also a good chance
that unrelated template

498
00:21:35,030 --> 00:21:38,400
solution dot js happened to
bundle jQuery in their

499
00:21:38,400 --> 00:21:39,180
implementation.

500
00:21:39,180 --> 00:21:44,070
And now you're pulling down
two versions of it.

501
00:21:44,070 --> 00:21:45,440
I've seen a lot of
things like this.

502
00:21:45,440 --> 00:21:46,520
So how long can this go on?

503
00:21:46,520 --> 00:21:49,790
How many script tags can you
add to your web page?

504
00:21:49,790 --> 00:21:51,860
Well, a lot, unfortunately.

505
00:21:51,860 --> 00:21:55,560
And this is a big source of
slowness, if you've looked at

506
00:21:55,560 --> 00:22:00,090
page feed or any of Steve
Souders's work on how to make

507
00:22:00,090 --> 00:22:02,030
faster websites.

508
00:22:02,030 --> 00:22:02,850
Everyone will tell you.

509
00:22:02,850 --> 00:22:05,340
One, you need to minimize the
number of requests that your

510
00:22:05,340 --> 00:22:07,220
page makes.

511
00:22:07,220 --> 00:22:08,550
Sometimes you may want
to split things

512
00:22:08,550 --> 00:22:10,320
up to leverage cacheing.

513
00:22:10,320 --> 00:22:13,970
That really depends on the
profile of your page or the

514
00:22:13,970 --> 00:22:15,640
assets that you're trying
to download.

515
00:22:15,640 --> 00:22:18,220
But if you see something like
this, you're probably doing

516
00:22:18,220 --> 00:22:18,860
something wrong.

517
00:22:18,860 --> 00:22:21,440
And you could be doing something
a lot better.

518
00:22:21,440 --> 00:22:25,040
And also, a lot of these
disparate libraries are

519
00:22:25,040 --> 00:22:28,590
probably reimplementing the same
functionality and your

520
00:22:28,590 --> 00:22:31,600
users are now downloading
it five times.

521
00:22:31,600 --> 00:22:32,760
So managing dependencies.

522
00:22:32,760 --> 00:22:34,360
Again, I said there's no
import statement in

523
00:22:34,360 --> 00:22:34,980
JavaScript.

524
00:22:34,980 --> 00:22:39,190
So it's somewhat difficult
to do out of the box.

525
00:22:39,190 --> 00:22:42,950
Another thing that I've seen
happening recently is creating

526
00:22:42,950 --> 00:22:46,530
a special version of JavaScript
for mobile.

527
00:22:46,530 --> 00:22:49,270
Creating a special version of
your JavaScript for mobile is

528
00:22:49,270 --> 00:22:49,960
a good thing.

529
00:22:49,960 --> 00:22:53,060
Because they have different
capabilities and

530
00:22:53,060 --> 00:22:53,700
that sort of thing.

531
00:22:53,700 --> 00:22:56,400
But the problem is that when
I see forks of libraries.

532
00:22:56,400 --> 00:22:59,540
So there's a library out called
Zepto .js and it's

533
00:22:59,540 --> 00:23:06,420
basically a mobile web kit
implementation of jQuery So

534
00:23:06,420 --> 00:23:09,990
when I say mobile web kit I
mean, you can rely on an array

535
00:23:09,990 --> 00:23:11,420
having a for each library.

536
00:23:11,420 --> 00:23:14,220
Or that you know that the
query selector method is

537
00:23:14,220 --> 00:23:17,290
available in the DOM As opposed
to, in jQuery, to be

538
00:23:17,290 --> 00:23:20,400
backwards compatible there's
substantial code that it

539
00:23:20,400 --> 00:23:24,590
bundles to be able to emulate
query SelectorAll and

540
00:23:24,590 --> 00:23:26,390
iterating of an array
and a whole bunch

541
00:23:26,390 --> 00:23:27,320
of things like that.

542
00:23:27,320 --> 00:23:32,330
And so instead of trying to
write one library, and not

543
00:23:32,330 --> 00:23:34,270
repeating yourself, and then
doing some sort of

544
00:23:34,270 --> 00:23:37,720
post-processing to generate what
would be a mobile web kit

545
00:23:37,720 --> 00:23:41,140
optimized version and then
generating what's, let's say a

546
00:23:41,140 --> 00:23:43,850
browser-agnostic version, people
sometimes just choose

547
00:23:43,850 --> 00:23:44,800
to fork things.

548
00:23:44,800 --> 00:23:48,390
And obviously then, it's much
harder to maintain.

549
00:23:48,390 --> 00:23:49,460
You have two versions.

550
00:23:49,460 --> 00:23:51,440
One has features that the
other one doesn't.

551
00:23:51,440 --> 00:23:52,580
Testing.

552
00:23:52,580 --> 00:23:56,910
All the efforts of what you're
trying to do are now doubled.

553
00:23:56,910 --> 00:23:59,590

554
00:23:59,590 --> 00:24:03,480
Another one is safeguarding
private variables.

555
00:24:03,480 --> 00:24:06,700
Again, because we have no idea
of visibility keywords in

556
00:24:06,700 --> 00:24:07,230
JavaScript.

557
00:24:07,230 --> 00:24:10,265
There is no public
private keyword.

558
00:24:10,265 --> 00:24:16,080
A lot of people use Closure to
emulate the private variables

559
00:24:16,080 --> 00:24:18,280
in languages like Java.

560
00:24:18,280 --> 00:24:21,150
And so this is an implementation
of how you

561
00:24:21,150 --> 00:24:23,800
could do this if you imagine,
ImmutableLatLng, if you

562
00:24:23,800 --> 00:24:24,900
treated that as a constructor.

563
00:24:24,900 --> 00:24:26,790
You passed into lat, lng.

564
00:24:26,790 --> 00:24:28,700
You wanted there to be
getters for these

565
00:24:28,700 --> 00:24:30,930
properties but not setters.

566
00:24:30,930 --> 00:24:32,880
This would do that for you.

567
00:24:32,880 --> 00:24:36,120
The downside is that means every
time you instantiate one

568
00:24:36,120 --> 00:24:37,140
of these objects--

569
00:24:37,140 --> 00:24:39,980
in this case it's creating three
new function objects as

570
00:24:39,980 --> 00:24:42,560
opposed to sharing one
method object.

571
00:24:42,560 --> 00:24:44,580
So this will take
up more memory.

572
00:24:44,580 --> 00:24:47,010
It also increases
look up time.

573
00:24:47,010 --> 00:24:49,240
Because by using a Closure, you
actually create an actual

574
00:24:49,240 --> 00:24:50,640
level of scope.

575
00:24:50,640 --> 00:24:53,500
Newer engines like V 8 this
shouldn't actually be a

576
00:24:53,500 --> 00:24:55,780
significant difference in terms
of the look up time.

577
00:24:55,780 --> 00:24:59,670
But older browsers, like IE6,
these things actually become

578
00:24:59,670 --> 00:25:00,920
more significant.

579
00:25:00,920 --> 00:25:02,870

580
00:25:02,870 --> 00:25:04,680
And another thing is
documenting types.

581
00:25:04,680 --> 00:25:08,340
So as I mentioned we don't have
a standard syntax for

582
00:25:08,340 --> 00:25:12,320
documenting types of variables
and methods in JavaScript.

583
00:25:12,320 --> 00:25:15,080
But if you're going to have a
large application and people

584
00:25:15,080 --> 00:25:18,620
want to be able to look at an
API really quickly, it's more

585
00:25:18,620 --> 00:25:20,770
helpful if you have some
sort of standard

586
00:25:20,770 --> 00:25:23,460
way to document types.

587
00:25:23,460 --> 00:25:25,040
Sometimes libraries--

588
00:25:25,040 --> 00:25:28,260
this is what Dojo does,
basically is that you can make

589
00:25:28,260 --> 00:25:29,650
a little in-line comment.

590
00:25:29,650 --> 00:25:33,210
And this is actually pretty good
as long as it's, you have

591
00:25:33,210 --> 00:25:34,340
kind of a standard format.

592
00:25:34,340 --> 00:25:39,090
But even in this example, you
have a method that takes some

593
00:25:39,090 --> 00:25:40,440
number of parameters
and then you also

594
00:25:40,440 --> 00:25:41,845
specify a call back function.

595
00:25:41,845 --> 00:25:44,310
And a lot of people just say the
call back is a function.

596
00:25:44,310 --> 00:25:46,990
But really, that call
back has a contract.

597
00:25:46,990 --> 00:25:50,110
And in this case it
would be something

598
00:25:50,110 --> 00:25:51,850
that takes a lat lng.

599
00:25:51,850 --> 00:25:54,730
But developers right now usually
have to take a look at

600
00:25:54,730 --> 00:25:57,110
the implementation of the method
to see what the call

601
00:25:57,110 --> 00:26:00,130
back actually gets
or test it out.

602
00:26:00,130 --> 00:26:03,940
Because it's not expressed in
the type definition that you

603
00:26:03,940 --> 00:26:05,560
gave for the argument.

604
00:26:05,560 --> 00:26:09,410
It's a lot easier to pick up a
library and use it if you know

605
00:26:09,410 --> 00:26:12,030
what the contract of the
call back function is.

606
00:26:12,030 --> 00:26:14,290
Helps you figure out where you
should send it or actually if

607
00:26:14,290 --> 00:26:15,540
even if it's the right
method that you

608
00:26:15,540 --> 00:26:16,790
should be using or not.

609
00:26:16,790 --> 00:26:20,030

610
00:26:20,030 --> 00:26:21,580
So these are a bunch of problems
that JavaScript

611
00:26:21,580 --> 00:26:22,900
developers have today.

612
00:26:22,900 --> 00:26:26,300
And so I want to go through the
Closure tools and let's

613
00:26:26,300 --> 00:26:29,640
take a look at how Closure can
help you address these

614
00:26:29,640 --> 00:26:33,760
problems, write better code and
avoid these pitfalls and

615
00:26:33,760 --> 00:26:36,750
hopefully avoid bugs.

616
00:26:36,750 --> 00:26:41,510
So the first thing is, this
is basically how--

617
00:26:41,510 --> 00:26:43,370
when you use all the Closure
tools together--

618
00:26:43,370 --> 00:26:46,480
how your application is built.

619
00:26:46,480 --> 00:26:49,660
Or how you produce JavaScript
at the bottom.

620
00:26:49,660 --> 00:26:52,860
So at the top, so one thing you
would have is you'd have

621
00:26:52,860 --> 00:26:55,130
template code.

622
00:26:55,130 --> 00:26:57,060
I'll show you in a second.

623
00:26:57,060 --> 00:27:00,790
Closure Templates is its own
templating language.

624
00:27:00,790 --> 00:27:04,270
So you write your templates in
that templating language.

625
00:27:04,270 --> 00:27:06,820
And then you run it through the
tool, Closure Templates,

626
00:27:06,820 --> 00:27:08,240
and that produces JavaScript.

627
00:27:08,240 --> 00:27:10,410
So now each template that
you wrote becomes

628
00:27:10,410 --> 00:27:11,680
a JavaScript function.

629
00:27:11,680 --> 00:27:14,390
The Closure Library, as I said,
is already a library in

630
00:27:14,390 --> 00:27:15,340
pure JavaScript.

631
00:27:15,340 --> 00:27:19,033
So now you already have your
JavaScript library for string

632
00:27:19,033 --> 00:27:22,470
and DOM utilities and all sorts
of other good stuff.

633
00:27:22,470 --> 00:27:25,030
And then the third is your
application code.

634
00:27:25,030 --> 00:27:29,820
So you're able to write code
that leverages both the

635
00:27:29,820 --> 00:27:32,530
templates and the library code
that you've written.

636
00:27:32,530 --> 00:27:34,490
And all three of these
things go down

637
00:27:34,490 --> 00:27:36,170
into the Closure Compiler.

638
00:27:36,170 --> 00:27:39,820
And so the Closure Compiler
is a whole program

639
00:27:39,820 --> 00:27:41,200
optimize and compiler.

640
00:27:41,200 --> 00:27:43,180
Meaning that it has all the
source code of your

641
00:27:43,180 --> 00:27:45,770
application at once when
it compiles it.

642
00:27:45,770 --> 00:27:48,560
This is unlike, let's say
Java, for example.

643
00:27:48,560 --> 00:27:52,180
Where some of the assets that go
through javac are JARs are

644
00:27:52,180 --> 00:27:57,310
pre-compiled objects and
therefore there's some

645
00:27:57,310 --> 00:28:00,500
optimizations that the Closure
Compiler can do on a global

646
00:28:00,500 --> 00:28:04,100
level because it has all
the source code.

647
00:28:04,100 --> 00:28:06,560
And then as a result we get
some optimized JavaScript.

648
00:28:06,560 --> 00:28:10,910
We get something that Closure
Compiler has produced knowing

649
00:28:10,910 --> 00:28:14,420
all possible code paths, so to
speak, of your JavaScript

650
00:28:14,420 --> 00:28:15,460
application.

651
00:28:15,460 --> 00:28:18,150
And so this is what enables it
to produce something that's

652
00:28:18,150 --> 00:28:23,410
really small, really compact
and really fast.

653
00:28:23,410 --> 00:28:26,790
So the first thing I want to
show you is what the syntax

654
00:28:26,790 --> 00:28:30,160
for Closure Templates
look like.

655
00:28:30,160 --> 00:28:31,710
There's a namespace
at the top.

656
00:28:31,710 --> 00:28:35,650
In this case I made a namespace
called widget.

657
00:28:35,650 --> 00:28:39,090
The next, I guess this looks
kind of like Java or Javadoc,

658
00:28:39,090 --> 00:28:41,380
where you declare the parameters
that are going to

659
00:28:41,380 --> 00:28:43,410
be passed into the template.

660
00:28:43,410 --> 00:28:48,890
So these are basically your
template variables below.

661
00:28:48,890 --> 00:28:51,920
Then you have your HTML and
we have this dollar sign

662
00:28:51,920 --> 00:28:54,210
placeholder type of thing.

663
00:28:54,210 --> 00:28:57,280
Which, is probably not too
surprising if you've looked at

664
00:28:57,280 --> 00:28:58,890
most other templating
solutions.

665
00:28:58,890 --> 00:29:01,670
There's the markup and then
there's the stuff that you

666
00:29:01,670 --> 00:29:04,370
want to insert.

667
00:29:04,370 --> 00:29:07,710
At the outset, this maybe
doesn't look too compelling.

668
00:29:07,710 --> 00:29:11,180
But what's more interesting is
that when we run this through

669
00:29:11,180 --> 00:29:17,120
the Closure Templates tool,
and so this is what is

670
00:29:17,120 --> 00:29:20,700
produced once you run
it through the tool.

671
00:29:20,700 --> 00:29:23,280
So what's actually produced
is a function.

672
00:29:23,280 --> 00:29:27,190
So unlike PHP, where PHP is
also a templating library,

673
00:29:27,190 --> 00:29:30,220
where you can't really get
access to it programatically.

674
00:29:30,220 --> 00:29:31,580
It's kind of like you
just hit the page

675
00:29:31,580 --> 00:29:32,850
and stuff just happens.

676
00:29:32,850 --> 00:29:35,940
Now this template is actually
a function.

677
00:29:35,940 --> 00:29:40,840
It has, as a parameter
it has a return type.

678
00:29:40,840 --> 00:29:43,580
You can see that it takes
this object in.

679
00:29:43,580 --> 00:29:46,660
And another thing it does for
you is that, by default, you

680
00:29:46,660 --> 00:29:50,010
can see that all the arguments
are escapes.

681
00:29:50,010 --> 00:29:53,180
So I made that comment earlier
about my original definition

682
00:29:53,180 --> 00:29:59,090
of a function that you'd try to
do this template, where the

683
00:29:59,090 --> 00:30:03,090
arguments were not escaped and
you were subject to cross-site

684
00:30:03,090 --> 00:30:05,170
scripting vulnerabilities.

685
00:30:05,170 --> 00:30:08,510
In Closure Templates, it escapes
things by default.

686
00:30:08,510 --> 00:30:11,660
You can add annotations to say
don't escape anything in this

687
00:30:11,660 --> 00:30:13,610
template or don't escape
this variable.

688
00:30:13,610 --> 00:30:17,050
But by default, you should
be a lot safer.

689
00:30:17,050 --> 00:30:21,190
Another thing is also that
by this being a function,

690
00:30:21,190 --> 00:30:24,150
something you can interact with
programatically, you can,

691
00:30:24,150 --> 00:30:27,940
if you're familiar with the idea
of function carrying, and

692
00:30:27,940 --> 00:30:30,830
also that in JavaScript that
functions are first order

693
00:30:30,830 --> 00:30:32,830
objects, that you can
pass them around.

694
00:30:32,830 --> 00:30:36,580
So programatiically, this is a
much nicer way to deal with

695
00:30:36,580 --> 00:30:38,380
the idea of a template.

696
00:30:38,380 --> 00:30:42,590
Also, you can see if you look
carefully, all the white space

697
00:30:42,590 --> 00:30:44,030
that we put in the template--

698
00:30:44,030 --> 00:30:46,560
just to make it readable
for ourselves--

699
00:30:46,560 --> 00:30:48,460
is removed when it's
translated into

700
00:30:48,460 --> 00:30:49,740
a JavaScript function.

701
00:30:49,740 --> 00:30:51,470
So this saves bytes.

702
00:30:51,470 --> 00:30:53,390
When you traverse the DOM
there's actually fewer white

703
00:30:53,390 --> 00:30:54,960
space nodes that
get in the way.

704
00:30:54,960 --> 00:30:57,720
So these are all nice things
and help you create markup

705
00:30:57,720 --> 00:31:02,260
that's basically as trim
as it can possibly be.

706
00:31:02,260 --> 00:31:04,640
Also I want to point out that
there's these statements that

707
00:31:04,640 --> 00:31:08,100
got inserted at the top, which
are goog.provide and

708
00:31:08,100 --> 00:31:11,420
goog.require, These are
functions that are part of the

709
00:31:11,420 --> 00:31:13,600
Closure Library.

710
00:31:13,600 --> 00:31:16,070
This is basically how namespaces
are declared and

711
00:31:16,070 --> 00:31:18,970
how dependencies are expressed
in the Closure Library.

712
00:31:18,970 --> 00:31:21,100
So as I said, there's no native
import function in

713
00:31:21,100 --> 00:31:23,520
JavaScript but when you write
your code for the Closure

714
00:31:23,520 --> 00:31:26,370
Library in this style, now you
have a standard way of

715
00:31:26,370 --> 00:31:29,920
expressing dependencies and
we'll see the benefits of that

716
00:31:29,920 --> 00:31:32,840
in just a second.

717
00:31:32,840 --> 00:31:35,590
So the first thing is, now if we
have this template function

718
00:31:35,590 --> 00:31:36,790
and now we want to use it.

719
00:31:36,790 --> 00:31:40,140
So now this file we said
we provide this

720
00:31:40,140 --> 00:31:41,670
namespace called widget.

721
00:31:41,670 --> 00:31:44,790
Now we'll have some application
logic, where we

722
00:31:44,790 --> 00:31:45,610
want to use it.

723
00:31:45,610 --> 00:31:48,100
So now there's a goog.require
statement for widget.

724
00:31:48,100 --> 00:31:49,840
And we're actually, ourselves,
going to provide a new

725
00:31:49,840 --> 00:31:52,120
namespace called button.

726
00:31:52,120 --> 00:31:54,890
So here, we add a method to
the button namespace by

727
00:31:54,890 --> 00:31:57,820
declaring it as a property
on the button object.

728
00:31:57,820 --> 00:32:00,760
And the button object got
created as a side effect of

729
00:32:00,760 --> 00:32:03,140
running that goog.provide
statement.

730
00:32:03,140 --> 00:32:05,160
And now we add it
as a property.

731
00:32:05,160 --> 00:32:07,600
It's just a function.

732
00:32:07,600 --> 00:32:10,880
All templates take one argument,
where the argument

733
00:32:10,880 --> 00:32:12,440
is an object literal.

734
00:32:12,440 --> 00:32:15,650
Where the names of the
properties are the values for

735
00:32:15,650 --> 00:32:19,020
the template and the values of
the property are the values

736
00:32:19,020 --> 00:32:20,080
for the template values.

737
00:32:20,080 --> 00:32:23,060
And so basically we create this
data object and now we

738
00:32:23,060 --> 00:32:26,740
can just pass it to
widget.button as a function,

739
00:32:26,740 --> 00:32:30,820
return the value and return
that from get button HTML.

740
00:32:30,820 --> 00:32:32,320
I find this to be--

741
00:32:32,320 --> 00:32:34,220
many people find this to be--
much more maintainable.

742
00:32:34,220 --> 00:32:36,610
Because now, when you want to
write your markup, you can

743
00:32:36,610 --> 00:32:39,030
basically do it in any
way that you want.

744
00:32:39,030 --> 00:32:42,000
You can actually put comments
in this template that don't

745
00:32:42,000 --> 00:32:44,700
get included as part the
markup that's sent out.

746
00:32:44,700 --> 00:32:47,370

747
00:32:47,370 --> 00:32:48,860
And you really want
to write this.

748
00:32:48,860 --> 00:32:50,200
But you don't want to
write it by hand.

749
00:32:50,200 --> 00:32:51,530
But that's what you really
want produced.

750
00:32:51,530 --> 00:32:52,770
And now you have that.

751
00:32:52,770 --> 00:32:54,450
And now you can use
that inside your

752
00:32:54,450 --> 00:32:56,240
regular JavaScript function.

753
00:32:56,240 --> 00:32:58,120
So now we're just really
working in

754
00:32:58,120 --> 00:33:01,140
the JavaScript world.

755
00:33:01,140 --> 00:33:04,110
So as I mentioned, there's these
dependencies that we've

756
00:33:04,110 --> 00:33:06,760
expressed through goog.provide
and goog.require.

757
00:33:06,760 --> 00:33:11,780
So at the top we have button,
which we said requires widget.

758
00:33:11,780 --> 00:33:16,830
And widget requires soy, which
is the internal name of

759
00:33:16,830 --> 00:33:17,630
Closure Templates.

760
00:33:17,630 --> 00:33:20,020
You'll see that if you look
through Closure code.

761
00:33:20,020 --> 00:33:22,360
When you see soy it means
Closure Templates.

762
00:33:22,360 --> 00:33:25,300
And in practice, Closure
Templates by default include a

763
00:33:25,300 --> 00:33:25,960
bunch of stuff.

764
00:33:25,960 --> 00:33:28,010
It includes DOM utilities
because a lot of times you

765
00:33:28,010 --> 00:33:31,295
want to take the result of the
template and put it into a DOM

766
00:33:31,295 --> 00:33:33,710
node or create a document
fragment out of it.

767
00:33:33,710 --> 00:33:36,730
It includes string utilities for
doing the escaping and it

768
00:33:36,730 --> 00:33:39,620
also includes a lot
of utilities for

769
00:33:39,620 --> 00:33:40,210
internationalization.

770
00:33:40,210 --> 00:33:43,970
So there's actually support
for internationalization.

771
00:33:43,970 --> 00:33:47,020
In JavaScript Templates there's
a special message tag.

772
00:33:47,020 --> 00:33:50,760
So if You're building an
application that you want to

773
00:33:50,760 --> 00:33:54,750
localize, Closure Templates
helps with that as well.

774
00:33:54,750 --> 00:33:57,160
But the thing is though, in the
example that I gave, we're

775
00:33:57,160 --> 00:33:58,850
actually not using all
that stuff, right?

776
00:33:58,850 --> 00:34:00,610
We never used the
DOM utilities.

777
00:34:00,610 --> 00:34:03,760
We never used
internationalization.

778
00:34:03,760 --> 00:34:07,810
A lot of people will choose to
maintain these dependencies by

779
00:34:07,810 --> 00:34:10,690
hand saying, oh I don't want
to include all that stuff.

780
00:34:10,690 --> 00:34:12,520
But as we'll see, the Closure
Compiler will take care of

781
00:34:12,520 --> 00:34:13,050
that for you.

782
00:34:13,050 --> 00:34:17,630
So it's OK to create large
libraries, where you, in

783
00:34:17,630 --> 00:34:20,000
practice later, only use
some of the functions.

784
00:34:20,000 --> 00:34:23,570
Because you're going to want to
supply these libraries to,

785
00:34:23,570 --> 00:34:26,489
say, other teammates or
for other projects

786
00:34:26,489 --> 00:34:27,530
that you maybe use.

787
00:34:27,530 --> 00:34:30,630
So in practice, we'll see how
actually the DOM utilities and

788
00:34:30,630 --> 00:34:32,860
the internationalization stuff
gets stripped out.

789
00:34:32,860 --> 00:34:38,980
You don't pay some penalty for
using a more mature library.

790
00:34:38,980 --> 00:34:43,070
So for example, in terms of
leveraging dependencies, we'll

791
00:34:43,070 --> 00:34:44,280
introduce a new one
called myapp.

792
00:34:44,280 --> 00:34:46,219
Now let's say this is
your application.

793
00:34:46,219 --> 00:34:49,989
And now you require button and
you require some DOM utilities

794
00:34:49,989 --> 00:34:53,690
and now you have a function that
goes ahead and uses the

795
00:34:53,690 --> 00:34:56,739
template and inserts it into
the DOM with these standard

796
00:34:56,739 --> 00:34:57,755
DOM utilities.

797
00:34:57,755 --> 00:34:59,455
So now the dependency
graph for your

798
00:34:59,455 --> 00:35:00,370
application has changed.

799
00:35:00,370 --> 00:35:02,530
Now we have a new thing
at the root of the

800
00:35:02,530 --> 00:35:03,910
graph called myapp.

801
00:35:03,910 --> 00:35:06,140
It depends on button and
its dependencies still

802
00:35:06,140 --> 00:35:07,090
go all the way down.

803
00:35:07,090 --> 00:35:09,680
But now myapp depends on DOM.

804
00:35:09,680 --> 00:35:12,420
And so now actually that DOM
dependency is going to come

805
00:35:12,420 --> 00:35:14,570
back into our code.

806
00:35:14,570 --> 00:35:17,650
But the internationalization one
will still be separated.

807
00:35:17,650 --> 00:35:21,610
This is really nice because this
all happens naturally, as

808
00:35:21,610 --> 00:35:23,270
we'll see with the
Closure Compiler.

809
00:35:23,270 --> 00:35:25,900
As opposed to trying to manage
all those script tags by hand

810
00:35:25,900 --> 00:35:29,000
and trying to figure out what
the dependency ordering is and

811
00:35:29,000 --> 00:35:31,020
trying to find the minimal set
because you want to send down

812
00:35:31,020 --> 00:35:33,025
the least JavaScript
code as possible.

813
00:35:33,025 --> 00:35:36,630

814
00:35:36,630 --> 00:35:39,856
Jumping right into the Closure
Compiler and looking at some

815
00:35:39,856 --> 00:35:41,000
of the effects.

816
00:35:41,000 --> 00:35:44,020
So the Closure Compiler, now
with code that is written in

817
00:35:44,020 --> 00:35:46,690
the style, it understands
these goog.provide and

818
00:35:46,690 --> 00:35:48,130
goog.require statements.

819
00:35:48,130 --> 00:35:50,870
Now this is where it gets pretty
serious in terms of the

820
00:35:50,870 --> 00:35:54,140
savings that it can give
you in terms of your

821
00:35:54,140 --> 00:35:55,460
JavaScript code size.

822
00:35:55,460 --> 00:35:58,260
So by default, if you just
concatenated all the files

823
00:35:58,260 --> 00:36:02,630
that would be transitively
required, by that myapp.js

824
00:36:02,630 --> 00:36:07,180
file that I created, it's
375K, approximately.

825
00:36:07,180 --> 00:36:09,040
Very very, large.

826
00:36:09,040 --> 00:36:09,850
That is a lot of code.

827
00:36:09,850 --> 00:36:12,290
Especially for something as
trivial that we were doing.

828
00:36:12,290 --> 00:36:14,110
We were just building
up some HTML and

829
00:36:14,110 --> 00:36:16,645
inserting it into a DOM.

830
00:36:16,645 --> 00:36:18,510
So that does seem
a bit excessive.

831
00:36:18,510 --> 00:36:21,290

832
00:36:21,290 --> 00:36:23,590
But then if you run the Closure
Compiler, there's a

833
00:36:23,590 --> 00:36:24,920
mode called whitespace only.

834
00:36:24,920 --> 00:36:28,320
Where all it does is remove
whitespace and comments.

835
00:36:28,320 --> 00:36:30,770
This already gets you
down quite a bit.

836
00:36:30,770 --> 00:36:34,170
So as you may guess, the Closure
Library is actually

837
00:36:34,170 --> 00:36:36,590
pretty well documented
since that got rid of

838
00:36:36,590 --> 00:36:38,920
almost 75% of the code.

839
00:36:38,920 --> 00:36:42,700
So that's a pretty big
win right there.

840
00:36:42,700 --> 00:36:46,860
By comparison, I also ran the
same code through YUI

841
00:36:46,860 --> 00:36:48,770
Compressor and UglifyJS.

842
00:36:48,770 --> 00:36:52,820
These are some other minifiers
that are popular right now.

843
00:36:52,820 --> 00:36:54,680
You can see they do
a bit better than

844
00:36:54,680 --> 00:36:56,100
whitespace only mode.

845
00:36:56,100 --> 00:36:58,660
And the Closure Compiler also
has the simple mode, which is

846
00:36:58,660 --> 00:37:01,710
analogous to the YUI Compressor
and UglifyJS.

847
00:37:01,710 --> 00:37:03,830
And you can see it just ekes
them out by a little bit.

848
00:37:03,830 --> 00:37:06,280
But we're not looking at an
order of magnitude of

849
00:37:06,280 --> 00:37:07,200
difference.

850
00:37:07,200 --> 00:37:10,620
Until we look at the advanced
mode of the Closure Compiler.

851
00:37:10,620 --> 00:37:13,880
The advanced mode is quite
a different animal.

852
00:37:13,880 --> 00:37:17,820
Basically what it can do is,
as I mentioned it's a whole

853
00:37:17,820 --> 00:37:19,630
program optimize and compiler.

854
00:37:19,630 --> 00:37:22,420
So it basically traces
the code paths

855
00:37:22,420 --> 00:37:25,020
from the main method.

856
00:37:25,020 --> 00:37:25,920
From this main method.

857
00:37:25,920 --> 00:37:29,030
So this is the only function
that's actually called in this

858
00:37:29,030 --> 00:37:29,740
application.

859
00:37:29,740 --> 00:37:32,480
And it can trace through and
realize that, OK, the only

860
00:37:32,480 --> 00:37:35,430
things that are called ate
getButtonHtml getElement and

861
00:37:35,430 --> 00:37:36,420
so on and so forth.

862
00:37:36,420 --> 00:37:40,180
And then when it's done
optimizing, it will only

863
00:37:40,180 --> 00:37:44,610
include the bits that it needs,
that it's determined

864
00:37:44,610 --> 00:37:48,130
that will be exercised by this
JavaScript application.

865
00:37:48,130 --> 00:37:51,330
So now we've gotten down to
something that's 1/200 of the

866
00:37:51,330 --> 00:37:54,700
original size of what we
were dealing with.

867
00:37:54,700 --> 00:37:57,160
This is obviously a much better
way, to let a tool do

868
00:37:57,160 --> 00:38:01,130
this for you than do this
type of thing by hand.

869
00:38:01,130 --> 00:38:06,130
And even to go one step further
is that you can enable

870
00:38:06,130 --> 00:38:09,390
options to eliminate
platform-specific code.

871
00:38:09,390 --> 00:38:12,700
So if you have these special
defines, these special options

872
00:38:12,700 --> 00:38:15,590
pass through the compiler, you
can say, assume that it's

873
00:38:15,590 --> 00:38:18,660
mobile web kit and also assume
it's not JScript, which is the

874
00:38:18,660 --> 00:38:20,270
engine in Internet Explorer.

875
00:38:20,270 --> 00:38:22,430
And in this particular example,
this won't be true

876
00:38:22,430 --> 00:38:26,890
for all examples, but it gets
the whole program down to 481

877
00:38:26,890 --> 00:38:29,170
bytes, which is basically
nothing.

878
00:38:29,170 --> 00:38:32,410
And this is all being done for
you, as opposed to you trying

879
00:38:32,410 --> 00:38:35,590
to reorganize your code and
optimize it by hand in order

880
00:38:35,590 --> 00:38:39,280
to get this same result.

881
00:38:39,280 --> 00:38:42,460
So again, this also comes back
to, I mentioned that libraries

882
00:38:42,460 --> 00:38:45,490
Zepto.js and jQuery where people
are making these forks.

883
00:38:45,490 --> 00:38:48,620
Where instead if they were just
writing their code in a

884
00:38:48,620 --> 00:38:51,590
way that you could eliminate
blocks of code using the

885
00:38:51,590 --> 00:38:54,330
compiler, then they could share
much more of the common

886
00:38:54,330 --> 00:38:58,540
code as opposed to having to do
a giant fork, which is much

887
00:38:58,540 --> 00:39:01,600
harder to keep in sync.

888
00:39:01,600 --> 00:39:04,070
So if we look, this
is the output

889
00:39:04,070 --> 00:39:05,410
of the Closure Compiler.

890
00:39:05,410 --> 00:39:07,920
It's very, very compact.

891
00:39:07,920 --> 00:39:10,410
I was at the JavaScript
conference last week and

892
00:39:10,410 --> 00:39:12,860
someone made the astute
remark of, I don't

893
00:39:12,860 --> 00:39:13,760
want to be a compiler.

894
00:39:13,760 --> 00:39:15,670
I want a compiler to
be a compiler.

895
00:39:15,670 --> 00:39:18,630
And I think that's
a good adage.

896
00:39:18,630 --> 00:39:20,750
But right now we see a lot of
people just trying to use

897
00:39:20,750 --> 00:39:23,300
short variable names and some
other things and trying to do

898
00:39:23,300 --> 00:39:24,040
it all by hand.

899
00:39:24,040 --> 00:39:28,100
But no one is going to write
this type of code by hand,

900
00:39:28,100 --> 00:39:30,190
even though this is really
what we want

901
00:39:30,190 --> 00:39:31,780
produced at the outset.

902
00:39:31,780 --> 00:39:35,260
And as your application gets
larger and larger, it's even

903
00:39:35,260 --> 00:39:35,900
more important.

904
00:39:35,900 --> 00:39:37,840
Because you can imagine, with
that example of five script

905
00:39:37,840 --> 00:39:41,550
tags, you can imagine someone
growing their application to

906
00:39:41,550 --> 00:39:43,820
be 20 script tags and then
someone copy-pastes it because

907
00:39:43,820 --> 00:39:46,640
they think it's what they need
for their next project.

908
00:39:46,640 --> 00:39:50,730
It's just not a way to do large
JavaScript development.

909
00:39:50,730 --> 00:39:52,930
Especially when it's really
important that something

910
00:39:52,930 --> 00:39:57,470
really compact, like what you
see here, is the result.

911
00:39:57,470 --> 00:39:59,630
Another important thing to think
about as well is that,

912
00:39:59,630 --> 00:40:02,520
as our applications are getting
larger in JavaScript,

913
00:40:02,520 --> 00:40:06,280
that there's a lot more IP,
intellectual property, that's

914
00:40:06,280 --> 00:40:07,480
going into these things
that we are

915
00:40:07,480 --> 00:40:09,590
sending down to our users.

916
00:40:09,590 --> 00:40:13,110
And if you've built a very large
JavaScript application,

917
00:40:13,110 --> 00:40:16,790
and now say, you're putting it
in the Chrome Web Store or

918
00:40:16,790 --> 00:40:18,520
various other places, you don't
want to be giving your

919
00:40:18,520 --> 00:40:20,830
source code away, necessarily.

920
00:40:20,830 --> 00:40:23,330
So even though it's not the
primary goal the of the

921
00:40:23,330 --> 00:40:26,150
Compiler, it also effectively
serves as an obfuscator.

922
00:40:26,150 --> 00:40:28,860
It makes it much more difficult
for someone to take

923
00:40:28,860 --> 00:40:32,310
the code that they get and then
add their own features to

924
00:40:32,310 --> 00:40:33,860
it and then claim
it as their own.

925
00:40:33,860 --> 00:40:36,570
So that's another aspect, I
think, that's kind of unique

926
00:40:36,570 --> 00:40:40,500
to development in the large
right now, is that the bulk of

927
00:40:40,500 --> 00:40:41,740
the code is so much
more interesting.

928
00:40:41,740 --> 00:40:44,190
It took you so much more time
to build up, if you're doing

929
00:40:44,190 --> 00:40:47,310
it for business reasons, that
you need to have a better way

930
00:40:47,310 --> 00:40:48,600
to protect it.

931
00:40:48,600 --> 00:40:51,910

932
00:40:51,910 --> 00:40:55,610
Also, as I mentioned, there's
no type system built into

933
00:40:55,610 --> 00:40:56,670
JavaScript natively.

934
00:40:56,670 --> 00:41:00,190
So one of the better ways to
approximate it is by using

935
00:41:00,190 --> 00:41:01,790
basically something
like annotations.

936
00:41:01,790 --> 00:41:02,850
And this is what we see here.

937
00:41:02,850 --> 00:41:07,280
We have some JS stock, as we
call it, and where we have--

938
00:41:07,280 --> 00:41:09,940
we have app param tags
like you're kind of

939
00:41:09,940 --> 00:41:11,630
accustomed to from Java.

940
00:41:11,630 --> 00:41:13,780
But then the thing in curly
braces is what's called a type

941
00:41:13,780 --> 00:41:14,300
expression.

942
00:41:14,300 --> 00:41:18,440
And it basically says, this is
the valid types that can be

943
00:41:18,440 --> 00:41:19,930
passed in for this argument.

944
00:41:19,930 --> 00:41:22,840
We also have this annotation
for a constructor.

945
00:41:22,840 --> 00:41:27,340
So that basically says that, if
the compiler sees you using

946
00:41:27,340 --> 00:41:29,590
this LatLng function but not
using it with the new key

947
00:41:29,590 --> 00:41:30,570
word, it will yell at you.

948
00:41:30,570 --> 00:41:32,980
Because it recognizes that
this is the constructor.

949
00:41:32,980 --> 00:41:34,960
It's something that's meant
to be instantiated.

950
00:41:34,960 --> 00:41:38,210
It's not an ordinary function.

951
00:41:38,210 --> 00:41:42,530
Similarly there's also this
app private annotation.

952
00:41:42,530 --> 00:41:45,180
And it's not on by default but
you can add a check to the

953
00:41:45,180 --> 00:41:48,530
Compiler that says, make sure
all accesses to something

954
00:41:48,530 --> 00:41:52,010
annotated with app private are
only done from what's inside a

955
00:41:52,010 --> 00:41:53,790
Closure class.

956
00:41:53,790 --> 00:41:57,020
So again, as opposed to creating
those somewhat clunky

957
00:41:57,020 --> 00:42:01,020
closures, now you have a way
that better communicates what

958
00:42:01,020 --> 00:42:02,490
you're trying to do, much
more succinctly by

959
00:42:02,490 --> 00:42:03,890
just saying app private.

960
00:42:03,890 --> 00:42:07,130
It also eliminates that run time
overhead, you had before,

961
00:42:07,130 --> 00:42:09,150
of creating a closure.

962
00:42:09,150 --> 00:42:12,950
Now instead of calling a getter
method, the Compiler

963
00:42:12,950 --> 00:42:15,330
can change those getter methods
into direct property

964
00:42:15,330 --> 00:42:18,470
look ups, it can in line them,
and this can further reduce

965
00:42:18,470 --> 00:42:20,300
code size and improve run
time performance.

966
00:42:20,300 --> 00:42:23,130

967
00:42:23,130 --> 00:42:29,630
Also that these type
expressions, they also enable

968
00:42:29,630 --> 00:42:30,480
static typing.

969
00:42:30,480 --> 00:42:34,200
So the Compiler also has logic
to enforce your types.

970
00:42:34,200 --> 00:42:35,900
So just something that you're
accustomed from the Java

971
00:42:35,900 --> 00:42:39,055
compiler or any other very
strongly typed language, this

972
00:42:39,055 --> 00:42:42,010
is something that you can turn
on and have it check to make

973
00:42:42,010 --> 00:42:43,200
sure that the contracts
that you've

974
00:42:43,200 --> 00:42:44,770
declared are being honored.

975
00:42:44,770 --> 00:42:48,630
It actually is able to work with
partial type information

976
00:42:48,630 --> 00:42:50,480
in that you may not
document the types

977
00:42:50,480 --> 00:42:51,720
for all your functions.

978
00:42:51,720 --> 00:42:54,480
But where you do, the compiler
will leverage it and where you

979
00:42:54,480 --> 00:42:57,390
don't, it'll basically
make a best effort.

980
00:42:57,390 --> 00:42:59,260
But it shouldn't return
false positives.

981
00:42:59,260 --> 00:43:02,280

982
00:43:02,280 --> 00:43:04,900
Finally there's a rich type
expression language.

983
00:43:04,900 --> 00:43:08,770
So as I mentioned before, we
often see things where someone

984
00:43:08,770 --> 00:43:10,310
just declares a callback.

985
00:43:10,310 --> 00:43:12,910
Now there's actually a standard
way, or at least from

986
00:43:12,910 --> 00:43:15,500
the perspective of the Closure
Compiler, so that you can say,

987
00:43:15,500 --> 00:43:18,680
this is a function that takes a
LatLng object, which may be

988
00:43:18,680 --> 00:43:21,390
null, which is what the question
mark at the front of

989
00:43:21,390 --> 00:43:22,610
that LatLng signifies.

990
00:43:22,610 --> 00:43:26,030
You can also specify if it's a
var function, the type of its

991
00:43:26,030 --> 00:43:26,640
return type.

992
00:43:26,640 --> 00:43:29,450
This one didn't happen to
have a return type.

993
00:43:29,450 --> 00:43:32,020
And this is a win, both for
the Compiler, because it's

994
00:43:32,020 --> 00:43:35,700
able to do type checking
on more complex

995
00:43:35,700 --> 00:43:37,570
expressions like functions.

996
00:43:37,570 --> 00:43:40,650
But also for your developers,
because they can go and run

997
00:43:40,650 --> 00:43:41,930
through the code and look
really quickly.

998
00:43:41,930 --> 00:43:44,320
Like, oh I just need to pass a
function that takes a LatLng?

999
00:43:44,320 --> 00:43:45,130
Excellent.

1000
00:43:45,130 --> 00:43:48,810
As opposed to having to dig
through the code to figure out

1001
00:43:48,810 --> 00:43:52,270
exactly what it does.

1002
00:43:52,270 --> 00:43:55,830
So to try to bring all together,
JavaScript code

1003
00:43:55,830 --> 00:43:57,020
bases are getting larger.

1004
00:43:57,020 --> 00:43:59,500
I think the Chrome Books
announcement today is also

1005
00:43:59,500 --> 00:44:02,840
very exciting in this regard
in that people are going to

1006
00:44:02,840 --> 00:44:04,070
want to make bigger
and bigger apps.

1007
00:44:04,070 --> 00:44:06,340
They're going to have to be in
JavaScript at some level,

1008
00:44:06,340 --> 00:44:09,520
either translated from GWT
or writing them directly.

1009
00:44:09,520 --> 00:44:11,160
Especially if you want
them to work offline.

1010
00:44:11,160 --> 00:44:13,950
Because then all you have
when it works offline is

1011
00:44:13,950 --> 00:44:17,210
JavaScript, HTML and CSS.

1012
00:44:17,210 --> 00:44:24,986
So as we are bringing more
complex applications to the

1013
00:44:24,986 --> 00:44:28,160
web, these code bases are
going to get larger.

1014
00:44:28,160 --> 00:44:30,230
And JavaScript, unfortunately,
was not designed for

1015
00:44:30,230 --> 00:44:31,590
programming in the large.

1016
00:44:31,590 --> 00:44:34,540
And so one way is to try to
escape it and run to another

1017
00:44:34,540 --> 00:44:35,660
programming language.

1018
00:44:35,660 --> 00:44:38,820
But another option is to try to
tame it, so to speak, with

1019
00:44:38,820 --> 00:44:39,980
the Closure tools.

1020
00:44:39,980 --> 00:44:43,140
And that is what, in
my experiences,

1021
00:44:43,140 --> 00:44:45,590
worked quite well.

1022
00:44:45,590 --> 00:44:48,220
And so I encourage you not to
run from JavaScript but to

1023
00:44:48,220 --> 00:44:51,710
give it a big bear
hug instead.

1024
00:44:51,710 --> 00:44:54,990
But use the Closure tools
to tame it so that your

1025
00:44:54,990 --> 00:44:58,660
application can grow but
not grow out of hand.

1026
00:44:58,660 --> 00:44:59,630
So thank you very much.

1027
00:44:59,630 --> 00:45:00,980
And I now have time
for questions.

1028
00:45:00,980 --> 00:45:02,230
[APPLAUSE]

1029
00:45:02,230 --> 00:45:09,390

1030
00:45:09,390 --> 00:45:11,640
Yep?

1031
00:45:11,640 --> 00:45:15,310
AUDIENCE: I'm not sure I know
anybody who's starting on a

1032
00:45:15,310 --> 00:45:17,090
really big JavaScript project.

1033
00:45:17,090 --> 00:45:20,050
We already have JavaScript
projects and we're probably

1034
00:45:20,050 --> 00:45:21,630
not using Closure tools.

1035
00:45:21,630 --> 00:45:24,440
Very few people are outside
of Google, I feel like.

1036
00:45:24,440 --> 00:45:27,620
How do you transition a very,
very large project--

1037
00:45:27,620 --> 00:45:29,460
I mean the sort of project that
would actually benefit

1038
00:45:29,460 --> 00:45:30,800
from Closure tools--

1039
00:45:30,800 --> 00:45:34,880
onto it without like, OK well,
we're just going to spend the

1040
00:45:34,880 --> 00:45:37,330
next three months writing
comments?

1041
00:45:37,330 --> 00:45:40,310
MICHAEL BOLIN: So I think,
like any migration, you

1042
00:45:40,310 --> 00:45:42,360
certainly want to
do it in pieces.

1043
00:45:42,360 --> 00:45:45,500
And you obviously don't want to
hold up, prevent yourself

1044
00:45:45,500 --> 00:45:48,510
from making any sort of forward
progress while you're

1045
00:45:48,510 --> 00:45:49,750
in transition.

1046
00:45:49,750 --> 00:45:53,920
So the first thing I would say
is using goog.provide and

1047
00:45:53,920 --> 00:45:57,970
goog.require, having some
scaffolding to express the

1048
00:45:57,970 --> 00:45:59,980
dependencies in your
application.

1049
00:45:59,980 --> 00:46:02,760
I would say that is step one.

1050
00:46:02,760 --> 00:46:08,740
Step two is then, you probably
have some existing logic for

1051
00:46:08,740 --> 00:46:13,080
things like registering event
listeners or array utilities.

1052
00:46:13,080 --> 00:46:16,590
And then I think what you do is
you choose one at a time to

1053
00:46:16,590 --> 00:46:19,230
swap out what your home-brewed
solution with the Closure

1054
00:46:19,230 --> 00:46:22,100
Library equivalent and then
you progressively do that.

1055
00:46:22,100 --> 00:46:24,030
This is also what happened
inside Google.

1056
00:46:24,030 --> 00:46:27,090
The Library didn't exist
forever and we had long

1057
00:46:27,090 --> 00:46:30,320
running applications that
were already built up.

1058
00:46:30,320 --> 00:46:31,220
And it was the same problem.

1059
00:46:31,220 --> 00:46:33,850
Because you don't want to just
copy it all in in one day.

1060
00:46:33,850 --> 00:46:35,880
Because then your application
doubles in size and that's not

1061
00:46:35,880 --> 00:46:37,600
really great for your
users either.

1062
00:46:37,600 --> 00:46:40,050
So I think you definitely want
to stage it and you definitely

1063
00:46:40,050 --> 00:46:41,350
want to pick.

1064
00:46:41,350 --> 00:46:43,500
Create the scaffolding with the
require and provide and

1065
00:46:43,500 --> 00:46:45,970
then move things in
as you go forward.

1066
00:46:45,970 --> 00:46:46,890
AUDIENCE: I should clarify.

1067
00:46:46,890 --> 00:46:49,610
We're already using Dojo
provide and require.

1068
00:46:49,610 --> 00:46:52,080
So we already have something
in place.

1069
00:46:52,080 --> 00:46:53,520
Certainly we could replace
them with googs.

1070
00:46:53,520 --> 00:46:54,410
No problem.

1071
00:46:54,410 --> 00:46:57,830
But it's actually really the
Closure Compiler, which seems

1072
00:46:57,830 --> 00:46:59,690
like it's an all or
nothing thing.

1073
00:46:59,690 --> 00:47:02,450
Like either everything is marked
up with comments so it

1074
00:47:02,450 --> 00:47:04,700
knows what to delete or it
deletes your application.

1075
00:47:04,700 --> 00:47:07,330

1076
00:47:07,330 --> 00:47:08,820
MICHAEL BOLIN: As I showed, the
Closure Compiler does have

1077
00:47:08,820 --> 00:47:09,500
different modes.

1078
00:47:09,500 --> 00:47:11,270
So there's simple mode,
for example.

1079
00:47:11,270 --> 00:47:12,500
AUDIENCE: I really want
advanced mode.

1080
00:47:12,500 --> 00:47:14,130
That's where I feel like
I get the big benefit.

1081
00:47:14,130 --> 00:47:15,400
How do I ever get there?

1082
00:47:15,400 --> 00:47:17,360
It's a million miles away.

1083
00:47:17,360 --> 00:47:19,190
MICHAEL BOLIN: I think that
some people in the Dojo

1084
00:47:19,190 --> 00:47:21,320
community, well I'm sure more
than some, are interested in

1085
00:47:21,320 --> 00:47:23,040
this as well.

1086
00:47:23,040 --> 00:47:25,390
Another thing you can do is, the
compiler is open source.

1087
00:47:25,390 --> 00:47:28,670
It is written in Java and it has
its own plugin system such

1088
00:47:28,670 --> 00:47:31,810
that you can write new
compiler passes.

1089
00:47:31,810 --> 00:47:35,100
So if you have a large, if you
feel like your code base is

1090
00:47:35,100 --> 00:47:37,640
too large to migrate, the right
thing to do, or the

1091
00:47:37,640 --> 00:47:39,810
simplest thing to do--
as simple as writing

1092
00:47:39,810 --> 00:47:41,000
compiler code is--

1093
00:47:41,000 --> 00:47:44,090
but is to write your own pass.

1094
00:47:44,090 --> 00:47:45,430
Fortunately the Closure
Compiler has a

1095
00:47:45,430 --> 00:47:46,650
lot of passes already.

1096
00:47:46,650 --> 00:47:48,910
And they're also very
well unit tested.

1097
00:47:48,910 --> 00:47:51,010
So if you break something
it'll be pretty clear.

1098
00:47:51,010 --> 00:47:53,220
And you also have a lot of
sample code to go off.

1099
00:47:53,220 --> 00:47:55,830
So you might want to write your
own pass that understands

1100
00:47:55,830 --> 00:47:57,710
Dojo a bit better.

1101
00:47:57,710 --> 00:48:00,110
And then that may be the best
way for you to leverage it.

1102
00:48:00,110 --> 00:48:01,560
AUDIENCE: So we don't have
a lot of, even Dojo

1103
00:48:01,560 --> 00:48:05,200
doc common in there.

1104
00:48:05,200 --> 00:48:07,644
MICHAEL BOLIN: What
do you have?

1105
00:48:07,644 --> 00:48:08,800
AUDIENCE: We've got comments.

1106
00:48:08,800 --> 00:48:10,290
We've got sort of ordinary
comments.

1107
00:48:10,290 --> 00:48:12,410
But we didn't make type
parameter comments.

1108
00:48:12,410 --> 00:48:13,680
Who would, right?

1109
00:48:13,680 --> 00:48:14,930
What's the point of those?

1110
00:48:14,930 --> 00:48:17,660

1111
00:48:17,660 --> 00:48:20,590
MICHAEL BOLIN: Type checking is
an option of the advanced

1112
00:48:20,590 --> 00:48:21,770
mode to get the minification.

1113
00:48:21,770 --> 00:48:23,470
It's not a requirement.

1114
00:48:23,470 --> 00:48:27,420
So you don't have to have
everything marked up with type

1115
00:48:27,420 --> 00:48:30,410
expressions to even use advanced
mode, necessarily.

1116
00:48:30,410 --> 00:48:32,820
It's more helpful if you do but
it's not a hard and fast

1117
00:48:32,820 --> 00:48:34,130
requirement.

1118
00:48:34,130 --> 00:48:37,390
AUDIENCE: Can I, if I have
half my code marked up--

1119
00:48:37,390 --> 00:48:40,250
or really, a hundredth of my
code marked up with type

1120
00:48:40,250 --> 00:48:42,160
parameters can I use
that at all?

1121
00:48:42,160 --> 00:48:43,260
MICHAEL BOLIN: Yeah,
absolutely.

1122
00:48:43,260 --> 00:48:46,970
So basically every time omit a
type expression, it assumes

1123
00:48:46,970 --> 00:48:48,760
that the type expression would
be asterisk, which

1124
00:48:48,760 --> 00:48:50,310
means the any type.

1125
00:48:50,310 --> 00:48:54,250
And so it already has
mechanisms to

1126
00:48:54,250 --> 00:48:55,360
deal with that situation.

1127
00:48:55,360 --> 00:48:58,440
AUDIENCE: So if I replaced
all my Dojo requires with

1128
00:48:58,440 --> 00:49:02,670
goog.requires and run the
advanced Compiler, what's

1129
00:49:02,670 --> 00:49:03,200
about to happen?

1130
00:49:03,200 --> 00:49:04,600
It's going to delete
my [? location ?]

1131
00:49:04,600 --> 00:49:04,730
right?

1132
00:49:04,730 --> 00:49:06,280
MICHAEL BOLIN: There are some
other caveats that are

1133
00:49:06,280 --> 00:49:08,440
actually well documented
on the website.

1134
00:49:08,440 --> 00:49:11,490
In terms of things like quoting
properties, is a

1135
00:49:11,490 --> 00:49:13,940
common one.

1136
00:49:13,940 --> 00:49:16,010
That's probably the biggest one
off the top of my head.

1137
00:49:16,010 --> 00:49:18,760
But I think most Dojo code
is pretty similar.

1138
00:49:18,760 --> 00:49:22,820
So I don't think it would be a
disaster but there's a very

1139
00:49:22,820 --> 00:49:25,980
good page on code.google.com
that says hazards of using

1140
00:49:25,980 --> 00:49:26,573
advanced mode.

1141
00:49:26,573 --> 00:49:28,280
And it should help you
audit your code for

1142
00:49:28,280 --> 00:49:29,470
those types of things.

1143
00:49:29,470 --> 00:49:32,060
AUDIENCE: Thanks.

1144
00:49:32,060 --> 00:49:33,030
AUDIENCE: Hi.

1145
00:49:33,030 --> 00:49:36,220
We have a pretty big
JavaScript project.

1146
00:49:36,220 --> 00:49:38,590
Probably a couple megs of
source or something.

1147
00:49:38,590 --> 00:49:39,430
Big project.

1148
00:49:39,430 --> 00:49:42,310
But we switched over to the
Closure Compiler last summer

1149
00:49:42,310 --> 00:49:43,550
and we've been totally
thrilled with it.

1150
00:49:43,550 --> 00:49:47,440
But this is the first time
we've seen the Templates.

1151
00:49:47,440 --> 00:49:49,960
And I think it's something
we're interested in.

1152
00:49:49,960 --> 00:49:52,780
I am curious-- because it looks
like you have to run a

1153
00:49:52,780 --> 00:49:56,100
compiler pass just to use them--
is there any, so I

1154
00:49:56,100 --> 00:49:59,190
know, like, we're using the
advanced mode compilation but

1155
00:49:59,190 --> 00:50:00,765
you can run it uncompiled
and the

1156
00:50:00,765 --> 00:50:04,260
goog.requires just do XHR requests.

1157
00:50:04,260 --> 00:50:06,030
Get the code and eval
them and stuff.

1158
00:50:06,030 --> 00:50:08,630
Is there an equivalent for those
templates, that you can

1159
00:50:08,630 --> 00:50:10,470
run them straight from source?

1160
00:50:10,470 --> 00:50:12,980
Because at this point, running
the compiler takes some time.

1161
00:50:12,980 --> 00:50:15,790
Because it's a big project.

1162
00:50:15,790 --> 00:50:18,720
MICHAEL BOLIN: So built a
tool, for some reason I

1163
00:50:18,720 --> 00:50:19,890
neglected to put it
in my slides.

1164
00:50:19,890 --> 00:50:22,020
It's called Plovr.

1165
00:50:22,020 --> 00:50:25,020
My O'Riley animal is the golden
plover, so I named my

1166
00:50:25,020 --> 00:50:27,620
tool Plovr, without an e because
I wanted to be cool

1167
00:50:27,620 --> 00:50:28,790
like Flickr.

1168
00:50:28,790 --> 00:50:33,670
But if you take a look, what it
does is it has some modes

1169
00:50:33,670 --> 00:50:36,450
that basically you can just
point it at a directory of

1170
00:50:36,450 --> 00:50:40,030
JavaScript in Closure Templates
files and it will

1171
00:50:40,030 --> 00:50:41,930
just spin up and serve
them from disk.

1172
00:50:41,930 --> 00:50:46,390
And the JS ones it will serve
verbatim and the dot.soi files

1173
00:50:46,390 --> 00:50:49,330
for Closure Templates, it'll
translate them on the fly.

1174
00:50:49,330 --> 00:50:52,870
So you're development, you can
still debug what is basically

1175
00:50:52,870 --> 00:50:56,520
raw code but not have to run the
compiler over everything

1176
00:50:56,520 --> 00:50:57,200
to get that.

1177
00:50:57,200 --> 00:50:58,695
Because I understand that
for larger code

1178
00:50:58,695 --> 00:51:00,260
bases it is a bit slower.

1179
00:51:00,260 --> 00:51:00,670
AUDIENCE: OK.

1180
00:51:00,670 --> 00:51:00,850
Cool.

1181
00:51:00,850 --> 00:51:02,100
Thanks.

1182
00:51:02,100 --> 00:51:04,580

1183
00:51:04,580 --> 00:51:06,200
AUDIENCE: I actually have
two questions for you.

1184
00:51:06,200 --> 00:51:09,514
The first question is about
browser native functionality.

1185
00:51:09,514 --> 00:51:12,630
The Closure Compiler, is it
smart enough to detect that

1186
00:51:12,630 --> 00:51:13,570
kind of functionality?

1187
00:51:13,570 --> 00:51:17,020
And then, if so, when new
browser-capable features come

1188
00:51:17,020 --> 00:51:20,587
out, what's the delay time
between the library being

1189
00:51:20,587 --> 00:51:25,780
updated versus not and being
able to support those.

1190
00:51:25,780 --> 00:51:27,030
MICHAEL BOLIN: That's
a good question.

1191
00:51:27,030 --> 00:51:29,200

1192
00:51:29,200 --> 00:51:30,600
So basically you're writing
in JavaScript.

1193
00:51:30,600 --> 00:51:33,760
So if it's there you can you
test in JavaScript as you

1194
00:51:33,760 --> 00:51:34,580
normally would.

1195
00:51:34,580 --> 00:51:37,470
You could say, if document.body
query selector

1196
00:51:37,470 --> 00:51:39,250
all and then do one thing.

1197
00:51:39,250 --> 00:51:41,290
And if not, do another thing.

1198
00:51:41,290 --> 00:51:43,770
But there's also this idea,
when using the compiler in

1199
00:51:43,770 --> 00:51:45,870
advanced mode, this idea of
what's called externs.

1200
00:51:45,870 --> 00:51:48,560
Where you basically say, these
are all the symbols that are

1201
00:51:48,560 --> 00:51:50,450
going to exist in the
environment in which my code

1202
00:51:50,450 --> 00:51:52,530
runs and their type
definitions.

1203
00:51:52,530 --> 00:51:54,590
So document and window and
that sort of thing.

1204
00:51:54,590 --> 00:51:57,270
Because as you saw, the Closure
Compiler renamed a

1205
00:51:57,270 --> 00:51:58,260
whole bunch of variables.

1206
00:51:58,260 --> 00:51:59,700
But it can't rename the
built-ins, like

1207
00:51:59,700 --> 00:52:02,490
document and window.

1208
00:52:02,490 --> 00:52:05,870
So when you're talking about
browser features, those are

1209
00:52:05,870 --> 00:52:09,250
usually listed in these externs
files that declare

1210
00:52:09,250 --> 00:52:11,300
basically what's in the
browser environment.

1211
00:52:11,300 --> 00:52:15,490
Those are updated pretty
quickly, I would say.

1212
00:52:15,490 --> 00:52:17,280
Because a lot of projects,
people

1213
00:52:17,280 --> 00:52:19,160
are pushing the envelope.

1214
00:52:19,160 --> 00:52:21,640
In that sense the compiler,
the time between a feature

1215
00:52:21,640 --> 00:52:24,590
coming out to being used by the
Compiler, or available or

1216
00:52:24,590 --> 00:52:28,420
recognized by the compiler
is pretty small.

1217
00:52:28,420 --> 00:52:30,650
AUDIENCE: My second question
was about development.

1218
00:52:30,650 --> 00:52:33,466
It looks like you don't get that
minified code until after

1219
00:52:33,466 --> 00:52:35,980
you've run through the compiler,
which makes sense.

1220
00:52:35,980 --> 00:52:38,900
When I'm doing actual
development and I'm debugging

1221
00:52:38,900 --> 00:52:41,530
with Firebug or Chrome's
developer tools, do I have to

1222
00:52:41,530 --> 00:52:44,750
load up all 150 or whatever
megabyte of

1223
00:52:44,750 --> 00:52:47,590
those library files?

1224
00:52:47,590 --> 00:52:49,890
MICHAEL BOLIN: It depends
how you do it.

1225
00:52:49,890 --> 00:52:52,220
So one thing you can also do
with the Closure Compiler,

1226
00:52:52,220 --> 00:52:54,640
which I didn't demonstrate
today, is you can have this

1227
00:52:54,640 --> 00:52:55,540
idea modules.

1228
00:52:55,540 --> 00:52:59,670
So GWT has this idea of code
splitting, where you can say

1229
00:52:59,670 --> 00:53:02,070
when I'm only using up to this
feature, then only include

1230
00:53:02,070 --> 00:53:03,180
these JavaScript files.

1231
00:53:03,180 --> 00:53:05,740
And then if the user starts
using this other feature, then

1232
00:53:05,740 --> 00:53:07,650
pull down these other files.

1233
00:53:07,650 --> 00:53:11,600
So one really good technique is
to use this modules feature

1234
00:53:11,600 --> 00:53:13,950
of the compiler, which
ultimately will compile

1235
00:53:13,950 --> 00:53:18,490
optimized version of each of
those clumps of code and will

1236
00:53:18,490 --> 00:53:21,090
depend on the symbols that
exist in the code that's

1237
00:53:21,090 --> 00:53:22,010
already loaded.

1238
00:53:22,010 --> 00:53:25,050
So basically, you're only
loading the minimal set of

1239
00:53:25,050 --> 00:53:28,190
files for the functionality
you need right now as the

1240
00:53:28,190 --> 00:53:30,240
user, say, goes to the
settings page.

1241
00:53:30,240 --> 00:53:32,910
And now the settings code,
now it'll pull that down,

1242
00:53:32,910 --> 00:53:35,360
basically on demand.

1243
00:53:35,360 --> 00:53:36,730
And this works in
development too.

1244
00:53:36,730 --> 00:53:38,460
So it will only be the
individual files that

1245
00:53:38,460 --> 00:53:41,890
contribute to, what I'm
calling a module.

1246
00:53:41,890 --> 00:53:45,360
So, no, you don't have to
necessarily load everything

1247
00:53:45,360 --> 00:53:46,910
when you start up.

1248
00:53:46,910 --> 00:53:48,160
AUDIENCE: Thanks.

1249
00:53:48,160 --> 00:53:50,480

1250
00:53:50,480 --> 00:53:51,330
AUDIENCE: Does this one work?

1251
00:53:51,330 --> 00:53:51,600
MICHAEL BOLIN: Sorry.

1252
00:53:51,600 --> 00:53:52,220
I didn't see you.

1253
00:53:52,220 --> 00:53:53,490
The lights are bright.

1254
00:53:53,490 --> 00:53:54,590
AUDIENCE: This relates to
the first question.

1255
00:53:54,590 --> 00:53:57,930
You had that one slide, where
you had the prototype with the

1256
00:53:57,930 --> 00:54:01,480
dollar sign w, I've used Closure
to do some newer

1257
00:54:01,480 --> 00:54:02,630
projects, but I have
a lot of legacy

1258
00:54:02,630 --> 00:54:06,260
projects with Prototype.

1259
00:54:06,260 --> 00:54:10,230
Will the compiler deal with
those types of commands, to

1260
00:54:10,230 --> 00:54:10,830
compile them down?

1261
00:54:10,830 --> 00:54:13,060
Or do you have to pretty much
remove all the Prototype to

1262
00:54:13,060 --> 00:54:14,840
get the compiler to work?

1263
00:54:14,840 --> 00:54:15,210
MICHAEL BOLIN: Well no.

1264
00:54:15,210 --> 00:54:18,470
So if you supply the Prototype
source code as an input to the

1265
00:54:18,470 --> 00:54:20,990
compiler, it will treat it
like any other input.

1266
00:54:20,990 --> 00:54:22,160
And also if--

1267
00:54:22,160 --> 00:54:24,530
so unused functions will then
also still go away.

1268
00:54:24,530 --> 00:54:27,320
And interestingly, if you have
a function that you use a lot

1269
00:54:27,320 --> 00:54:31,040
in the Closure Library and it
has a very verbose name, the

1270
00:54:31,040 --> 00:54:34,420
compiler will pick the smallest
names for the

1271
00:54:34,420 --> 00:54:37,490
functions that are used the
most. So possibly your

1272
00:54:37,490 --> 00:54:39,640
prototype functions could get
renamed to longer things,

1273
00:54:39,640 --> 00:54:41,990
although they're only two bytes
so it's probably not.

1274
00:54:41,990 --> 00:54:44,350
Actually it would be longer.

1275
00:54:44,350 --> 00:54:45,680
But basically, sorry,
the short answer to

1276
00:54:45,680 --> 00:54:46,660
your question is yes.

1277
00:54:46,660 --> 00:54:49,170
You can use the Prototype
code with the compiler.

1278
00:54:49,170 --> 00:54:51,680

1279
00:54:51,680 --> 00:54:53,700
AUDIENCE: So one of the most fun
things in the world about

1280
00:54:53,700 --> 00:54:57,390
doing JavaScript is after you've
minified it, that you

1281
00:54:57,390 --> 00:55:00,720
get a bug report
from the field.

1282
00:55:00,720 --> 00:55:04,070
So is there an equivalent to a
symbol table or something that

1283
00:55:04,070 --> 00:55:08,190
could be added in say, a
less-than perfectly optimized?

1284
00:55:08,190 --> 00:55:09,860
MICHAEL BOLIN: Yep.

1285
00:55:09,860 --> 00:55:12,440
So basically there's an option,
when you run the

1286
00:55:12,440 --> 00:55:15,110
compiler, to output as a
byproduct, a thing called a

1287
00:55:15,110 --> 00:55:16,040
source map.

1288
00:55:16,040 --> 00:55:19,480
And so it is a reverse mapping,
it's actually every

1289
00:55:19,480 --> 00:55:22,860
line and character in your
compiled code, to the line and

1290
00:55:22,860 --> 00:55:27,310
character position in the
original source code.

1291
00:55:27,310 --> 00:55:31,700
And then there's some other
Java code that's there for

1292
00:55:31,700 --> 00:55:34,450
taking a JavaScript stack trace
from the server and

1293
00:55:34,450 --> 00:55:38,450
converting it into an obfuscated
JavaScript file.

1294
00:55:38,450 --> 00:55:43,000
The only caveat is that, you
really care about the line and

1295
00:55:43,000 --> 00:55:43,710
the character offset.

1296
00:55:43,710 --> 00:55:46,010
And I believe right now, only
Chrome-- and I guess probably

1297
00:55:46,010 --> 00:55:47,130
then Safari--

1298
00:55:47,130 --> 00:55:48,560
provide both the line
and the character.

1299
00:55:48,560 --> 00:55:51,340
Most of the other browsers
only do the line.

1300
00:55:51,340 --> 00:55:54,200
I haven't checked Firefox 4, but
at least Firefox 3.6 still

1301
00:55:54,200 --> 00:55:55,790
only sent the line number.

1302
00:55:55,790 --> 00:55:59,940
So if anyone has influence over
any of those folks, it'd

1303
00:55:59,940 --> 00:56:01,680
be great if they also sent
character offsets.

1304
00:56:01,680 --> 00:56:04,580
Because, to exactly the point
that you're making.

1305
00:56:04,580 --> 00:56:07,322

1306
00:56:07,322 --> 00:56:10,760
AUDIENCE: Is Closure planning to
implement the common module

1307
00:56:10,760 --> 00:56:14,460
dependency, CommonJS standard?

1308
00:56:14,460 --> 00:56:15,260
MICHAEL BOLIN: That's
a good question.

1309
00:56:15,260 --> 00:56:17,580
So there is no plan
and there's no

1310
00:56:17,580 --> 00:56:19,620
anti-plan as far as I know.

1311
00:56:19,620 --> 00:56:22,770
In that they're not hating on
it and they maybe haven't

1312
00:56:22,770 --> 00:56:26,110
figured out exactly how to
merge the two worlds.

1313
00:56:26,110 --> 00:56:31,060
I think, if there were a good
proposal put forth on how to

1314
00:56:31,060 --> 00:56:34,140
combine those two things, I
think the people who work on

1315
00:56:34,140 --> 00:56:35,420
Closure would be
very interested

1316
00:56:35,420 --> 00:56:37,130
in making that happen.

1317
00:56:37,130 --> 00:56:38,430
AUDIENCE: Are you still
working on Closure?

1318
00:56:38,430 --> 00:56:40,210
Or is that something Google
works on and you

1319
00:56:40,210 --> 00:56:41,080
don't work on anymore.

1320
00:56:41,080 --> 00:56:43,650
MICHAEL BOLIN: I contribute
to Closure for sure.

1321
00:56:43,650 --> 00:56:46,680
And I certainly talk
to those folks.

1322
00:56:46,680 --> 00:56:49,240
We had a discussion just last
week about it and it was kind

1323
00:56:49,240 --> 00:56:52,600
of like, one of the many items
on the list. It's certainly

1324
00:56:52,600 --> 00:56:55,650
something that we'd like to
address but it hasn't bubbled

1325
00:56:55,650 --> 00:56:56,900
to the top yet.

1326
00:56:56,900 --> 00:57:00,326

1327
00:57:00,326 --> 00:57:01,760
Anybody else?

1328
00:57:01,760 --> 00:57:03,340
Thank you, everyone.

1329
00:57:03,340 --> 00:57:05,360
I hope you enjoy Google I/O.

1330
00:57:05,360 --> 00:57:06,482

