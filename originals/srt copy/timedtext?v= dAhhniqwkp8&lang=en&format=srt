1
00:00:00,000 --> 00:00:03,550

2
00:00:03,550 --> 00:00:05,200
SAM DUTTON: And I think
we're off, yeah?

3
00:00:05,200 --> 00:00:07,770
We're all ready to go.

4
00:00:07,770 --> 00:00:10,090
I think we're live and
broadcasting now.

5
00:00:10,090 --> 00:00:14,790
The wonders of real-time
communication.

6
00:00:14,790 --> 00:00:19,800
We've crossed over and just to
say hello and apologies for

7
00:00:19,800 --> 00:00:21,770
the problems earlier of trying
get us hooked up.

8
00:00:21,770 --> 00:00:23,510
But we are up and running now.

9
00:00:23,510 --> 00:00:26,220
So just to introduce myself--
my name is Sam Dutton.

10
00:00:26,220 --> 00:00:29,990
I'm a developer advocate for
Google Chrome based in London,

11
00:00:29,990 --> 00:00:32,520
coming from London today.

12
00:00:32,520 --> 00:00:35,270
Yeah, we've got people from
all around the world.

13
00:00:35,270 --> 00:00:38,070
So if we could just cross over
to the others now, and people

14
00:00:38,070 --> 00:00:40,630
could introduce themselves
and see who's here.

15
00:00:40,630 --> 00:00:43,790

16
00:00:43,790 --> 00:00:46,610
JUSTIN UBERTI: Hi, I'm
Justin Uberti.

17
00:00:46,610 --> 00:00:49,900
MALANET: Hi, I'm Malanet
[INAUDIBLE].

18
00:00:49,900 --> 00:00:52,570
TOM: And I'm Tom [INAUDIBLE].

19
00:00:52,570 --> 00:00:54,205
SERGE LACHAPELLE: And I'm from
Stockholm, I'm Serge

20
00:00:54,205 --> 00:00:55,970
Lachapelle.

21
00:00:55,970 --> 00:00:57,170
SAM DUTTON: Fantastic.

22
00:00:57,170 --> 00:00:59,350
It's great to see
everyone here.

23
00:00:59,350 --> 00:01:03,030
So what we're going to today is
we're going to kind of give

24
00:01:03,030 --> 00:01:07,370
an overview of WebRTC and see
where we are now, and talk

25
00:01:07,370 --> 00:01:09,930
through, just very quickly,
the sort of basics of the

26
00:01:09,930 --> 00:01:12,430
technology, and then really
go over the questions.

27
00:01:12,430 --> 00:01:14,830
We've had great questions on
Moderator from everyone.

28
00:01:14,830 --> 00:01:17,310
So thanks very much
for that stuff.

29
00:01:17,310 --> 00:01:21,980
First, I'd just like to just
give you two inspirational

30
00:01:21,980 --> 00:01:23,283
quotes from people
that I've heard.

31
00:01:23,283 --> 00:01:26,330
And the first one is from
Brendan Eich, who's the

32
00:01:26,330 --> 00:01:28,180
inventor of JavaScript.

33
00:01:28,180 --> 00:01:33,540
And he says that's be believes
that "WebRTC is a new front in

34
00:01:33,540 --> 00:01:36,250
the long war for an open
and unencumbered

35
00:01:36,250 --> 00:01:38,520
web," so strong words.

36
00:01:38,520 --> 00:01:43,050
And another quote from Phil
Edholm, blogger, who says

37
00:01:43,050 --> 00:01:47,010
that, "Potentially WebRTC and
HTML5 could enable the same

38
00:01:47,010 --> 00:01:49,810
transformation for real-time
communications that the

39
00:01:49,810 --> 00:01:53,350
original browser did
for information."

40
00:01:53,350 --> 00:01:54,480
So it's strong stuff.

41
00:01:54,480 --> 00:02:00,410
And we believe that WebRTC
has huge potential.

42
00:02:00,410 --> 00:02:03,230
So for those who are kind of new
to the topic, just a very

43
00:02:03,230 --> 00:02:06,200
quick overview of what
WebRTC actually is.

44
00:02:06,200 --> 00:02:10,080
And it's kind of a collection
of standards for real-time

45
00:02:10,080 --> 00:02:14,030
plug-in free video, audio,
and data communication.

46
00:02:14,030 --> 00:02:16,390
Now there are some existing
services that

47
00:02:16,390 --> 00:02:18,210
do stuff like this--

48
00:02:18,210 --> 00:02:20,600
Google Talk and Skype
and so on.

49
00:02:20,600 --> 00:02:23,650
But all of these use plug-ins.

50
00:02:23,650 --> 00:02:28,610
And we believe that WebRTC
can do real time more

51
00:02:28,610 --> 00:02:30,870
efficiently than that.

52
00:02:30,870 --> 00:02:34,137
So the first question, I guess,
people are asking is,

53
00:02:34,137 --> 00:02:37,790
well, what do I need
to do WebRTC?

54
00:02:37,790 --> 00:02:42,140
Well, you're going to need a
source of streaming video, or

55
00:02:42,140 --> 00:02:45,640
audio, or, in the
future, data.

56
00:02:45,640 --> 00:02:50,290
You're going to need a way to
communicate that video, audio,

57
00:02:50,290 --> 00:02:52,750
or data to other peers.

58
00:02:52,750 --> 00:02:58,420
And you're going to have to
exchange some kind of messages

59
00:02:58,420 --> 00:03:00,960
between each other to initiate
sessions, to close sessions,

60
00:03:00,960 --> 00:03:04,700
and also, of course, to report
errors as they happen.

61
00:03:04,700 --> 00:03:07,820
And you're going to need to be
able to exchange, between

62
00:03:07,820 --> 00:03:11,850
peers, information about media
and configuration--

63
00:03:11,850 --> 00:03:15,350
things like resolution
and format.

64
00:03:15,350 --> 00:03:19,530
And of course, you're also going
to need ways to actually

65
00:03:19,530 --> 00:03:22,040
let people get in touch
with each other.

66
00:03:22,040 --> 00:03:27,150
So in terms of what WebRTC has
brought to the web, in terms

67
00:03:27,150 --> 00:03:32,840
of APIs, we have MediaStream
for getting streaming data.

68
00:03:32,840 --> 00:03:38,880
We have PeerConnection for
communicating data, and then

69
00:03:38,880 --> 00:03:42,640
what we're going to be seeing
implemented is Data Channel as

70
00:03:42,640 --> 00:03:46,200
a method of exchanging
streaming data.

71
00:03:46,200 --> 00:03:50,450
So a really powerful
set of APIs there.

72
00:03:50,450 --> 00:03:54,000
Now, that's looking on
the client side.

73
00:03:54,000 --> 00:03:58,170
If we go to the server,
WebRTC, real-time

74
00:03:58,170 --> 00:04:00,540
communication, is always
going to need

75
00:04:00,540 --> 00:04:02,400
servers, however simple.

76
00:04:02,400 --> 00:04:06,270
You need for users to be able to
discover each other, users

77
00:04:06,270 --> 00:04:10,170
to be able send in details to
each other, and communication

78
00:04:10,170 --> 00:04:14,040
that can survive network
glitches.

79
00:04:14,040 --> 00:04:18,370
And so that client applications
can send data

80
00:04:18,370 --> 00:04:21,329
about the media they're working
with, like I said.

81
00:04:21,329 --> 00:04:25,710
So information about resolution,
format, and so on.

82
00:04:25,710 --> 00:04:28,370
And we also-- this is
very important--

83
00:04:28,370 --> 00:04:31,600
of course, lots of client
applications are going to be

84
00:04:31,600 --> 00:04:33,720
behind net gateways--

85
00:04:33,720 --> 00:04:34,970
firewalls and so on.

86
00:04:34,970 --> 00:04:38,800
And so WebRTC client
applications are going to need

87
00:04:38,800 --> 00:04:42,310
to be able to communicate
across those barriers.

88
00:04:42,310 --> 00:04:47,180
So thinking from the server
side, WebRTC needs two types

89
00:04:47,180 --> 00:04:49,430
of server-side functionality.

90
00:04:49,430 --> 00:04:53,760
You need stuff to do user
discovery communication

91
00:04:53,760 --> 00:04:58,670
signaling between clients, and
then you need servers that can

92
00:04:58,670 --> 00:05:04,900
help with net traversal and
streaming data communication.

93
00:05:04,900 --> 00:05:10,230
So what I would suggest is, if
you haven't done so already,

94
00:05:10,230 --> 00:05:14,230
especially if you're to WebRTC
is, do take a look at Justin

95
00:05:14,230 --> 00:05:17,640
Uberti's video from Google
I/O. You can

96
00:05:17,640 --> 00:05:18,680
find that on YouTube.

97
00:05:18,680 --> 00:05:24,960
So Justin Uberti's WebRTC Google
I/O video, which is

98
00:05:24,960 --> 00:05:25,820
great stuff.

99
00:05:25,820 --> 00:05:28,200
And if you want to find
out more about

100
00:05:28,200 --> 00:05:30,560
getUserMedia, the sort of--

101
00:05:30,560 --> 00:05:36,030
what you might have seen in
terms of stuff for using media

102
00:05:36,030 --> 00:05:38,860
stream-- take a look
at the HTML5 Rocks.

103
00:05:38,860 --> 00:05:43,070
HTML5rocks.com has a lot of
great documentation about

104
00:05:43,070 --> 00:05:45,600
using media streams, in
particular of course,

105
00:05:45,600 --> 00:05:46,850
getUserMedia.

106
00:05:46,850 --> 00:05:49,780

107
00:05:49,780 --> 00:05:55,820
Now, what I would also suggest
is having a look, initially,

108
00:05:55,820 --> 00:05:58,540
to get your head around the
idea of peer connection.

109
00:05:58,540 --> 00:06:02,670
And if you looked at WebRTC.org,
you'll find some

110
00:06:02,670 --> 00:06:04,230
great information there.

111
00:06:04,230 --> 00:06:08,900
But one of the sites I would
recommend just to begin

112
00:06:08,900 --> 00:06:15,390
looking at peer connection is
WebRTC-demos.appspot.com,

113
00:06:15,390 --> 00:06:17,760
that's WebRTC-demos.appspot.com.

114
00:06:17,760 --> 00:06:21,672
And we will have links for these
available on the site.

115
00:06:21,672 --> 00:06:24,270

116
00:06:24,270 --> 00:06:27,273
And then, once you've understood
something of peer

117
00:06:27,273 --> 00:06:31,040
connection, what you need to
do, I think, is move on to

118
00:06:31,040 --> 00:06:32,790
significalling and data
communication.

119
00:06:32,790 --> 00:06:35,375
And a great place to start that
is appRTC.appspot.com.

120
00:06:35,375 --> 00:06:38,080

121
00:06:38,080 --> 00:06:40,330
And again, we'll put the
links up for that.

122
00:06:40,330 --> 00:06:44,140
So just to get straight down
here, we've, like I said, had

123
00:06:44,140 --> 00:06:49,100
some great questions from people
who are coming in to

124
00:06:49,100 --> 00:06:53,710
see what they'd like to
find out about WebRTC.

125
00:06:53,710 --> 00:06:57,830
So I'm just going to go over
now to the questions.

126
00:06:57,830 --> 00:07:02,700
And see what we've got on
Moderator, and then ask our

127
00:07:02,700 --> 00:07:04,470
panel of experts here.

128
00:07:04,470 --> 00:07:08,460
So OK, just starting straight
at the top.

129
00:07:08,460 --> 00:07:12,490
And, I guess Serge, I'll let
you dive in and see who you

130
00:07:12,490 --> 00:07:13,910
think might be best
to answer this.

131
00:07:13,910 --> 00:07:18,940
First question is from AIDGAB,
coming from Kazan.

132
00:07:18,940 --> 00:07:22,140
Please give some explanation
about how media can be

133
00:07:22,140 --> 00:07:25,816
broadcast using peer
connection.

134
00:07:25,816 --> 00:07:30,571
Are there any relays that
can be used with WebRTC?

135
00:07:30,571 --> 00:07:33,350
I think there's a couple of
questions inherent in this.

136
00:07:33,350 --> 00:07:34,600
SERGE LACHAPELLE: Justin, you
want to take that one?

137
00:07:34,600 --> 00:07:37,790

138
00:07:37,790 --> 00:07:39,070
JUSTIN UBERTI: Sure.

139
00:07:39,070 --> 00:07:46,390
So the basic idea of doing a
multi-party communication,

140
00:07:46,390 --> 00:07:50,450
there's a couple ways that
you can approach this.

141
00:07:50,450 --> 00:07:53,710
One way is that you could
create multiple peer

142
00:07:53,710 --> 00:07:57,870
connections, one to each
participant, and create what's

143
00:07:57,870 --> 00:07:59,300
called a mesh network.

144
00:07:59,300 --> 00:08:01,840
And for small conferences,
this can

145
00:08:01,840 --> 00:08:03,310
actually work pretty well.

146
00:08:03,310 --> 00:08:05,940
You basically send your video
and audio to every other

147
00:08:05,940 --> 00:08:08,750
participant, and they
do the same.

148
00:08:08,750 --> 00:08:12,000
But, as you probably have
noticed, as this gets to

149
00:08:12,000 --> 00:08:16,410
larger conferences, this
becomes less efficient.

150
00:08:16,410 --> 00:08:20,550
And so this is where the fact
that we're working with the

151
00:08:20,550 --> 00:08:25,250
ITF and using standard protocols
allows others to

152
00:08:25,250 --> 00:08:28,030
create what we call
middle boxes.

153
00:08:28,030 --> 00:08:32,280
Middle boxes can be conferencing
servers that can

154
00:08:32,280 --> 00:08:34,059
do various things like
a traditional--

155
00:08:34,059 --> 00:08:36,419
what they call an MCU.

156
00:08:36,419 --> 00:08:40,690
An MCU basically takes all the
incoming video feeds, in this

157
00:08:40,690 --> 00:08:43,669
case from each peer connection,
would composite

158
00:08:43,669 --> 00:08:47,020
them into a single image, and
then would send it back out

159
00:08:47,020 --> 00:08:49,910
as, basically, the
group video with

160
00:08:49,910 --> 00:08:52,010
everybody's picture and sound.

161
00:08:52,010 --> 00:08:56,820
And WebRTC doesn't provide this
technology per se, but

162
00:08:56,820 --> 00:08:58,860
you can create it using--

163
00:08:58,860 --> 00:09:03,070
there are various products
that exist in internet.

164
00:09:03,070 --> 00:09:06,910
Things like Asterisk, other
services that people are

165
00:09:06,910 --> 00:09:09,900
creating based on WebRTC that
will be able to ride this sort

166
00:09:09,900 --> 00:09:11,720
of functionality.

167
00:09:11,720 --> 00:09:15,960
And then secondly, instead of
also doing that sort of

168
00:09:15,960 --> 00:09:18,480
compositor, you can also
think of these

169
00:09:18,480 --> 00:09:20,260
things are simple relays.

170
00:09:20,260 --> 00:09:23,780
That, when the data comes in, it
gets sort of broadcast out

171
00:09:23,780 --> 00:09:25,190
to all participants.

172
00:09:25,190 --> 00:09:28,180
And, again, these are things
that you can create using

173
00:09:28,180 --> 00:09:31,650
standard RTP protocols
because that's what

174
00:09:31,650 --> 00:09:33,282
WebRTC is built upon.

175
00:09:33,282 --> 00:09:36,230

176
00:09:36,230 --> 00:09:38,210
SAM DUTTON: Thanks very much.

177
00:09:38,210 --> 00:09:40,182
One thing I'd like
to clear up--

178
00:09:40,182 --> 00:09:44,220
I guess I think when I was first
looking in WebRTC and

179
00:09:44,220 --> 00:09:47,510
trying to get my head around
it, there was some stuff

180
00:09:47,510 --> 00:09:50,330
relating to the different server
technologies that came

181
00:09:50,330 --> 00:09:53,040
up that was really new to
me as a web developer.

182
00:09:53,040 --> 00:09:55,670
And I was wondering if
one of you guys could

183
00:09:55,670 --> 00:09:56,610
talk us through that.

184
00:09:56,610 --> 00:09:59,860
So the three specific things I'm
talking about are-- well,

185
00:09:59,860 --> 00:10:04,370
the ICE Framework, and what that
consists of, and how TURN

186
00:10:04,370 --> 00:10:07,600
servers work, and what's a STUN
server, how does this

187
00:10:07,600 --> 00:10:08,380
stuff work?

188
00:10:08,380 --> 00:10:10,420
And why do we need it?

189
00:10:10,420 --> 00:10:11,630
And how does it fit?

190
00:10:11,630 --> 00:10:15,100
Where do I get one?

191
00:10:15,100 --> 00:10:18,780
JUSTIN UBERTI: OK, so, it
is a confusing area.

192
00:10:18,780 --> 00:10:21,060
In part it's because
the technology--

193
00:10:21,060 --> 00:10:23,490
and the names are kind
of overloaded.

194
00:10:23,490 --> 00:10:28,290
So when we talk about STUN, STUN
could be a mechanism for

195
00:10:28,290 --> 00:10:31,690
actually retrieving your IP
address as seen by the outside

196
00:10:31,690 --> 00:10:34,070
world from a STUN server.

197
00:10:34,070 --> 00:10:38,270
So it could also be the method
through which you do ICE.

198
00:10:38,270 --> 00:10:43,240
The type of connectivity check
message that you send from one

199
00:10:43,240 --> 00:10:46,170
side to the other are called
STUN messages.

200
00:10:46,170 --> 00:10:52,510
And recognizing this, the
authors of STUN have changed

201
00:10:52,510 --> 00:10:56,480
the acronym that STUN means
over time-- from being one

202
00:10:56,480 --> 00:10:58,730
specific thing now, it's
Session Traversal

203
00:10:58,730 --> 00:11:00,130
Utilities for Nat.

204
00:11:00,130 --> 00:11:02,040
It's kind of like a bag
of different tricks.

205
00:11:02,040 --> 00:11:05,080
Well anyway, so what does this
mean to the developer.

206
00:11:05,080 --> 00:11:10,090
Well, let's back up and look at
the fundamental part of the

207
00:11:10,090 --> 00:11:11,670
ice process.

208
00:11:11,670 --> 00:11:14,940
And Ice is Interactive
Connectivity Establishment.

209
00:11:14,940 --> 00:11:20,440
In a nutshell, what ICE involves
is that the client on

210
00:11:20,440 --> 00:11:24,590
either side will go and retrieve
as many IP addresses

211
00:11:24,590 --> 00:11:25,850
as they can find.

212
00:11:25,850 --> 00:11:29,290
Typically, this will be if the
local IP address, the IP

213
00:11:29,290 --> 00:11:32,990
address of its actual network
adapter, the STUN address,

214
00:11:32,990 --> 00:11:37,420
which is basically what the
outside world sees your IP

215
00:11:37,420 --> 00:11:38,910
addresses as being.

216
00:11:38,910 --> 00:11:41,430
You send a ping to a STUN
server, and the STUN server

217
00:11:41,430 --> 00:11:43,770
replies back with the IP
address that it saw

218
00:11:43,770 --> 00:11:45,500
that ping come from.

219
00:11:45,500 --> 00:11:47,710
And that gives you your
outside address.

220
00:11:47,710 --> 00:11:52,660
And then lastly, you can ask
TURN server, which is

221
00:11:52,660 --> 00:11:56,030
basically a network interface
in the cloud, if you will.

222
00:11:56,030 --> 00:11:59,290
And it's an IP address in the
cloud that you can kind of

223
00:11:59,290 --> 00:12:02,730
access and, in some cases,
this is the one you'll

224
00:12:02,730 --> 00:12:04,080
actually want to use.

225
00:12:04,080 --> 00:12:08,330
Now as I mentioned, each client
server retrieves these

226
00:12:08,330 --> 00:12:12,910
addresses, the STUN, the TURN,
and local address, and they

227
00:12:12,910 --> 00:12:17,090
send them to the other side and
then both sides basically

228
00:12:17,090 --> 00:12:20,790
send checks from their network
interfaces to these addresses

229
00:12:20,790 --> 00:12:23,110
they've been provided
with by a peer.

230
00:12:23,110 --> 00:12:25,820
And they figure out which ones
are actually usable for

231
00:12:25,820 --> 00:12:27,800
sending and receiving data.

232
00:12:27,800 --> 00:12:30,740
And whichever one ends up being
the one that works and

233
00:12:30,740 --> 00:12:32,560
is the most efficient is
the one that's actually

234
00:12:32,560 --> 00:12:33,820
used for the call.

235
00:12:33,820 --> 00:12:37,780
So looking back, the
terminology, ICE is the

236
00:12:37,780 --> 00:12:41,130
process through which these
checks are done.

237
00:12:41,130 --> 00:12:44,590
TURN is the actual server that
lives in the cloud that

238
00:12:44,590 --> 00:12:48,980
provides you with a sort of
IP address in the cloud.

239
00:12:48,980 --> 00:12:50,480
In cases where your
STUN address

240
00:12:50,480 --> 00:12:52,080
isn't immediately usable.

241
00:12:52,080 --> 00:12:54,590
And there some cases, depending
on your NAT behavior

242
00:12:54,590 --> 00:12:57,540
where the STUN address just
won't work for actual

243
00:12:57,540 --> 00:12:58,270
communication.

244
00:12:58,270 --> 00:13:04,380
And then STUN, is, in addition
to this sort of bag of

245
00:13:04,380 --> 00:13:08,360
utilities for making all this
stuff happen, it's the type of

246
00:13:08,360 --> 00:13:11,960
server that's used to discover
your NAT address, and it's the

247
00:13:11,960 --> 00:13:15,010
type of sort of
connectivity-check message

248
00:13:15,010 --> 00:13:17,470
that's sent from client
to client as

249
00:13:17,470 --> 00:13:19,760
part of the ICE process.

250
00:13:19,760 --> 00:13:22,190
Does that all make sense?

251
00:13:22,190 --> 00:13:24,330
SAM DUTTON: Yeah, thank
you, thank you.

252
00:13:24,330 --> 00:13:27,890
Serge, I think you've got
a nice diagram up there.

253
00:13:27,890 --> 00:13:29,200
Should we go over to that?

254
00:13:29,200 --> 00:13:32,630

255
00:13:32,630 --> 00:13:34,580
JUSTIN UBERTI: Ah yeah, that's
a great diagram.

256
00:13:34,580 --> 00:13:38,310
SAM DUTTON: Yeah,
can we see this.

257
00:13:38,310 --> 00:13:43,655
So yeah, but maybe we could just
talk through that briefly

258
00:13:43,655 --> 00:13:45,760
and see what's there?

259
00:13:45,760 --> 00:13:47,460
JUSTIN UBERTI: So right, I mean
this is a great diagram.

260
00:13:47,460 --> 00:13:50,510
It shows two peers, each
behind a NAT device.

261
00:13:50,510 --> 00:13:58,720

262
00:13:58,720 --> 00:13:59,520
SERGE LACHAPELLE: Oops,
Justin, I think

263
00:13:59,520 --> 00:14:00,770
you got muted, sorry.

264
00:14:00,770 --> 00:14:03,650

265
00:14:03,650 --> 00:14:04,470
JUSTIN UBERTI: Sorry.

266
00:14:04,470 --> 00:14:07,615
OK, as I was saying, so we
have two peers here each

267
00:14:07,615 --> 00:14:09,020
behind NAT.

268
00:14:09,020 --> 00:14:12,330
And then the relay server, which
is also known as the

269
00:14:12,330 --> 00:14:15,020
TURN server, typically,
and STUN server.

270
00:14:15,020 --> 00:14:19,240
And the peer contacts the STUN
server can learn the address

271
00:14:19,240 --> 00:14:20,870
of its NAT.

272
00:14:20,870 --> 00:14:21,530
[INAUDIBLE]

273
00:14:21,530 --> 00:14:25,890
TURN server can learn the
IP address in the cloud.

274
00:14:25,890 --> 00:14:30,080
And then it shares those
addresses with remote peer

275
00:14:30,080 --> 00:14:32,020
through the cloud.

276
00:14:32,020 --> 00:14:34,750
And then they perform the
connectivity checks.

277
00:14:34,750 --> 00:14:36,640
That part isn't shown here.

278
00:14:36,640 --> 00:14:39,370
But basically, we could figure
out what pathway the media can

279
00:14:39,370 --> 00:14:40,790
actually take.

280
00:14:40,790 --> 00:14:46,470
And for most consumer NATs,
it'll be the STUN address.

281
00:14:46,470 --> 00:14:49,920
Because the NAT basically says
that the address learned from

282
00:14:49,920 --> 00:14:53,390
the STUN server can also be
used for communication.

283
00:14:53,390 --> 00:14:57,320
On some enterprise-grade NATs,
the rules are a little

284
00:14:57,320 --> 00:15:01,290
different, that the address
learned from the STUN server

285
00:15:01,290 --> 00:15:03,070
can't actually be used
for communication

286
00:15:03,070 --> 00:15:04,100
with a remote peer.

287
00:15:04,100 --> 00:15:07,810
And in these cases, at least one
side will need to use the

288
00:15:07,810 --> 00:15:09,710
relay server in order
to get the media

289
00:15:09,710 --> 00:15:12,830
from one side to another.

290
00:15:12,830 --> 00:15:14,080
SERGE LACHAPELLE: Great.

291
00:15:14,080 --> 00:15:16,260

292
00:15:16,260 --> 00:15:17,110
SAM DUTTON: That's brilliant.

293
00:15:17,110 --> 00:15:21,620
I guess they way I understand
it, just correct me if this is

294
00:15:21,620 --> 00:15:25,670
wrong, so the understanding I
have is that when you're using

295
00:15:25,670 --> 00:15:30,190
WebRTC, essentially, the
framework will attempt to make

296
00:15:30,190 --> 00:15:34,580
a direct connection between the
peers and if that fails

297
00:15:34,580 --> 00:15:37,150
will revert to using
a relay server.

298
00:15:37,150 --> 00:15:39,430
That's probably a gross
simplification but is that

299
00:15:39,430 --> 00:15:42,490
something like what's
happening here.

300
00:15:42,490 --> 00:15:44,580
JUSTIN UBERTI: Yeah, that's
exactly what going on.

301
00:15:44,580 --> 00:15:47,870
I would say it's a little bit
more than that because rather

302
00:15:47,870 --> 00:15:50,940
than have to sort of try one
thing, and then only fall back

303
00:15:50,940 --> 00:15:54,550
and use the other thing if it
fails, and have a delay

304
00:15:54,550 --> 00:15:57,320
associated with that, we're
kind of trying all these

305
00:15:57,320 --> 00:15:58,870
things in parallel.

306
00:15:58,870 --> 00:16:02,640
And that may mean that we use
the relay connection first,

307
00:16:02,640 --> 00:16:06,040
and then we maybe find out later
that another connection

308
00:16:06,040 --> 00:16:06,770
is actually better.

309
00:16:06,770 --> 00:16:09,950
And in a case like that, we can
get the call running as

310
00:16:09,950 --> 00:16:12,840
soon as possible on the first
connection we have and then

311
00:16:12,840 --> 00:16:17,310
maybe transition to a more
efficient connection type as

312
00:16:17,310 --> 00:16:20,590
the actual ICE process
proceeds.

313
00:16:20,590 --> 00:16:22,440
SAM DUTTON: Gotcha, so it's not
just about connectivity.

314
00:16:22,440 --> 00:16:23,400
It's about efficient

315
00:16:23,400 --> 00:16:27,710
connectivity and data transfer.

316
00:16:27,710 --> 00:16:30,710
OK, I'm just going to go over to
the questions again because

317
00:16:30,710 --> 00:16:33,680
we've got a stack of
good ones here.

318
00:16:33,680 --> 00:16:36,300
So yeah, this is a question a
lot of developers are asking.

319
00:16:36,300 --> 00:16:40,400
From Fred in [INAUDIBLE] in
Germany, "When will data

320
00:16:40,400 --> 00:16:43,590
connections be available for
developers." So I guess

321
00:16:43,590 --> 00:16:45,600
thinking here about
data channels.

322
00:16:45,600 --> 00:16:48,910
SERGE LACHAPELLE: So I
can answer that one.

323
00:16:48,910 --> 00:16:52,250
We've posted our roadmap
on the Chromium blog.

324
00:16:52,250 --> 00:16:57,510
So if you search on the Chromium
blog and for WebRTC,

325
00:16:57,510 --> 00:16:58,530
you'll find it there.

326
00:16:58,530 --> 00:17:05,430
Basically we first want to go
into Chrome stable with just

327
00:17:05,430 --> 00:17:06,750
audio and video.

328
00:17:06,750 --> 00:17:09,690
And once that's working well,
we'll start cranking on the

329
00:17:09,690 --> 00:17:11,650
data channel thing.

330
00:17:11,650 --> 00:17:15,359
So it's just a question of
having to focus and prioritize

331
00:17:15,359 --> 00:17:17,319
things properly.

332
00:17:17,319 --> 00:17:20,220
And so we decided to go with
audio and video first.

333
00:17:20,220 --> 00:17:24,420
And right after that, once
you've seen audio and video go

334
00:17:24,420 --> 00:17:28,490
from behind a flag into the
public Chrome, that's a good

335
00:17:28,490 --> 00:17:30,020
signal that we're starting
to work on the

336
00:17:30,020 --> 00:17:32,140
data channel stuff.

337
00:17:32,140 --> 00:17:34,510
SAM DUTTON: Cool, cool It's
incredibly powerful.

338
00:17:34,510 --> 00:17:37,330
I don't know who'd like to
just talk this through.

339
00:17:37,330 --> 00:17:40,860
But data channel is going to
be a whole other set of

340
00:17:40,860 --> 00:17:45,540
possibilities for all kinds
of applications.

341
00:17:45,540 --> 00:17:48,150
JUSTIN UBERTI: Oh absolutely,
it basically changes any web

342
00:17:48,150 --> 00:17:51,450
application into a peer-to-peer
application.

343
00:17:51,450 --> 00:17:56,680
And by providing great tools
built in-- we'll have support

344
00:17:56,680 --> 00:17:59,130
for unreliable and
reliable data and

345
00:17:59,130 --> 00:18:01,630
things like flow control--

346
00:18:01,630 --> 00:18:05,510
we basically solve a lot of
the problems that P2P apps

347
00:18:05,510 --> 00:18:07,720
right now have to solve
themselves.

348
00:18:07,720 --> 00:18:11,470
So the bag of tools that we're
going to be providing web

349
00:18:11,470 --> 00:18:15,450
developers in a really
easy-to-use package, I think

350
00:18:15,450 --> 00:18:17,330
is just going to be very
transformative.

351
00:18:17,330 --> 00:18:19,660
There's all sorts of
applications that need to send

352
00:18:19,660 --> 00:18:24,200
a lot of data, or send data
with very low latency.

353
00:18:24,200 --> 00:18:27,175
And what they'll be able to
do with this API should be

354
00:18:27,175 --> 00:18:29,270
incredible.

355
00:18:29,270 --> 00:18:30,840
SAM DUTTON: One of the questions
I've had personally

356
00:18:30,840 --> 00:18:34,530
is people asking, what's the
relationship between web

357
00:18:34,530 --> 00:18:37,070
sockets and so WebRTC.

358
00:18:37,070 --> 00:18:39,930
Are these two technologies
doing the same thing or

359
00:18:39,930 --> 00:18:41,876
something different?

360
00:18:41,876 --> 00:18:44,950
JUSTIN UBERTI: Well, they're
slightly different, but

361
00:18:44,950 --> 00:18:47,890
conceptually they're
kind of the same.

362
00:18:47,890 --> 00:18:51,770
They're a pipe that you want
to be able to send data to

363
00:18:51,770 --> 00:18:54,770
somebody else in any format.

364
00:18:54,770 --> 00:18:58,310
And so a web socket will
transmit a server, because

365
00:18:58,310 --> 00:19:02,730
it's done over HTTP and goes
to a web server, whereas a

366
00:19:02,730 --> 00:19:05,440
data channel will go
directly to a peer.

367
00:19:05,440 --> 00:19:10,100
Now those kind of differences
don't really affect the

368
00:19:10,100 --> 00:19:12,960
overall architecture of
how you can send data.

369
00:19:12,960 --> 00:19:16,280
And so what we've done is we've
created an API for the

370
00:19:16,280 --> 00:19:20,580
data channel that matches what
the web socket API is

371
00:19:20,580 --> 00:19:21,750
syntactically.

372
00:19:21,750 --> 00:19:24,072
And so if you have an
application that's written to

373
00:19:24,072 --> 00:19:27,120
use web sockets, you should be
able to transition it to use

374
00:19:27,120 --> 00:19:30,870
data channels extremely easily
because we've tried to keep

375
00:19:30,870 --> 00:19:33,830
that difference as small
as possible.

376
00:19:33,830 --> 00:19:36,820
And in most cases, the syntax
should be identical.

377
00:19:36,820 --> 00:19:40,420
But the real difference is that
a web socket is always

378
00:19:40,420 --> 00:19:43,450
reliable, there's no support
for unreliable data, and it

379
00:19:43,450 --> 00:19:46,088
always goes to a server.

380
00:19:46,088 --> 00:19:50,190
A data channel will always will
go to a peer, although

381
00:19:50,190 --> 00:19:51,790
the peer could be a server.

382
00:19:51,790 --> 00:19:53,850
You could also talk to a server
if you wanted to send

383
00:19:53,850 --> 00:19:56,000
unreliable data to a server.

384
00:19:56,000 --> 00:19:59,030
But it has a lot more
flexibility in terms of what

385
00:19:59,030 --> 00:20:02,000
the actual communication
protocol should be because

386
00:20:02,000 --> 00:20:06,008
we're not having to constrain
ourselves to HTTP.

387
00:20:06,008 --> 00:20:08,390
SAM DUTTON: OK, thanks
for that.

388
00:20:08,390 --> 00:20:15,540
Just going over to a very
specific question on the

389
00:20:15,540 --> 00:20:20,000
Moderator questions here
from Lorenzo Minero.

390
00:20:20,000 --> 00:20:22,630
He's asking, "Are you going
to add a way to specify

391
00:20:22,630 --> 00:20:26,060
resolution and frame rate
for an outgoing stream?

392
00:20:26,060 --> 00:20:28,830
Would this is the media stream
property or something that

393
00:20:28,830 --> 00:20:32,330
would need to be adjusted
to via JSEP?"

394
00:20:32,330 --> 00:20:36,070
Just before we go into that,
maybe a little quick

395
00:20:36,070 --> 00:20:39,310
explanation about JSEP.

396
00:20:39,310 --> 00:20:45,030
Now, what people may have seen
was the original WebKit peer

397
00:20:45,030 --> 00:20:49,520
connection object, which has
become WebKit deprecated peer

398
00:20:49,520 --> 00:20:49,990
connection.

399
00:20:49,990 --> 00:20:54,420
Now, the idea of this is that
the original implementation

400
00:20:54,420 --> 00:20:58,980
pre-JSEP, the demos that used
that stuff and applications

401
00:20:58,980 --> 00:21:02,330
could still use that format.

402
00:21:02,330 --> 00:21:07,130
And now, as we move on to JSEP
implementations before full

403
00:21:07,130 --> 00:21:13,140
standardization, that we can
call those by a different

404
00:21:13,140 --> 00:21:16,640
name-- peer connection, 00,
something like that.

405
00:21:16,640 --> 00:21:19,660
Maybe Justin would like to just
tell us a little bit more

406
00:21:19,660 --> 00:21:21,070
about that, or maybe
for Tommy.

407
00:21:21,070 --> 00:21:23,730

408
00:21:23,730 --> 00:21:24,350
TOM: So--

409
00:21:24,350 --> 00:21:27,570
and if you are really
interested this.

410
00:21:27,570 --> 00:21:31,620
If you look at the latest
editor's draft of the peer

411
00:21:31,620 --> 00:21:37,090
connection standard, you'll
see that we have objects

412
00:21:37,090 --> 00:21:39,330
called media constraints.

413
00:21:39,330 --> 00:21:40,890
That's not the final name.

414
00:21:40,890 --> 00:21:46,370
But they will contain
constraints that are either

415
00:21:46,370 --> 00:21:49,020
optional or mandatory.

416
00:21:49,020 --> 00:21:54,110
So you can say that, I want a
video at at least 320 pixels.

417
00:21:54,110 --> 00:22:00,210
But I they really want to
have 640-wide video.

418
00:22:00,210 --> 00:22:01,530
And that can be--

419
00:22:01,530 --> 00:22:04,230
those kind of specifications can
be added when you create

420
00:22:04,230 --> 00:22:08,330
the peer connection, but also
when you create your own

421
00:22:08,330 --> 00:22:11,090
answer or create your offer.

422
00:22:11,090 --> 00:22:15,220
And also when you add your
stream to the peer connection.

423
00:22:15,220 --> 00:22:18,040
So yes. there will be complete
configurability for this.

424
00:22:18,040 --> 00:22:21,010

425
00:22:21,010 --> 00:22:23,500
SAM DUTTON: Great,
thanks very much.

426
00:22:23,500 --> 00:22:25,080
Interesting stuff.

427
00:22:25,080 --> 00:22:27,490
A couple of questions
from that Ted at

428
00:22:27,490 --> 00:22:31,290
Cloudeo based in Poland.

429
00:22:31,290 --> 00:22:33,870
I guess that's Poland, Poland.

430
00:22:33,870 --> 00:22:35,550
But a couple of good
questions.

431
00:22:35,550 --> 00:22:40,800
Firstly asking, "Do you plan to
add an ability to transmit

432
00:22:40,800 --> 00:22:44,960
multiple streams using a
single VPN connection?

433
00:22:44,960 --> 00:22:47,350
I'm thinking about a
conferencing server built

434
00:22:47,350 --> 00:22:52,910
using WebRTC library that will
use single peer connection per

435
00:22:52,910 --> 00:22:55,637
participant." Who would
like to take that?

436
00:22:55,637 --> 00:22:58,930

437
00:22:58,930 --> 00:23:00,260
JUSTIN UBERTI: I can
speak to that one.

438
00:23:00,260 --> 00:23:02,770

439
00:23:02,770 --> 00:23:07,040
We've got the addstream API,
where you can basically add a

440
00:23:07,040 --> 00:23:08,390
stream to a peer connection.

441
00:23:08,390 --> 00:23:11,820
But there is obviously no reason
why you couldn't add

442
00:23:11,820 --> 00:23:13,070
more than one stream.

443
00:23:13,070 --> 00:23:17,315
And especially on the remote
side, you could have the

444
00:23:17,315 --> 00:23:19,200
remote side, if you have some
conferencing server, add

445
00:23:19,200 --> 00:23:22,060
multiple streams to your
incoming peer connection.

446
00:23:22,060 --> 00:23:25,380
And you'd be notified as to
each one of these streams.

447
00:23:25,380 --> 00:23:32,800
And the mechanism for which this
is done is we're thinking

448
00:23:32,800 --> 00:23:36,350
that within a given RTP session
that's on a peer

449
00:23:36,350 --> 00:23:42,110
connection, you can have what
we call multiple SSRC And an

450
00:23:42,110 --> 00:23:45,010
SSRC corresponds to a
media stream track.

451
00:23:45,010 --> 00:23:48,400
And then tracks, as you know,
go into a media stream.

452
00:23:48,400 --> 00:23:53,600
And so you could imagine in a
multi-user conference you

453
00:23:53,600 --> 00:23:57,740
could end up getting multiple
media streams, and then

454
00:23:57,740 --> 00:23:59,770
basically each meda stream
would correspond to a

455
00:23:59,770 --> 00:24:01,290
participant.

456
00:24:01,290 --> 00:24:04,480
And then each stream would have
a track for audio and a

457
00:24:04,480 --> 00:24:07,248
track for video for each
participant's audio and video.

458
00:24:07,248 --> 00:24:11,890

459
00:24:11,890 --> 00:24:14,030
SAM DUTTON: Thanks very much,
that's interesting stuff.

460
00:24:14,030 --> 00:24:18,395
Another question from the
moderator stream that we're

461
00:24:18,395 --> 00:24:19,440
getting here.

462
00:24:19,440 --> 00:24:21,960
This is from the Dimitri
in Moscow.

463
00:24:21,960 --> 00:24:26,810
The question is, "We need a way
to save and send recorded

464
00:24:26,810 --> 00:24:30,250
video and audio via media
stream record, which was

465
00:24:30,250 --> 00:24:33,100
announced on Google I/O 2012.

466
00:24:33,100 --> 00:24:35,440
When will appear in Chrome?"

467
00:24:35,440 --> 00:24:39,840
Before we answer that, just one
thing I'd like to-- just a

468
00:24:39,840 --> 00:24:42,940
warning, really, that people may
have seen on the web blog

469
00:24:42,940 --> 00:24:49,680
posts talking about platforms
that implement WebRTC, where

470
00:24:49,680 --> 00:24:52,820
in fact the platforms have
actually only implemented

471
00:24:52,820 --> 00:24:55,080
getUserMedia.

472
00:24:55,080 --> 00:24:59,880
There's, of course, more to
WebRTC than just getUserMedia.

473
00:24:59,880 --> 00:25:02,170
There's the whole,
actual real-time

474
00:25:02,170 --> 00:25:04,000
communication part of it.

475
00:25:04,000 --> 00:25:07,550
But going back to the question,
maybe Serge, if you

476
00:25:07,550 --> 00:25:08,800
could take this one.

477
00:25:08,800 --> 00:25:11,750

478
00:25:11,750 --> 00:25:12,080
SERGE LACHAPELLE: Sure.

479
00:25:12,080 --> 00:25:15,490
There's been a ton of requests
for being able to record media

480
00:25:15,490 --> 00:25:17,490
locally from the browser.

481
00:25:17,490 --> 00:25:22,770
And unfortunately, the API for
media recording isn't fully

482
00:25:22,770 --> 00:25:23,910
baked right now.

483
00:25:23,910 --> 00:25:27,230
So we're kind of taking a step
back and letting the standards

484
00:25:27,230 --> 00:25:30,180
process do its thing.

485
00:25:30,180 --> 00:25:35,300
And when there's a stable draft,
we will start working

486
00:25:35,300 --> 00:25:36,710
on implementing that.

487
00:25:36,710 --> 00:25:41,100
Right now we'll be focusing on
real-time audio and video

488
00:25:41,100 --> 00:25:43,306
going forward.

489
00:25:43,306 --> 00:25:44,570
SAM DUTTON: OK, thanks
very much.

490
00:25:44,570 --> 00:25:48,760
Another question that we've had
from a lot of developers.

491
00:25:48,760 --> 00:25:52,650
Going over to [? Hersian ?]
from Hazara in Pakistan.

492
00:25:52,650 --> 00:25:56,437
"Is there any possibility for
audio-only communication among

493
00:25:56,437 --> 00:25:58,030
peers in future.

494
00:25:58,030 --> 00:26:01,920
That is audio tag can understand
remote streams and

495
00:26:01,920 --> 00:26:05,370
generated blogs." And I
think I'll give this

496
00:26:05,370 --> 00:26:10,340
to Malanet, I think.

497
00:26:10,340 --> 00:26:11,760
MALANET: Yeah.

498
00:26:11,760 --> 00:26:13,390
I think that that's definitely
possible.

499
00:26:13,390 --> 00:26:16,300
I mean, you can have
it [INAUDIBLE]

500
00:26:16,300 --> 00:26:18,320
[? spend ?] having this
[? article. ?]

501
00:26:18,320 --> 00:26:21,570
And right now we aren't
implementing that tag, but we

502
00:26:21,570 --> 00:26:23,710
are in the process of
implementing a tag according

503
00:26:23,710 --> 00:26:24,960
to that feature.

504
00:26:24,960 --> 00:26:28,230

505
00:26:28,230 --> 00:26:30,850
SAM DUTTON: OK, thanks
very much.

506
00:26:30,850 --> 00:26:34,200
Another question from
Ted at Cloudeo.

507
00:26:34,200 --> 00:26:36,750
He's asking about HTTP
streaming fallback.

508
00:26:36,750 --> 00:26:43,060
The IETF WebRTC use cases and
requirements doc has NF37

509
00:26:43,060 --> 00:26:46,470
requirements stating that the
browser must be able to stream

510
00:26:46,470 --> 00:26:49,200
data using HTTP.

511
00:26:49,200 --> 00:26:53,440
Any idea on how you plan
to achieve this?

512
00:26:53,440 --> 00:26:57,550
JUSTIN UBERTI: So I'll
take this one.

513
00:26:57,550 --> 00:27:01,580
There are a bunch of techniques
that apps today use

514
00:27:01,580 --> 00:27:08,430
to work over HTTP because most
of our communication apps we

515
00:27:08,430 --> 00:27:11,420
run in environments where the
firewalls basically knock down

516
00:27:11,420 --> 00:27:13,390
everything except HTTP.

517
00:27:13,390 --> 00:27:14,500
And we still need to work.

518
00:27:14,500 --> 00:27:17,010
And so WebRTC needs to work
in this scenario too.

519
00:27:17,010 --> 00:27:21,500
And there are a bunch of tricks
that can be done to

520
00:27:21,500 --> 00:27:22,240
accomplish this.

521
00:27:22,240 --> 00:27:25,630
I won't go into all the details,
but one easy one is

522
00:27:25,630 --> 00:27:30,630
to do HTTP Connect, which is
kind of the way that SSL is

523
00:27:30,630 --> 00:27:33,550
used to connect through
an HTTP proxy.

524
00:27:33,550 --> 00:27:40,050
And basically, an SLL
connection, the data is opaque

525
00:27:40,050 --> 00:27:43,010
to the proxy or opaque to
whatever's making this

526
00:27:43,010 --> 00:27:43,870
connection.

527
00:27:43,870 --> 00:27:49,950
And so if we send our data and
make it look HTTPS then,

528
00:27:49,950 --> 00:27:52,020
basically, we can go
through proxies.

529
00:27:52,020 --> 00:27:54,940
We can go through things that
are restricting to HTTP and

530
00:27:54,940 --> 00:27:56,260
HTTPS only.

531
00:27:56,260 --> 00:28:01,630
And this is obviously a very
important part of making sure

532
00:28:01,630 --> 00:28:03,360
WebRTC can work everywhere.

533
00:28:03,360 --> 00:28:07,750
And servers, turn servers and
such, will need to sort of be

534
00:28:07,750 --> 00:28:10,110
aware, when you're making
extensions to the

535
00:28:10,110 --> 00:28:14,455
specifications, to deal with
being able to allocate ports

536
00:28:14,455 --> 00:28:17,320
and stuff like that over
HTTPS instead of over

537
00:28:17,320 --> 00:28:18,980
just vanilla TCP.

538
00:28:18,980 --> 00:28:22,300
But like I said, it's already
in use today in various

539
00:28:22,300 --> 00:28:26,910
products, and it'll definitely
find its way into WebRTC.

540
00:28:26,910 --> 00:28:29,106
SAM DUTTON: Cool, cool,
thanks so much.

541
00:28:29,106 --> 00:28:32,020
We've got a question about
protocols, actually, but this

542
00:28:32,020 --> 00:28:35,820
raise, to my mind, it's a big
question about the way

543
00:28:35,820 --> 00:28:38,250
signaling works with WebRTC.

544
00:28:38,250 --> 00:28:43,950
And one thing about WebRTC is
that so it doesn't make

545
00:28:43,950 --> 00:28:46,840
specifications for
signaling methods

546
00:28:46,840 --> 00:28:48,500
or signaling protocols.

547
00:28:48,500 --> 00:28:54,320
And as I understand it, the kind
of name this architecture

548
00:28:54,320 --> 00:28:57,830
has been called JSEP.

549
00:28:57,830 --> 00:29:01,650
And I'm just wondering if is one
of the people we're with

550
00:29:01,650 --> 00:29:04,210
there could just give us a
little bit more detail.

551
00:29:04,210 --> 00:29:06,240
What is this JSEP thing?

552
00:29:06,240 --> 00:29:13,250
And what was the design process
that led to that.

553
00:29:13,250 --> 00:29:17,190
So some talk about protocols,
signaling, and the

554
00:29:17,190 --> 00:29:17,880
methods we can use.

555
00:29:17,880 --> 00:29:23,300
Because I've seen different
approaches using XHR, and the

556
00:29:23,300 --> 00:29:25,290
channel API Google,
or with websites.

557
00:29:25,290 --> 00:29:29,310
So yeah, maybe Serge could
kick this off.

558
00:29:29,310 --> 00:29:32,995
SERGE LACHAPELLE: So JSEP
means JavaScript--

559
00:29:32,995 --> 00:29:36,010
God, I always forget the E.

560
00:29:36,010 --> 00:29:36,770
JUSTIN UBERTI: Establishment.

561
00:29:36,770 --> 00:29:38,290
SERGE LACHAPELLE: Establishment,
thank you.

562
00:29:38,290 --> 00:29:40,060
JavaScript Establishment
Protocol.

563
00:29:40,060 --> 00:29:50,360
And it reuses the strength
of the browser.

564
00:29:50,360 --> 00:29:53,330
Browsers are great at
communicating over HTTP.

565
00:29:53,330 --> 00:29:59,730
And so JSEP reuses that channel
for all its signaling

566
00:29:59,730 --> 00:30:06,960
and what JSEP gives us are a
low-level API that allows us

567
00:30:06,960 --> 00:30:10,100
to then encapsulate other
protocols on it.

568
00:30:10,100 --> 00:30:12,440
So it's really protocol-neutral.

569
00:30:12,440 --> 00:30:17,700
And so we think that JSEP
strikes a good balance for web

570
00:30:17,700 --> 00:30:21,870
developers that want to get up
and running quickly, and more

571
00:30:21,870 --> 00:30:25,410
advanced developers that might
want to encapsulate other

572
00:30:25,410 --> 00:30:28,570
established voice-over-IP
protocols or create their own

573
00:30:28,570 --> 00:30:30,370
more advanced protocols.

574
00:30:30,370 --> 00:30:35,560
So it's really a lower-level
API that allows you to

575
00:30:35,560 --> 00:30:38,780
encapsulate other protocols.

576
00:30:38,780 --> 00:30:40,350
JUSTIN UBERTI: And we're seeing
people do great stuff

577
00:30:40,350 --> 00:30:42,600
with this already.

578
00:30:42,600 --> 00:30:45,480
People already have SIP
in the browser.

579
00:30:45,480 --> 00:30:47,280
It's something called SIPML5.

580
00:30:47,280 --> 00:30:49,900

581
00:30:49,900 --> 00:30:56,250
By taking the JSEP API and
converting it into SIP.

582
00:30:56,250 --> 00:30:59,650
And we've already seen other
things where the API can be

583
00:30:59,650 --> 00:31:01,840
converted into XMTP.

584
00:31:01,840 --> 00:31:06,040
The whole idea behind JSEP is
to not bake the signalling

585
00:31:06,040 --> 00:31:07,440
protocol in the browser.

586
00:31:07,440 --> 00:31:10,410
So that applications can use
whatever they need, whether

587
00:31:10,410 --> 00:31:12,800
it's SIP, whether it's XMTP,
whether it's something custom

588
00:31:12,800 --> 00:31:17,230
to the application, and not
constrained by the API.

589
00:31:17,230 --> 00:31:19,730
And so far we're seeing
that work out

590
00:31:19,730 --> 00:31:22,610
exactly as we had intended.

591
00:31:22,610 --> 00:31:23,440
SAM DUTTON: Cool, OK, thanks.

592
00:31:23,440 --> 00:31:26,220
I just realized we've got about
three minutes to go.

593
00:31:26,220 --> 00:31:30,080
So another couple of
quick questions.

594
00:31:30,080 --> 00:31:33,051
Again, something I've heard from
developers, from Matt in

595
00:31:33,051 --> 00:31:35,390
the United States-- "How
is security handled?

596
00:31:35,390 --> 00:31:38,080
Could chat sessions be
intercepted or accessed by

597
00:31:38,080 --> 00:31:45,140
third parties?" Maybe, Serge?

598
00:31:45,140 --> 00:31:48,450
SERGE LACHAPELLE: Well, we've
taken the opportunity, when

599
00:31:48,450 --> 00:31:55,640
designing and proposing this API
and the protocols, to make

600
00:31:55,640 --> 00:31:57,270
sure that encryption
was turned on

601
00:31:57,270 --> 00:31:59,100
from the very beginning.

602
00:31:59,100 --> 00:32:04,390
So encryption for communication
peer-to-pere is

603
00:32:04,390 --> 00:32:05,900
not an option.

604
00:32:05,900 --> 00:32:07,590
It's on by default.

605
00:32:07,590 --> 00:32:14,940
And so right now, at the ITF
there are discussions on what

606
00:32:14,940 --> 00:32:16,790
types of encryption
and what types of

607
00:32:16,790 --> 00:32:18,470
authentication to use.

608
00:32:18,470 --> 00:32:22,440
But I think there's strong
sentiment to have encryption

609
00:32:22,440 --> 00:32:24,590
be on from the start.

610
00:32:24,590 --> 00:32:29,570
Maybe Justin can fill in where
our implementation is in

611
00:32:29,570 --> 00:32:31,550
regards to encryption today.

612
00:32:31,550 --> 00:32:35,700
JUSTIN UBERTI: Right, so we
support SRTP, which is a

613
00:32:35,700 --> 00:32:38,990
secure RTP in our current
implementation right now.

614
00:32:38,990 --> 00:32:42,590
And as Serge mentioned, that's
going to be the standard it's

615
00:32:42,590 --> 00:32:46,065
been required for
implementations of WebRTC.

616
00:32:46,065 --> 00:32:51,610
And that uses AES and
SHA1, really, it's

617
00:32:51,610 --> 00:32:53,870
state-of-the-art security.

618
00:32:53,870 --> 00:32:58,340
And we're also looking at
doing something a step

619
00:32:58,340 --> 00:33:02,600
further, which is something
called DTLS SRTP, which uses

620
00:33:02,600 --> 00:33:06,650
the datagram TMS protocol to
set up the keys for SRTP,

621
00:33:06,650 --> 00:33:10,500
which makes it a lot harder
for any sort of man in the

622
00:33:10,500 --> 00:33:15,450
middle or anything like
that to be able to

623
00:33:15,450 --> 00:33:16,430
interface to the keys.

624
00:33:16,430 --> 00:33:17,960
Because the keys are,
basically, only

625
00:33:17,960 --> 00:33:19,920
know by either side.

626
00:33:19,920 --> 00:33:23,790
And it provides a little bit
more traditional guarantee

627
00:33:23,790 --> 00:33:26,770
that, not only is the media
secure, but that the keying

628
00:33:26,770 --> 00:33:31,330
and everything like that has
been done in a form that's

629
00:33:31,330 --> 00:33:32,580
future-safe.

630
00:33:32,580 --> 00:33:34,660

631
00:33:34,660 --> 00:33:36,160
SAM DUTTON: Cool, OK.

632
00:33:36,160 --> 00:33:39,440
And another question we've,
again, had from a lot of

633
00:33:39,440 --> 00:33:44,960
developers is just wondering
when we might see WebRTC

634
00:33:44,960 --> 00:33:49,250
implemented in Chrome
for Android.

635
00:33:49,250 --> 00:33:51,620
SERGE LACHAPELLE: Android, and
mobiles in general, are

636
00:33:51,620 --> 00:33:53,650
extremely interesting for us.

637
00:33:53,650 --> 00:34:00,320
As a team, we've decided to
iterate on the API spec and

638
00:34:00,320 --> 00:34:07,020
help the API get to 1.0 version
using the desktop.

639
00:34:07,020 --> 00:34:08,730
So that's really been how we've

640
00:34:08,730 --> 00:34:10,170
been executing currently.

641
00:34:10,170 --> 00:34:13,270
We've been working on the
desktop to be sure that we can

642
00:34:13,270 --> 00:34:17,699
provide good strong feedback
to the W3C and the ITF.

643
00:34:17,699 --> 00:34:25,400
Now once we come out from behind
the flag, and the API

644
00:34:25,400 --> 00:34:27,810
has reached a stable state,
we're going to start cranking

645
00:34:27,810 --> 00:34:28,980
on mobile as well.

646
00:34:28,980 --> 00:34:32,449
So if you look at the
code.webrtc.com, you'll see

647
00:34:32,449 --> 00:34:34,389
there's a lot of mobile
components

648
00:34:34,389 --> 00:34:37,170
that are there already.

649
00:34:37,170 --> 00:34:42,159
We'll just need to package it
all in into nice WebRTC for

650
00:34:42,159 --> 00:34:44,520
the Chrome browser on Android.

651
00:34:44,520 --> 00:34:46,659
But first, desktop.

652
00:34:46,659 --> 00:34:49,370
SAM DUTTON: Yeah, and that
brings me to my final question

653
00:34:49,370 --> 00:34:51,470
actually, which again
there's a few of

654
00:34:51,470 --> 00:34:54,739
these on the Moderator.

655
00:34:54,739 --> 00:34:57,450
If we could just have an
overview of where we are now

656
00:34:57,450 --> 00:35:03,660
with implementation on the
desktop in Chrome.

657
00:35:03,660 --> 00:35:06,660
SERGE LACHAPELLE: So you
probably saw, a blog post

658
00:35:06,660 --> 00:35:09,560
recently about getUserMedia.

659
00:35:09,560 --> 00:35:13,510
And so that's the ability to
access basic webcam and

660
00:35:13,510 --> 00:35:16,210
microphone from the browser.

661
00:35:16,210 --> 00:35:19,510
And that's going
into Chrome 21.

662
00:35:19,510 --> 00:35:23,600
In Chrome 22, we're going to
add the ability to remember

663
00:35:23,600 --> 00:35:25,570
decisions for secure websites.

664
00:35:25,570 --> 00:35:29,870
So if you're on an HTTPS
website, you'll be able to

665
00:35:29,870 --> 00:35:33,970
always allow certain websites
to use the camera and

666
00:35:33,970 --> 00:35:34,590
microphone.

667
00:35:34,590 --> 00:35:39,560
And this is going to make many
web app developers very happy.

668
00:35:39,560 --> 00:35:43,000
So then we won't have to press
the allow buttom all the time.

669
00:35:43,000 --> 00:35:49,000
Post that, we've just gotten
a new draft from the W3C

670
00:35:49,000 --> 00:35:51,700
specifying the WebRTC API.

671
00:35:51,700 --> 00:35:56,310
We think that this draft is good
enough now to implement,

672
00:35:56,310 --> 00:35:59,970
and modify our implementation
a little bit, and try to get

673
00:35:59,970 --> 00:36:01,500
that from behind a the flag.

674
00:36:01,500 --> 00:36:05,900
I don't know exactly where on
the Chrome releases we're

675
00:36:05,900 --> 00:36:09,790
going to end up, but fairly soon
we're going to be coming

676
00:36:09,790 --> 00:36:12,850
out from behind the flag.

677
00:36:12,850 --> 00:36:14,630
SAM DUTTON: That's
fantastic news.

678
00:36:14,630 --> 00:36:16,180
Thanks very much
for joining us.

679
00:36:16,180 --> 00:36:19,340
If you'd like to find out more
about WebRTC, please look

680
00:36:19,340 --> 00:36:23,600
WebRTC.org or we've got an
introductory article about

681
00:36:23,600 --> 00:36:26,350
WebRTC on HTML5rocks.com.

682
00:36:26,350 --> 00:36:28,510
We'll put the links to all
that stuff, all those

683
00:36:28,510 --> 00:36:33,250
resources on the post for this
hangout and on WebRTC.

684
00:36:33,250 --> 00:36:35,130
And we'll tweak that
and so on.

685
00:36:35,130 --> 00:36:38,920
And just to apologize for the
late start time today, really

686
00:36:38,920 --> 00:36:41,360
apologize for the technical
problems we've had with

687
00:36:41,360 --> 00:36:43,050
real-time communication.

688
00:36:43,050 --> 00:36:46,800
And thank you so much
for joining us.

689
00:36:46,800 --> 00:36:49,670
And we'll have to be having
more hangouts

690
00:36:49,670 --> 00:36:50,480
like this in the future.

691
00:36:50,480 --> 00:36:54,250
And just a big thank you to
all of the panel today for

692
00:36:54,250 --> 00:36:56,250
spending valuable
time with us.

693
00:36:56,250 --> 00:36:58,450
SERGE LACHAPELLE: Thank you, I
look forward to doing this

694
00:36:58,450 --> 00:36:59,130
soon again.

695
00:36:59,130 --> 00:37:02,230
SAM DUTTON: Yeah, So thank
you Justin, Malanet,

696
00:37:02,230 --> 00:37:03,380
and Tommy and Serge.

697
00:37:03,380 --> 00:37:05,970
It's been fantastic.

698
00:37:05,970 --> 00:37:07,490
JUSTIN UBERTI: It was
fun to be here.

699
00:37:07,490 --> 00:37:08,290
SAM DUTTON: OK.

700
00:37:08,290 --> 00:37:08,850
See you guys.

701
00:37:08,850 --> 00:37:10,100
MALANET: Bye-bye.

702
00:37:10,100 --> 00:37:13,433

