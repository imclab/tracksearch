1
00:00:00,000 --> 00:00:03,670

2
00:00:03,670 --> 00:00:04,660
RYAN FIORAVANTI: I'm going
to get started now.

3
00:00:04,660 --> 00:00:06,550
Welcome everyone.

4
00:00:06,550 --> 00:00:08,039
My name is Ryan Fioravanti.

5
00:00:08,039 --> 00:00:10,350
I'm here today from the Gmail
team to talk about building

6
00:00:10,350 --> 00:00:12,250
fast mobile web apps.

7
00:00:12,250 --> 00:00:14,510
And if you'd like to follow
along on your laptop or

8
00:00:14,510 --> 00:00:16,020
device, the URL is up here.

9
00:00:16,020 --> 00:00:17,730
You can see the slides at

10
00:00:17,730 --> 00:00:26,390
rjf-io2012.appspot.com OK.

11
00:00:26,390 --> 00:00:29,370
Everyone loves fast stuff,
especially users.

12
00:00:29,370 --> 00:00:32,439
And developers like building
fast things.

13
00:00:32,439 --> 00:00:34,470
Unfortunately, on the mobile
web, it's really

14
00:00:34,470 --> 00:00:36,390
difficult to do.

15
00:00:36,390 --> 00:00:38,790
Today I'm going to try and
present a few things that I

16
00:00:38,790 --> 00:00:42,550
hope you can use to help
build faster mobile web

17
00:00:42,550 --> 00:00:45,120
applications.

18
00:00:45,120 --> 00:00:47,840
When I start looking at
performance work, I like to

19
00:00:47,840 --> 00:00:51,080
approach things in a very
structured manner.

20
00:00:51,080 --> 00:00:53,760
What that means for me is before
I start working on some

21
00:00:53,760 --> 00:00:57,180
improvements, I like to measure
first to prove myself

22
00:00:57,180 --> 00:00:58,400
that there's actually
a problem that

23
00:00:58,400 --> 00:01:00,360
I'm trying to solve.

24
00:01:00,360 --> 00:01:03,150
As I start working on the
problem, I then remeasure

25
00:01:03,150 --> 00:01:06,920
throughout the process to make
sure that I'm making progress

26
00:01:06,920 --> 00:01:08,605
in a way that I'm happy with.

27
00:01:08,605 --> 00:01:12,190
And finally, when I think I'm
done, I'll measure again to

28
00:01:12,190 --> 00:01:14,840
see that I actually had impact
I thought I would.

29
00:01:14,840 --> 00:01:16,620
And if I didn't find an
improvement, I think it's

30
00:01:16,620 --> 00:01:19,380
really important in those
cases to investigate and

31
00:01:19,380 --> 00:01:22,040
figure out why the work that I
did didn't have the impact

32
00:01:22,040 --> 00:01:24,040
that I thought it would.

33
00:01:24,040 --> 00:01:26,370
I seen a lot of people spend a
lot of time trying to make

34
00:01:26,370 --> 00:01:30,350
performance optimizations based
off hunches they have or

35
00:01:30,350 --> 00:01:32,740
ideas, and they spend
a lot of time.

36
00:01:32,740 --> 00:01:34,710
When they're done, it
ends up having no

37
00:01:34,710 --> 00:01:35,980
impact for the users.

38
00:01:35,980 --> 00:01:38,190
And there's no benefit.

39
00:01:38,190 --> 00:01:41,080
So we want to avoid these
kinds of situations.

40
00:01:41,080 --> 00:01:43,550
With this kind of thinking in
mind, this kind of approach, I

41
00:01:43,550 --> 00:01:47,850
decided to structure this
presentation today around a

42
00:01:47,850 --> 00:01:49,600
live website.

43
00:01:49,600 --> 00:01:51,500
So I decided to pick on

44
00:01:51,500 --> 00:01:54,040
html5rocks.com, the mobile version.

45
00:01:54,040 --> 00:01:56,160
And what we're going to do
is do a little bit of

46
00:01:56,160 --> 00:01:58,740
exploration, a little bit of
measurements, to try to

47
00:01:58,740 --> 00:02:02,440
identify what kind of problems
it has, and what kind of fixes

48
00:02:02,440 --> 00:02:06,810
we can make and how much
we can improve this.

49
00:02:06,810 --> 00:02:09,770
So before we start working on
improvements, we first have to

50
00:02:09,770 --> 00:02:12,320
measure to figure out what's
actually wrong.

51
00:02:12,320 --> 00:02:16,350
The best way to do that is by
using a device to do all these

52
00:02:16,350 --> 00:02:18,230
measurements for us.

53
00:02:18,230 --> 00:02:20,920
Now that you all have Chrome on
an Android device, this is

54
00:02:20,920 --> 00:02:22,310
really easy for you to do.

55
00:02:22,310 --> 00:02:24,730
And Chrome on Android comes
with a really neat feature

56
00:02:24,730 --> 00:02:27,560
where you can use the remote
debugger to do profiling on

57
00:02:27,560 --> 00:02:29,150
the device itself.

58
00:02:29,150 --> 00:02:31,640
And this is really useful,
because profiling on your

59
00:02:31,640 --> 00:02:35,950
local desktop browser, for
example, is not at all the

60
00:02:35,950 --> 00:02:38,170
same as profiling on
your mobile device.

61
00:02:38,170 --> 00:02:39,230
The hardware's very different.

62
00:02:39,230 --> 00:02:40,940
The performance is
really different.

63
00:02:40,940 --> 00:02:42,230
And so we really need
to do all this

64
00:02:42,230 --> 00:02:44,600
profiling on a mobile device.

65
00:02:44,600 --> 00:02:47,760
We're also going to install the
PageSpeed extension, and

66
00:02:47,760 --> 00:02:50,090
this is going to help us run
a bunch of automated

67
00:02:50,090 --> 00:02:52,020
analysis on the page.

68
00:02:52,020 --> 00:02:54,300
And hopefully we can get some
quick wins based on its

69
00:02:54,300 --> 00:02:55,550
recommendations.

70
00:02:55,550 --> 00:02:59,290

71
00:02:59,290 --> 00:03:01,560
OK, before we get started out
with PageSpeed or anything

72
00:03:01,560 --> 00:03:05,410
else, we need to define
our success criteria.

73
00:03:05,410 --> 00:03:08,160
So to do that, we need an
accurate way to make some

74
00:03:08,160 --> 00:03:09,690
measurements and figure
out if we're

75
00:03:09,690 --> 00:03:12,320
actually improving anything.

76
00:03:12,320 --> 00:03:14,060
Typically this has been
done in a couple

77
00:03:14,060 --> 00:03:15,830
of ways in the past.

78
00:03:15,830 --> 00:03:17,977
One of the most common ways that
developers would profile

79
00:03:17,977 --> 00:03:21,140
their application or do
measurements for performance

80
00:03:21,140 --> 00:03:25,180
timings, was to add timings in
script blocks for the page.

81
00:03:25,180 --> 00:03:27,850
So it was really common to see
people add a script block at

82
00:03:27,850 --> 00:03:30,480
the top of the document where
they would take a time.

83
00:03:30,480 --> 00:03:31,630
And that would be time zero.

84
00:03:31,630 --> 00:03:33,830
And then they would have timing
throughout the page,

85
00:03:33,830 --> 00:03:36,240
which they could then use the
deltas of to decide how long

86
00:03:36,240 --> 00:03:39,840
certain parts of the page took
for the browser to render.

87
00:03:39,840 --> 00:03:42,540

88
00:03:42,540 --> 00:03:44,570
There's a couple of
problems with this

89
00:03:44,570 --> 00:03:45,550
that we want to avoid.

90
00:03:45,550 --> 00:03:47,930
Number one, just by adding these
measurements to your

91
00:03:47,930 --> 00:03:50,350
page, you can actually have
a negative impact on the

92
00:03:50,350 --> 00:03:51,380
browser's performance.

93
00:03:51,380 --> 00:03:53,730
So just by measuring and looking
at it, you're changing

94
00:03:53,730 --> 00:03:54,950
the situation.

95
00:03:54,950 --> 00:03:56,650
So we want to avoid that.

96
00:03:56,650 --> 00:03:58,920
But also, using this technique,
we were only able

97
00:03:58,920 --> 00:04:02,320
to measure things that were
happening in the browser after

98
00:04:02,320 --> 00:04:04,850
the browser has received
the page content.

99
00:04:04,850 --> 00:04:07,170
We didn't have access to things
like, how long did a

100
00:04:07,170 --> 00:04:07,870
redirect take?

101
00:04:07,870 --> 00:04:09,320
How long did the DNS
lookups take?

102
00:04:09,320 --> 00:04:13,720
How long did the page take to
download from first byte to

103
00:04:13,720 --> 00:04:16,209
the last byte being
sent to the page?

104
00:04:16,209 --> 00:04:18,050
Using this
window.performance.timing

105
00:04:18,050 --> 00:04:20,200
object, we're able to
capture all that

106
00:04:20,200 --> 00:04:21,920
information really easily.

107
00:04:21,920 --> 00:04:24,290
This is an object that's
injected by the browser on

108
00:04:24,290 --> 00:04:27,050
every page load, and it contains
a lot of different

109
00:04:27,050 --> 00:04:29,340
attributes that we can
use to analyze the

110
00:04:29,340 --> 00:04:31,920
full pageload sequence.

111
00:04:31,920 --> 00:04:32,800
So this is really cool.

112
00:04:32,800 --> 00:04:35,240
And we're going to use this in
a bunch of experiments that

113
00:04:35,240 --> 00:04:38,280
we're going to do throughout
this presentation.

114
00:04:38,280 --> 00:04:41,100
The ones I found particularly
interesting from the

115
00:04:41,100 --> 00:04:44,020
experiments I was running
were these four.

116
00:04:44,020 --> 00:04:45,940
So first of all, the most
important one is

117
00:04:45,940 --> 00:04:47,880
navigationStart timing.

118
00:04:47,880 --> 00:04:50,410
This is the exact time that
the user requested for the

119
00:04:50,410 --> 00:04:51,380
page to be loaded.

120
00:04:51,380 --> 00:04:55,290
So this is them clicking a link
to go to your page, or

121
00:04:55,290 --> 00:04:58,610
typing in the URL, or
opening a bookmark.

122
00:04:58,610 --> 00:05:01,060
From the user's perspective,
this is time zero, and

123
00:05:01,060 --> 00:05:03,410
everything after this time is
them sitting there staring at

124
00:05:03,410 --> 00:05:07,530
a white screen, waiting for
your content to appear.

125
00:05:07,530 --> 00:05:10,790
The responseStart event was
the second one that was

126
00:05:10,790 --> 00:05:11,660
interesting to me.

127
00:05:11,660 --> 00:05:15,570
This one is when the browser has
started receiving content.

128
00:05:15,570 --> 00:05:17,790
So this is important because
this tells me when the browser

129
00:05:17,790 --> 00:05:19,160
is able to actually
start doing work.

130
00:05:19,160 --> 00:05:21,640
It's not waiting for the page
to load over the network.

131
00:05:21,640 --> 00:05:23,670
It can start processing
a document, executing

132
00:05:23,670 --> 00:05:27,990
JavaScript, and evaluating
CSS.

133
00:05:27,990 --> 00:05:32,060
The next one is this
domContentLoadedEventStart.

134
00:05:32,060 --> 00:05:34,740
This is basically the
DOMContentReady event.

135
00:05:34,740 --> 00:05:36,630
And this one is important
because this is when your

136
00:05:36,630 --> 00:05:40,450
document becomes interactive and
can start handling events.

137
00:05:40,450 --> 00:05:43,410
And this is our best
approximation for when the

138
00:05:43,410 --> 00:05:46,390
user actually sees something
on the page.

139
00:05:46,390 --> 00:05:50,200
And this is important, because
this is the time that for the

140
00:05:50,200 --> 00:05:52,530
start of this that I'm going to
be optimizing for, for when

141
00:05:52,530 --> 00:05:54,940
the browser gets the page to
when the user sees something.

142
00:05:54,940 --> 00:05:57,680
We want the user to see
something as soon as possible,

143
00:05:57,680 --> 00:05:59,220
because until that point,
they're just staring at a

144
00:05:59,220 --> 00:06:00,170
white screen.

145
00:06:00,170 --> 00:06:02,990
So DOMContentReady means the
user is no longer staring at a

146
00:06:02,990 --> 00:06:04,230
white screen.

147
00:06:04,230 --> 00:06:08,240
The load event is the
window load event.

148
00:06:08,240 --> 00:06:10,790
And this is when the browser's
finished downloading all the

149
00:06:10,790 --> 00:06:13,320
resources on a page, including
the images.

150
00:06:13,320 --> 00:06:15,320
So this is like the final
finish point.

151
00:06:15,320 --> 00:06:18,530

152
00:06:18,530 --> 00:06:18,790
OK.

153
00:06:18,790 --> 00:06:21,260
So we had to set up a baseline
for the experiments before we

154
00:06:21,260 --> 00:06:23,060
start making any performance
improvements.

155
00:06:23,060 --> 00:06:25,220
And this is what
I came up with.

156
00:06:25,220 --> 00:06:28,280
So the way that I set up my
experiments here is, I created

157
00:06:28,280 --> 00:06:30,950
a local copy of html5rocks.com,
the mobile

158
00:06:30,950 --> 00:06:33,950
version, and I set up an
experiment where the browser

159
00:06:33,950 --> 00:06:36,950
would reload the page 50 times
and capture the time from

160
00:06:36,950 --> 00:06:39,920
response start to the
DOMContentReady event.

161
00:06:39,920 --> 00:06:41,960
So what I wanted to optimize
for was just the in-page

162
00:06:41,960 --> 00:06:44,100
rendering, none of the
network stuff.

163
00:06:44,100 --> 00:06:47,390
Just optimizing how fast we
can show the user their

164
00:06:47,390 --> 00:06:50,450
content and stop staring
at the white screen.

165
00:06:50,450 --> 00:06:54,060
And for this experiment, all
the resources are cache,

166
00:06:54,060 --> 00:06:59,810
running on Nexus S hardware,
and using window.reload to

167
00:06:59,810 --> 00:07:02,340
execute the page reloads.

168
00:07:02,340 --> 00:07:04,950
So our baseline here is
1,200 milliseconds.

169
00:07:04,950 --> 00:07:08,100
So 1,200 milliseconds from the
browser getting the first byte

170
00:07:08,100 --> 00:07:10,570
of the document to showing
the user something.

171
00:07:10,570 --> 00:07:12,450
And so that's what we're trying
to improve on now.

172
00:07:12,450 --> 00:07:15,420
And also, 812 kilobytes
transferred for the page.

173
00:07:15,420 --> 00:07:18,040

174
00:07:18,040 --> 00:07:20,270
So the first thing I tried
was PageSpeed.

175
00:07:20,270 --> 00:07:24,670
So you can just open your Chrome
debugger on the Android

176
00:07:24,670 --> 00:07:28,760
device and open up PageSpeed,
and you can run an analysis.

177
00:07:28,760 --> 00:07:31,330
So what it told me right away is
hey, you've got some images

178
00:07:31,330 --> 00:07:33,610
that aren't scaled properly.

179
00:07:33,610 --> 00:07:34,960
So this is a pretty easy fix.

180
00:07:34,960 --> 00:07:36,460
We just have to scale
the images.

181
00:07:36,460 --> 00:07:39,110
So I just modified the local
version to serve up images of

182
00:07:39,110 --> 00:07:40,400
the right size.

183
00:07:40,400 --> 00:07:43,050
The images we were serving were
actually way too big.

184
00:07:43,050 --> 00:07:47,850
They were 369x369 as
opposed to 75x75.

185
00:07:47,850 --> 00:07:49,690
So a lot of wasted
space there.

186
00:07:49,690 --> 00:07:53,830
And also, these were avatar
images, people's photographs,

187
00:07:53,830 --> 00:07:55,080
served up as PNGs.

188
00:07:55,080 --> 00:07:58,130

189
00:07:58,130 --> 00:08:00,840
So I fixed that issue, reran all
my experiments, and these

190
00:08:00,840 --> 00:08:02,280
were the results that I saw.

191
00:08:02,280 --> 00:08:06,740
We had a 2% improvement in
rendering time of the

192
00:08:06,740 --> 00:08:09,990
responseStart event to the DOM
ContentReady, and we saved

193
00:08:09,990 --> 00:08:12,030
about 67 kilobytes.

194
00:08:12,030 --> 00:08:14,070
So this isn't actually the
kind of improvement I was

195
00:08:14,070 --> 00:08:14,570
hoping for.

196
00:08:14,570 --> 00:08:16,110
I thought we were going to be
able to do much better here.

197
00:08:16,110 --> 00:08:19,210
Because we're serving up much
smaller images, and I just

198
00:08:19,210 --> 00:08:21,740
assumed that the browser would
be able to render the page

199
00:08:21,740 --> 00:08:22,450
much more quickly.

200
00:08:22,450 --> 00:08:23,710
But that wasn't actually
the case.

201
00:08:23,710 --> 00:08:25,370
But we did save some
bytes, so that's

202
00:08:25,370 --> 00:08:27,820
good for users' bandwidth.

203
00:08:27,820 --> 00:08:29,480
So at least we have that.

204
00:08:29,480 --> 00:08:31,440
The next thing I realized is,
hey, these are avatars.

205
00:08:31,440 --> 00:08:32,960
We shouldn't be serving
them up as PNGs.

206
00:08:32,960 --> 00:08:34,380
We should be using JPEG.

207
00:08:34,380 --> 00:08:37,100
And with JPEG, we can get much
better compression as well.

208
00:08:37,100 --> 00:08:42,159
So I change the JPEGs and
I remeasured everything.

209
00:08:42,159 --> 00:08:44,910
Here we have another 2%
improvement in rendering time.

210
00:08:44,910 --> 00:08:48,260
We're still talking only about
tens of milliseconds saved.

211
00:08:48,260 --> 00:08:50,690
So this isn't really anything
to get excited about yet.

212
00:08:50,690 --> 00:08:55,100
But we did save another large
chunk of the payload size.

213
00:08:55,100 --> 00:08:58,590
We saved over 300 milliseconds
here, which is a 44%

214
00:08:58,590 --> 00:09:00,840
improvement in the
download size.

215
00:09:00,840 --> 00:09:03,870
So when the resources aren't
cached, the page is going to

216
00:09:03,870 --> 00:09:05,750
load faster, and we're going
to be using less

217
00:09:05,750 --> 00:09:07,030
bandwidth for the users.

218
00:09:07,030 --> 00:09:10,490
So again, no big improvement in
rendering time, but still a

219
00:09:10,490 --> 00:09:12,140
really useful optimization
for us to have made.

220
00:09:12,140 --> 00:09:15,340

221
00:09:15,340 --> 00:09:16,180
Back to PageSpeed.

222
00:09:16,180 --> 00:09:17,600
It's now happy with
the scaled images.

223
00:09:17,600 --> 00:09:20,020
And it's telling us, now you've
got to minify some

224
00:09:20,020 --> 00:09:21,860
JavaScript.

225
00:09:21,860 --> 00:09:24,400
So that's also a pretty
easy fix.

226
00:09:24,400 --> 00:09:26,390
I opened up the network trace,
just to kind of see what

227
00:09:26,390 --> 00:09:29,370
resources it was loading, and
I found that the page was

228
00:09:29,370 --> 00:09:31,990
including the full version
of jQuery.

229
00:09:31,990 --> 00:09:34,070
So that's an easy fix.

230
00:09:34,070 --> 00:09:36,480
I just opened it up, saw that
it's actually the full

231
00:09:36,480 --> 00:09:40,430
version, and then we can just
swap that out with a minified

232
00:09:40,430 --> 00:09:43,510
version, save a bunch
of bytes.

233
00:09:43,510 --> 00:09:45,240
The page functionality
remains the same.

234
00:09:45,240 --> 00:09:47,910
This is a really easy fix to
make because it won't actually

235
00:09:47,910 --> 00:09:49,870
change anything.

236
00:09:49,870 --> 00:09:51,610
And then we can remeasure.

237
00:09:51,610 --> 00:09:54,930
This is the one that surprised
me the most, because here, we

238
00:09:54,930 --> 00:09:57,240
significantly reduced the amount
of JavaScript, but we

239
00:09:57,240 --> 00:10:00,050
didn't actually improve the
rendering time at all.

240
00:10:00,050 --> 00:10:02,580
The rendering time remained
constant from the last set of

241
00:10:02,580 --> 00:10:04,200
experiments.

242
00:10:04,200 --> 00:10:05,160
So that's not good.

243
00:10:05,160 --> 00:10:07,240
But again, we saved some bytes,
so we should do this.

244
00:10:07,240 --> 00:10:08,090
It's the right thing to do.

245
00:10:08,090 --> 00:10:10,820
It'll be faster when the
resources aren't cached, and

246
00:10:10,820 --> 00:10:12,440
that's good.

247
00:10:12,440 --> 00:10:15,350
So I said that we should always
measure before and

248
00:10:15,350 --> 00:10:16,790
after, so that's what
I did here.

249
00:10:16,790 --> 00:10:19,860
And if it doesn't match the
results that you expected, we

250
00:10:19,860 --> 00:10:21,100
should figure out why.

251
00:10:21,100 --> 00:10:23,730
So this is one that really
surprised me.

252
00:10:23,730 --> 00:10:27,350
And I figured out the answer,
and I'm going to show you that

253
00:10:27,350 --> 00:10:29,750
a bit later.

254
00:10:29,750 --> 00:10:32,540
So when you need to minify, this
is something you should

255
00:10:32,540 --> 00:10:35,380
definitely do to save
bytes over the wire.

256
00:10:35,380 --> 00:10:37,330
If you're using a third-party
library, just make sure you're

257
00:10:37,330 --> 00:10:39,940
pulling in the right version
for your production

258
00:10:39,940 --> 00:10:40,960
environment.

259
00:10:40,960 --> 00:10:43,770
So you usually want to include
the [? dead ?] version in your

260
00:10:43,770 --> 00:10:45,520
local setup.

261
00:10:45,520 --> 00:10:49,080
But when you deploy to
production, you should have

262
00:10:49,080 --> 00:10:50,780
some kind of build phase where
you swap it out with the

263
00:10:50,780 --> 00:10:51,920
minified version.

264
00:10:51,920 --> 00:10:53,080
And that's easy to do.

265
00:10:53,080 --> 00:10:54,860
If you're writing a lot of
your own JavaScript, then

266
00:10:54,860 --> 00:10:57,370
you're going to have to do
your own minification.

267
00:10:57,370 --> 00:10:58,850
This is something that
you can also set up

268
00:10:58,850 --> 00:11:00,030
into your build phase.

269
00:11:00,030 --> 00:11:03,410
There's a couple of tools you
can download as command-line

270
00:11:03,410 --> 00:11:05,720
tools that you can run
on your files.

271
00:11:05,720 --> 00:11:07,310
You run this tool, and
it spits out the

272
00:11:07,310 --> 00:11:08,810
minified version for you.

273
00:11:08,810 --> 00:11:10,750
Or if you just want to quickly
minify some stuff and you

274
00:11:10,750 --> 00:11:12,780
don't want to download anything
to get this set up,

275
00:11:12,780 --> 00:11:14,435
there's an online version as
well that you can try.

276
00:11:14,435 --> 00:11:17,650
You just drop some JavaScript
into a text area, click a

277
00:11:17,650 --> 00:11:22,100
button, and then you'll get
the minified version.

278
00:11:22,100 --> 00:11:22,260
OK.

279
00:11:22,260 --> 00:11:24,150
So the next thing that
I wanted to try--

280
00:11:24,150 --> 00:11:25,480
we're done with PageSpeed now.

281
00:11:25,480 --> 00:11:27,880
We've satisfied all of
its recommendations.

282
00:11:27,880 --> 00:11:29,990
The next thing that I
wanted to try is to

283
00:11:29,990 --> 00:11:32,330
run some CSS profiling.

284
00:11:32,330 --> 00:11:35,660
So using this, I can take a look
at exactly how expensive

285
00:11:35,660 --> 00:11:39,360
my CSS rendering is for the
browser to execute.

286
00:11:39,360 --> 00:11:42,160
So to do this, open up your
developer tools on the Android

287
00:11:42,160 --> 00:11:46,730
device, go over to the Profiles
tab, select the CSS

288
00:11:46,730 --> 00:11:49,240
Selector profile,
and click Start.

289
00:11:49,240 --> 00:11:51,930
And this will start a recording
of how expensive

290
00:11:51,930 --> 00:11:53,290
your CSS is.

291
00:11:53,290 --> 00:11:54,890
So what I did here
is I did that.

292
00:11:54,890 --> 00:11:57,010
I clicked start, started
recording, and then reload the

293
00:11:57,010 --> 00:11:59,610
page, and then I stopped
the recording.

294
00:11:59,610 --> 00:12:02,630
And this tells me how expensive
the CSS is during

295
00:12:02,630 --> 00:12:04,620
the pageload.

296
00:12:04,620 --> 00:12:06,090
And here's the results.

297
00:12:06,090 --> 00:12:09,160
So here we get a breakdown of
exactly how expensive every

298
00:12:09,160 --> 00:12:13,620
single CSS rule is in my style
sheets during a pageload.

299
00:12:13,620 --> 00:12:15,580
So it's telling me here,
this rule at the top--

300
00:12:15,580 --> 00:12:18,540
I've sorted by the total time
taken for each rule--

301
00:12:18,540 --> 00:12:21,800
the rule at the top is taking
over 50 milliseconds for the

302
00:12:21,800 --> 00:12:25,140
browser to evaluate while
the page is loading.

303
00:12:25,140 --> 00:12:27,530
This is rendering time that the
browser is spending before

304
00:12:27,530 --> 00:12:29,440
showing the user any content.

305
00:12:29,440 --> 00:12:33,220
So it's telling me, just by
fixing this rule, I can save

306
00:12:33,220 --> 00:12:35,370
the user 50 milliseconds
in wait time.

307
00:12:35,370 --> 00:12:36,800
So that's pretty cool.

308
00:12:36,800 --> 00:12:39,260
And there's also a bunch more
rules here that are over 20

309
00:12:39,260 --> 00:12:40,920
and 30 milliseconds.

310
00:12:40,920 --> 00:12:43,760
So if I fixed all of those, I'd
be looking at hundreds of

311
00:12:43,760 --> 00:12:45,570
milliseconds in savings.

312
00:12:45,570 --> 00:12:48,100
So that's something I'm
interested in, so I dug a

313
00:12:48,100 --> 00:12:49,900
little further.

314
00:12:49,900 --> 00:12:53,430
Before I show exactly what was
wrong, I'll talk a little bit

315
00:12:53,430 --> 00:12:58,180
about what can make CSS
expensive on mobile.

316
00:12:58,180 --> 00:13:01,730
Mainly, it all boils down to how
many elements is your CSS

317
00:13:01,730 --> 00:13:02,980
selector matching?

318
00:13:02,980 --> 00:13:05,170
So if you're matching all
elements in your document,

319
00:13:05,170 --> 00:13:06,530
that's going to be really
expensive for the

320
00:13:06,530 --> 00:13:09,110
browser to work with.

321
00:13:09,110 --> 00:13:12,000
This is why the universal
selector is so bad on mobile,

322
00:13:12,000 --> 00:13:15,470
because the browser has to apply
that to every element in

323
00:13:15,470 --> 00:13:17,450
your document.

324
00:13:17,450 --> 00:13:19,260
Also, ancestor rules are
pretty expensive.

325
00:13:19,260 --> 00:13:22,770
Because when it finds a match
for the right-most element in

326
00:13:22,770 --> 00:13:24,970
the selector, it has to search
the ancestor tree of that

327
00:13:24,970 --> 00:13:30,710
element, further qualifying to
find a match for that rule.

328
00:13:30,710 --> 00:13:34,590
So what I've got here, this body
* rule-- this is about

329
00:13:34,590 --> 00:13:37,450
the worst CSS rule you
could possibly write.

330
00:13:37,450 --> 00:13:39,060
This is the universal
selector matching

331
00:13:39,060 --> 00:13:40,020
everything in the document--

332
00:13:40,020 --> 00:13:41,920
which we already know we
shouldn't do on mobile-- but

333
00:13:41,920 --> 00:13:44,910
also with an ancestor selector
of the body.

334
00:13:44,910 --> 00:13:47,360
So the browser has to enumerate
every single element

335
00:13:47,360 --> 00:13:49,490
in the document, and then search
the ancestor tree of

336
00:13:49,490 --> 00:13:54,260
that element to ensure that it
has an ancestor of type body.

337
00:13:54,260 --> 00:13:56,250
So this is really expensive,
and it's also wasteful,

338
00:13:56,250 --> 00:13:58,590
because of course every
element's in the body.

339
00:13:58,590 --> 00:14:01,130
We really don't need to
qualify for this.

340
00:14:01,130 --> 00:14:04,760

341
00:14:04,760 --> 00:14:08,500
Here's some examples of ways you
can change your CSS from

342
00:14:08,500 --> 00:14:11,510
bad to good for these
different cases.

343
00:14:11,510 --> 00:14:12,830
So first of all, we know
we want to avoid

344
00:14:12,830 --> 00:14:15,040
the universal selector.

345
00:14:15,040 --> 00:14:17,750
The way to avoid this is to
just realize that most the

346
00:14:17,750 --> 00:14:19,730
time, you don't actually
need it.

347
00:14:19,730 --> 00:14:21,970
Say, for example, you want to
apply a consistent font to

348
00:14:21,970 --> 00:14:22,670
your entire document.

349
00:14:22,670 --> 00:14:24,890
You don't need to use the
universal selector to do that

350
00:14:24,890 --> 00:14:28,920
because CSS has this
cascading nature.

351
00:14:28,920 --> 00:14:31,250
You just apply the font rule
to your body, and then your

352
00:14:31,250 --> 00:14:34,250
entire document will naturally
inherit that rule.

353
00:14:34,250 --> 00:14:35,500
So that's an easy fix.

354
00:14:35,500 --> 00:14:38,280

355
00:14:38,280 --> 00:14:40,130
For [? considered ?]

356
00:14:40,130 --> 00:14:43,230
rules, these are pretty standard
rules, the ul li.

357
00:14:43,230 --> 00:14:46,020
If you want to color all of your
list items blue, that's a

358
00:14:46,020 --> 00:14:49,650
pretty standard way to do
it, when we learn CSS.

359
00:14:49,650 --> 00:14:53,070
But if you swap that out with
a specific class name called

360
00:14:53,070 --> 00:14:56,010
unordered-list-item that you
manually apply to all of your

361
00:14:56,010 --> 00:14:58,280
li elements in the document
that are children of ul

362
00:14:58,280 --> 00:15:01,230
elements, this will
execute much

363
00:15:01,230 --> 00:15:03,000
faster on mobile hardware.

364
00:15:03,000 --> 00:15:05,100
And you will see a difference.

365
00:15:05,100 --> 00:15:08,900
Lastly, don't include CSS rules
that set things that are

366
00:15:08,900 --> 00:15:10,330
default values.

367
00:15:10,330 --> 00:15:13,430
Like here, I've got div
set to display block.

368
00:15:13,430 --> 00:15:15,600
Just let the browser
figure that out.

369
00:15:15,600 --> 00:15:19,260
If you're trying to save some
rare user agents that might

370
00:15:19,260 --> 00:15:22,365
have screwed this up, then I
would say, just let most of

371
00:15:22,365 --> 00:15:23,760
your browsers be fast
and let broken

372
00:15:23,760 --> 00:15:25,055
browsers be broken browsers.

373
00:15:25,055 --> 00:15:28,080

374
00:15:28,080 --> 00:15:30,660
So back to the example,
html5rocks.com, we had that

375
00:15:30,660 --> 00:15:33,810
50-millisecond timing
on one rule.

376
00:15:33,810 --> 00:15:37,420
It turns out that it was
specifying a default CSS

377
00:15:37,420 --> 00:15:39,710
property, setting the
box sizing of every

378
00:15:39,710 --> 00:15:41,160
element in the document.

379
00:15:41,160 --> 00:15:42,600
So this one is really easy.

380
00:15:42,600 --> 00:15:43,920
Because it's a default
property, we

381
00:15:43,920 --> 00:15:44,570
can just remove it.

382
00:15:44,570 --> 00:15:46,310
The page will have the
same behavior.

383
00:15:46,310 --> 00:15:50,400
And we can figure out what
kind of impact it had.

384
00:15:50,400 --> 00:15:52,250
So here we go.

385
00:15:52,250 --> 00:15:54,510
Approximately 50 milliseconds
saved in rendering time.

386
00:15:54,510 --> 00:15:57,700
That's just about exactly
what we expected.

387
00:15:57,700 --> 00:15:59,700
That was nice to see.

388
00:15:59,700 --> 00:16:02,740
I was comforted by this, because
the profiler told me,

389
00:16:02,740 --> 00:16:06,080
when I measured before, that I
would save 50 milliseconds if

390
00:16:06,080 --> 00:16:07,660
I fixed this rule.

391
00:16:07,660 --> 00:16:09,570
And then when I measured after,
that was confirmed.

392
00:16:09,570 --> 00:16:11,850
So what this means is that the
profiler is doing an accurate

393
00:16:11,850 --> 00:16:15,600
job of predicting exactly how
much my users will save in

394
00:16:15,600 --> 00:16:18,370
time if I fix those rules.

395
00:16:18,370 --> 00:16:19,060
So that's good to know.

396
00:16:19,060 --> 00:16:22,010
So if you are planning on
setting out for a couple of

397
00:16:22,010 --> 00:16:25,950
days or a week to optimize the
CSS on your page, you can be

398
00:16:25,950 --> 00:16:28,600
sure that you should definitely
open up your CSS

399
00:16:28,600 --> 00:16:31,110
profiler and check, are there
actually any problems?

400
00:16:31,110 --> 00:16:33,050
And if not, then you can just
skip that whole process.

401
00:16:33,050 --> 00:16:37,540

402
00:16:37,540 --> 00:16:37,740
OK.

403
00:16:37,740 --> 00:16:40,700
So what's next?

404
00:16:40,700 --> 00:16:42,780
Remember what we're
trying to do here.

405
00:16:42,780 --> 00:16:46,400
We want to optimize the time for
which the user is sitting

406
00:16:46,400 --> 00:16:49,200
there waiting, looking
at a white screen.

407
00:16:49,200 --> 00:16:52,730
From the time the browser gets
the page to the time they want

408
00:16:52,730 --> 00:16:55,450
to see content, we want to get
rid of everything on that

409
00:16:55,450 --> 00:16:57,260
critical path.

410
00:16:57,260 --> 00:17:01,450
So if we look at the network
trace in your developer tools,

411
00:17:01,450 --> 00:17:05,210
you can see exactly when that
DomReady event is firing.

412
00:17:05,210 --> 00:17:07,230
That's the blue line.

413
00:17:07,230 --> 00:17:08,849
So this is our approximation
for when the

414
00:17:08,849 --> 00:17:10,890
user is seeing content.

415
00:17:10,890 --> 00:17:13,839
Everything on the left of this
is just getting in the way.

416
00:17:13,839 --> 00:17:15,740
So we need to make sure that
everything over here is

417
00:17:15,740 --> 00:17:19,450
something that's critical to
showing our user content.

418
00:17:19,450 --> 00:17:21,270
So here's the first resource.

419
00:17:21,270 --> 00:17:22,260
Obviously this is critical.

420
00:17:22,260 --> 00:17:24,599
This is the main markup
of the page.

421
00:17:24,599 --> 00:17:25,880
Our CSS is pretty critical.

422
00:17:25,880 --> 00:17:29,560
We don't want to show people
just plain HTML.

423
00:17:29,560 --> 00:17:31,742
But then the rest of these are
all JavaScript files that are

424
00:17:31,742 --> 00:17:36,380
loading over the network and
taking time to execute.

425
00:17:36,380 --> 00:17:39,730
So on html5rocks.com, this
is just a plain website.

426
00:17:39,730 --> 00:17:42,860
We don't need to include all
these scripts before we show

427
00:17:42,860 --> 00:17:44,840
the user something.

428
00:17:44,840 --> 00:17:48,280
And the problem with these is
just the presence of the

429
00:17:48,280 --> 00:17:50,540
scripts on the page that's
slowing down the

430
00:17:50,540 --> 00:17:52,200
DOMContentReady event.

431
00:17:52,200 --> 00:17:54,680
When you include a script on
your page, the browser doesn't

432
00:17:54,680 --> 00:17:58,030
actually know when it should
do something with it.

433
00:17:58,030 --> 00:18:00,860
It doesn't know if you need that
script immediately, or if

434
00:18:00,860 --> 00:18:02,920
you just need it 10
seconds from now.

435
00:18:02,920 --> 00:18:05,810
So what it does is it downloads
it immediately,

436
00:18:05,810 --> 00:18:07,910
before doing anything else,
before it proceeds with the

437
00:18:07,910 --> 00:18:09,880
rest of your document,
and then executes

438
00:18:09,880 --> 00:18:12,080
it right away, too.

439
00:18:12,080 --> 00:18:15,400
So in this case, we don't need
that kind of behavior.

440
00:18:15,400 --> 00:18:18,110
We can defer this JavaScript
until later.

441
00:18:18,110 --> 00:18:22,920
So we can do something here in
order to get rid of that.

442
00:18:22,920 --> 00:18:25,570

443
00:18:25,570 --> 00:18:27,800
So what we need is a way to
defer this JavaScript in a

444
00:18:27,800 --> 00:18:29,880
reliable manner.

445
00:18:29,880 --> 00:18:32,670
I looked at a couple
of ways to do this.

446
00:18:32,670 --> 00:18:34,670
First, I tried the
defer attribute.

447
00:18:34,670 --> 00:18:35,680
This didn't work well for me.

448
00:18:35,680 --> 00:18:39,530
I tried it and it worked, but
when I reran my experiments,

449
00:18:39,530 --> 00:18:41,920
it didn't actually
help anything.

450
00:18:41,920 --> 00:18:43,870
When I investigated a little
deeper to find out what was

451
00:18:43,870 --> 00:18:47,350
happening, I found a lot of
resources suggesting that the

452
00:18:47,350 --> 00:18:50,540
defer attribute is more like a
suggestion to the browser.

453
00:18:50,540 --> 00:18:52,830
So it can defer it if it thinks
that's a good idea, or

454
00:18:52,830 --> 00:18:56,380
it'll execute in parallel
to those idle cycles.

455
00:18:56,380 --> 00:18:58,570
I also found a bunch of stuff
that it's not good

456
00:18:58,570 --> 00:19:00,720
cross-browser, and
all this stuff.

457
00:19:00,720 --> 00:19:02,930
But the point is, it just
didn't really work well.

458
00:19:02,930 --> 00:19:06,780
It didn't speed up the
page-rendering time.

459
00:19:06,780 --> 00:19:09,260
I then looked at async
attribute, and this had some

460
00:19:09,260 --> 00:19:12,930
different behavior, where
it would defer the

461
00:19:12,930 --> 00:19:14,200
loading of the scripts.

462
00:19:14,200 --> 00:19:16,810
But they would load in at any
order, not necessarily the

463
00:19:16,810 --> 00:19:18,530
order that you included
them on the page.

464
00:19:18,530 --> 00:19:22,710
So this can lead to some race
conditions where you get

465
00:19:22,710 --> 00:19:24,490
JavaScript errors.

466
00:19:24,490 --> 00:19:26,890
Say, you have some inline
script running jQuery

467
00:19:26,890 --> 00:19:30,280
functions before the jQuery
file gets loaded.

468
00:19:30,280 --> 00:19:31,770
Then that's not going
to work properly.

469
00:19:31,770 --> 00:19:34,420

470
00:19:34,420 --> 00:19:37,910
So what I did is, I cooked up
a way you can include a

471
00:19:37,910 --> 00:19:40,290
special type on your script
attribute that tricks the

472
00:19:40,290 --> 00:19:42,480
browser into thinking that
this isn't actually

473
00:19:42,480 --> 00:19:43,710
JavaScript.

474
00:19:43,710 --> 00:19:45,860
So what we have here, is I've
just stamped all these script

475
00:19:45,860 --> 00:19:48,780
elements with a special
type called notJs.

476
00:19:48,780 --> 00:19:50,740
And so now these scripts will
actually download over the

477
00:19:50,740 --> 00:19:53,770
network, but the browser will
just pass over these and not

478
00:19:53,770 --> 00:19:55,640
do anything with it, because
it doesn't know what it is.

479
00:19:55,640 --> 00:19:58,350

480
00:19:58,350 --> 00:20:00,010
And then when you want to load
these scripts, you can just

481
00:20:00,010 --> 00:20:02,230
include this simple bit
of script here.

482
00:20:02,230 --> 00:20:04,355
What this does is it loads all
the scripts in the document,

483
00:20:04,355 --> 00:20:05,950
and loops through them.

484
00:20:05,950 --> 00:20:08,820
If the type is notJs, then
it sets the type back to

485
00:20:08,820 --> 00:20:12,670
text/javascript and then it
re-adds it to the document.

486
00:20:12,670 --> 00:20:16,180
When you do this, the document
reevaluates it, parses it

487
00:20:16,180 --> 00:20:18,740
right away because now it sees
that it's JavaScript, and

488
00:20:18,740 --> 00:20:22,070
executes it just as
we would expect.

489
00:20:22,070 --> 00:20:24,390
So what I've done is, I modified
the experiments.

490
00:20:24,390 --> 00:20:25,670
I created this function.

491
00:20:25,670 --> 00:20:28,180
I added notJs to all the
scripts on the page.

492
00:20:28,180 --> 00:20:29,650
And then I set this
function to be the

493
00:20:29,650 --> 00:20:32,120
window.onload function.

494
00:20:32,120 --> 00:20:33,942
Here's the results.

495
00:20:33,942 --> 00:20:35,192
Oooh.

496
00:20:35,192 --> 00:20:37,420

497
00:20:37,420 --> 00:20:40,050
So our page running time
just got a lot faster.

498
00:20:40,050 --> 00:20:42,910
We have a 33% improvement in
running time, and this is

499
00:20:42,910 --> 00:20:45,515
hundreds of milliseconds.

500
00:20:45,515 --> 00:20:49,540
But remember, all these
resources are cached.

501
00:20:49,540 --> 00:20:51,480
That's how we're running
these experiments.

502
00:20:51,480 --> 00:20:52,850
So why does this take so long?

503
00:20:52,850 --> 00:20:56,210

504
00:20:56,210 --> 00:20:59,520
It takes so long because it
takes one millisecond to parse

505
00:20:59,520 --> 00:21:03,930
every kilobyte of JavaScript
on modern mobile hardware.

506
00:21:03,930 --> 00:21:04,920
And this is really important.

507
00:21:04,920 --> 00:21:08,450
What I mean by parse is, when
the browser encounters a

508
00:21:08,450 --> 00:21:12,110
script block, this is the time
that it takes to read all the

509
00:21:12,110 --> 00:21:15,900
text in that script block and
figure out what it means in

510
00:21:15,900 --> 00:21:18,910
terms of JavaScript, and then
execute on the top-level lines

511
00:21:18,910 --> 00:21:22,230
of JavaScript in that
script function.

512
00:21:22,230 --> 00:21:25,320
And this is much more expensive
to do on mobile than

513
00:21:25,320 --> 00:21:28,420
it is on desktop.

514
00:21:28,420 --> 00:21:29,870
Here's a more detailed breakdown
of some of the

515
00:21:29,870 --> 00:21:33,430
experiments that my team has run
to investigate what kind

516
00:21:33,430 --> 00:21:36,200
of parse times we see
across devices.

517
00:21:36,200 --> 00:21:39,730
So you can see here, for Nexus
S hardware, it takes 300

518
00:21:39,730 --> 00:21:42,960
milliseconds to parse 300
kilobytes of JavaScript.

519
00:21:42,960 --> 00:21:44,820
And that's where we get our
one millisecond to one

520
00:21:44,820 --> 00:21:46,480
kilobyte rule.

521
00:21:46,480 --> 00:21:49,850
And 300K is a pretty average
amount of JavaScript to

522
00:21:49,850 --> 00:21:52,690
include on a page, especially
for pages that have kind of

523
00:21:52,690 --> 00:21:55,970
been ported over from desktop,
where we just include lots of

524
00:21:55,970 --> 00:21:59,430
JavaScript all the time and
it doesn't really matter.

525
00:21:59,430 --> 00:22:02,170
And 300 milliseconds is a long
time for a user to wait,

526
00:22:02,170 --> 00:22:04,380
sitting and staring at a white
screen, seeing nothing,

527
00:22:04,380 --> 00:22:06,150
waiting for your page to load.

528
00:22:06,150 --> 00:22:07,920
Now what's really interesting
is looking back a few

529
00:22:07,920 --> 00:22:09,690
generations in phone hardware.

530
00:22:09,690 --> 00:22:13,730
And we see that iPhone 2G would
take over three seconds

531
00:22:13,730 --> 00:22:16,900
to parse the same amount
of JavaScript.

532
00:22:16,900 --> 00:22:19,800
And that's a 10x improvement in
just a few generations of

533
00:22:19,800 --> 00:22:21,310
phone hardware.

534
00:22:21,310 --> 00:22:25,160
So what we're seeing is a trend
where phone hardware is

535
00:22:25,160 --> 00:22:28,610
improving drastically,
very quickly.

536
00:22:28,610 --> 00:22:30,650
And so this should play--

537
00:22:30,650 --> 00:22:31,680
you should keep this in mind.

538
00:22:31,680 --> 00:22:34,260
It should play a pretty big role
in how you think about

539
00:22:34,260 --> 00:22:36,850
performance optimizations.

540
00:22:36,850 --> 00:22:37,840
Now let's think back--

541
00:22:37,840 --> 00:22:39,730
our jQuery example.

542
00:22:39,730 --> 00:22:43,130
We minified jQuery, and we saved
over 100 kilobytes in

543
00:22:43,130 --> 00:22:46,180
JavaScript, but we saw no
improvement in rendering time.

544
00:22:46,180 --> 00:22:48,050
So why was that?

545
00:22:48,050 --> 00:22:51,250
So in this table, you'll see--

546
00:22:51,250 --> 00:22:52,420
or maybe you won't see--

547
00:22:52,420 --> 00:22:56,400
these are for minified
JavaScript sizes.

548
00:22:56,400 --> 00:23:00,750
So when we minified our jQuery
file from 240 kilobytes to 90

549
00:23:00,750 --> 00:23:04,220
kilobytes, we didn't actually
make it any less complex for

550
00:23:04,220 --> 00:23:05,180
the browser to parse.

551
00:23:05,180 --> 00:23:07,010
It's still the same
JavaScript.

552
00:23:07,010 --> 00:23:09,960
It still has the same level of
complexity, the same amount of

553
00:23:09,960 --> 00:23:11,910
stuff to execute, and the same
amount of stuff for the

554
00:23:11,910 --> 00:23:13,460
browser to figure out.

555
00:23:13,460 --> 00:23:16,200
So just by minifying it, we
didn't actually save anything

556
00:23:16,200 --> 00:23:17,060
in parse time.

557
00:23:17,060 --> 00:23:19,360
So that makes sense.

558
00:23:19,360 --> 00:23:21,590
What this also means is that you
shouldn't just minify your

559
00:23:21,590 --> 00:23:22,160
JavaScript.

560
00:23:22,160 --> 00:23:23,910
You should compile it.

561
00:23:23,910 --> 00:23:27,530
Using tools like Closure
Compiler, you can run phases

562
00:23:27,530 --> 00:23:32,030
like the dead code removal in
order to get rid of all the

563
00:23:32,030 --> 00:23:34,870
JavaScript on your page that's
not actually being used.

564
00:23:34,870 --> 00:23:37,080
So when you're pulling in
libraries like jQuery and

565
00:23:37,080 --> 00:23:40,410
using only a small fraction of
it, you can use compilers to

566
00:23:40,410 --> 00:23:42,370
remove all the stuff that you're
not actually using.

567
00:23:42,370 --> 00:23:43,950
And when you do that, that's
when you're going to see

568
00:23:43,950 --> 00:23:45,200
improvements in parse time.

569
00:23:45,200 --> 00:23:49,360

570
00:23:49,360 --> 00:23:50,940
OK, so how much faster
can we go now?

571
00:23:50,940 --> 00:23:54,730
We have optimized images,
optimized CSS, and no

572
00:23:54,730 --> 00:23:58,240
JavaScript getting in the way
of our content rendering.

573
00:23:58,240 --> 00:24:01,040
The only thing we could do now
is get rid of styles, which we

574
00:24:01,040 --> 00:24:06,460
probably don't want to do, or
send down a smaller DOM.

575
00:24:06,460 --> 00:24:08,480
So we could just say to our
designers, hey, your

576
00:24:08,480 --> 00:24:09,430
document's too big.

577
00:24:09,430 --> 00:24:10,525
I don't want to show
this much content.

578
00:24:10,525 --> 00:24:12,120
It's really expensive
on mobile.

579
00:24:12,120 --> 00:24:13,400
And maybe that's acceptable.

580
00:24:13,400 --> 00:24:14,740
But say it's not.

581
00:24:14,740 --> 00:24:16,370
There's still something
that you can do.

582
00:24:16,370 --> 00:24:19,600

583
00:24:19,600 --> 00:24:20,610
Here's a little trick.

584
00:24:20,610 --> 00:24:23,330
We're going to lazy load a
bunch of the document.

585
00:24:23,330 --> 00:24:27,910
So we can send down large
portions of the document and

586
00:24:27,910 --> 00:24:31,000
only show a little bit
when we're first

587
00:24:31,000 --> 00:24:33,820
rendering the page.

588
00:24:33,820 --> 00:24:37,350
The html5rocks.com main
page, it's got a lot

589
00:24:37,350 --> 00:24:38,450
of scrollable content.

590
00:24:38,450 --> 00:24:41,240
So there's a lot of stuff when
the user loads the page that's

591
00:24:41,240 --> 00:24:43,020
there, but they can't
actually see.

592
00:24:43,020 --> 00:24:44,910
So there's no reason for us to
actually demand that the

593
00:24:44,910 --> 00:24:47,550
browser try and render
that right away.

594
00:24:47,550 --> 00:24:50,170
So what I've done here is I took
a couple of the top-level

595
00:24:50,170 --> 00:24:53,430
elements on the web page and
set them to display:none,

596
00:24:53,430 --> 00:24:56,880
which just takes it out of the
rendering process completely.

597
00:24:56,880 --> 00:25:00,120
Then on the pageload, we can
just set these back to

598
00:25:00,120 --> 00:25:02,460
display:visible and they'll
show up right away.

599
00:25:02,460 --> 00:25:05,030
So they'll be there by the time
the user scrolls down to

600
00:25:05,030 --> 00:25:07,060
try and use those parts
of the page.

601
00:25:07,060 --> 00:25:09,660
And by doing this, we've made
the page significantly simpler

602
00:25:09,660 --> 00:25:12,350
for the browser to render, and
now we've saved another couple

603
00:25:12,350 --> 00:25:16,140
hundred milliseconds
in rendering time.

604
00:25:16,140 --> 00:25:19,630
So now we're sitting at 600
milliseconds of render time.

605
00:25:19,630 --> 00:25:22,340
So remember, that's time from
the browser getting the page

606
00:25:22,340 --> 00:25:24,550
to showing user content.

607
00:25:24,550 --> 00:25:27,850
And that's just about a 2x
improvement since we started

608
00:25:27,850 --> 00:25:29,690
these optimizations.

609
00:25:29,690 --> 00:25:32,380
So at this point I'm
pretty happy.

610
00:25:32,380 --> 00:25:35,030
And I don't know that there's
much more we can do on just

611
00:25:35,030 --> 00:25:36,390
the rendering, other
than waiting

612
00:25:36,390 --> 00:25:39,340
for newer phone hardware.

613
00:25:39,340 --> 00:25:42,480
We could maybe squeeze out
another 50 or 100 milliseconds

614
00:25:42,480 --> 00:25:45,910
in this rendering time by really
digging into the CSS or

615
00:25:45,910 --> 00:25:49,140
simplifying the DOM a little bit
more, and stuff like that.

616
00:25:49,140 --> 00:25:53,050
But at this point, our effort
is probably better spent

617
00:25:53,050 --> 00:25:55,210
optimizing other things.

618
00:25:55,210 --> 00:25:57,700
So, so far we've only been
looking at the rendering

619
00:25:57,700 --> 00:26:00,815
performance, but there's
actually a lot more variables

620
00:26:00,815 --> 00:26:04,270
that the user waits on, other
than just the rendering.

621
00:26:04,270 --> 00:26:06,375
We need to consider things like
the network load time and

622
00:26:06,375 --> 00:26:08,480
redirects and all this
kind of stuff.

623
00:26:08,480 --> 00:26:11,100
And optimizing for these is
really hard to do on your

624
00:26:11,100 --> 00:26:13,260
local development environments,
because the

625
00:26:13,260 --> 00:26:15,320
environment is completely
different from the production

626
00:26:15,320 --> 00:26:17,230
environment.

627
00:26:17,230 --> 00:26:19,780
So to figure out what real
users in the wild are

628
00:26:19,780 --> 00:26:21,430
experiencing, there's this
cool website called

629
00:26:21,430 --> 00:26:25,040
webpagetest.org, where you can
go and they've got a browser

630
00:26:25,040 --> 00:26:27,240
farm, and you can type
in any website URL.

631
00:26:27,240 --> 00:26:30,630
It will load the page and tell
you exactly what kind of load

632
00:26:30,630 --> 00:26:33,240
sequence your page has.

633
00:26:33,240 --> 00:26:36,310
So these are results for
html5rocks.com using one of

634
00:26:36,310 --> 00:26:40,100
their Android browsers in
the mobile browser farm.

635
00:26:40,100 --> 00:26:42,380
So here we can see exactly
what's happening on pageload.

636
00:26:42,380 --> 00:26:46,160
We've got two redirects here,
and then here's the main

637
00:26:46,160 --> 00:26:49,280
pageload, and then all these
resources loading.

638
00:26:49,280 --> 00:26:51,810
And here's the rest of
the waterfall chart.

639
00:26:51,810 --> 00:26:54,390
So right away, we can see
exactly how much time we could

640
00:26:54,390 --> 00:26:56,470
save the users by optimizing
different

641
00:26:56,470 --> 00:26:58,140
parts of this process.

642
00:26:58,140 --> 00:26:59,830
For example, why do we
need two redirects?

643
00:26:59,830 --> 00:27:02,930
We can just get rid of one of
these redirects, and we would

644
00:27:02,930 --> 00:27:07,330
automatically save 100
milliseconds right there.

645
00:27:07,330 --> 00:27:09,710
But it looks like the biggest
performance improvements we

646
00:27:09,710 --> 00:27:11,740
could make here are
on this pageload.

647
00:27:11,740 --> 00:27:16,550
It's taking over 1.7 seconds
to download this page.

648
00:27:16,550 --> 00:27:19,640
That's pretty terrible.

649
00:27:19,640 --> 00:27:23,730
Also, interestingly, is that
these browsers and the browser

650
00:27:23,730 --> 00:27:25,930
farm are all on a strong
Wi-Fi connection.

651
00:27:25,930 --> 00:27:27,930
So it's not like this is
downloading over an Edge

652
00:27:27,930 --> 00:27:30,670
network and taking
a long time.

653
00:27:30,670 --> 00:27:34,160
This is probably taking over
a second just in server

654
00:27:34,160 --> 00:27:35,970
processing time.

655
00:27:35,970 --> 00:27:38,760
So if we really want to make a
difference for our users, we

656
00:27:38,760 --> 00:27:42,650
would look at this information
and dig into our server

657
00:27:42,650 --> 00:27:45,310
infrastructure and figure out
why it's taking over a second

658
00:27:45,310 --> 00:27:47,790
to process requests and
start sending the

659
00:27:47,790 --> 00:27:49,040
first byte to the browser.

660
00:27:49,040 --> 00:27:52,610

661
00:27:52,610 --> 00:27:54,220
And here's the green line--
this is the load event.

662
00:27:54,220 --> 00:27:55,580
And you can see there's
a bunch of

663
00:27:55,580 --> 00:27:57,330
JavaScript files loading.

664
00:27:57,330 --> 00:27:59,910
This is what we've pushed over
onto the other side of the

665
00:27:59,910 --> 00:28:01,380
Ready event.

666
00:28:01,380 --> 00:28:06,030
And remember that we saved 600
milliseconds, which is maybe

667
00:28:06,030 --> 00:28:09,450
about like this much.

668
00:28:09,450 --> 00:28:12,150
And we said that the only
further improvements we can

669
00:28:12,150 --> 00:28:14,110
make there are pretty
marginal.

670
00:28:14,110 --> 00:28:17,330
So definitely, looking at this
huge chunk here, this is what

671
00:28:17,330 --> 00:28:22,270
we would want to focus on if we
want to help our users out.

672
00:28:22,270 --> 00:28:22,490
OK.

673
00:28:22,490 --> 00:28:25,120
So what if we decide improving
the server is hard?

674
00:28:25,120 --> 00:28:26,850
I want to do this
from the client.

675
00:28:26,850 --> 00:28:29,260
We actually can do that
by using AppCache.

676
00:28:29,260 --> 00:28:31,810
And using AppCache, we can
entirely get rid of the

677
00:28:31,810 --> 00:28:34,060
network time and bring that
to zero, because all the

678
00:28:34,060 --> 00:28:35,920
resources will be
cached locally,

679
00:28:35,920 --> 00:28:38,460
including the HTML file.

680
00:28:38,460 --> 00:28:41,360
To set this up, you just need to
create a manifest file and

681
00:28:41,360 --> 00:28:45,230
link it to your HTML
attribute here.

682
00:28:45,230 --> 00:28:48,020
You host this manifest file
on your web server.

683
00:28:48,020 --> 00:28:50,520
And in this manifest file, you
describe all the resources

684
00:28:50,520 --> 00:28:51,770
that you want to be cached.

685
00:28:51,770 --> 00:28:55,110

686
00:28:55,110 --> 00:28:57,080
So when we add that to the
page and rerun the

687
00:28:57,080 --> 00:28:59,640
experiments, we see that
we've actually

688
00:28:59,640 --> 00:29:01,820
taken a rendering hit.

689
00:29:01,820 --> 00:29:04,050
And so this was important
and a little bit of

690
00:29:04,050 --> 00:29:05,690
a surprise to me.

691
00:29:05,690 --> 00:29:09,180
Upon investigation, I realized
that what was happening was,

692
00:29:09,180 --> 00:29:11,860
the manifest file was
downloading every pageload.

693
00:29:11,860 --> 00:29:14,960
Even if all the resources are
cached, the browser has to

694
00:29:14,960 --> 00:29:18,560
re-download this manifest file
every time it opens the page,

695
00:29:18,560 --> 00:29:21,480
and that's because the manifest
serves as the

696
00:29:21,480 --> 00:29:24,640
indication to the browser as to
when it needs to update the

697
00:29:24,640 --> 00:29:27,240
resources because the
application's out of date.

698
00:29:27,240 --> 00:29:29,570
So when the developer changes
the manifest file, that means

699
00:29:29,570 --> 00:29:31,250
the app needs to be updated and

700
00:29:31,250 --> 00:29:33,280
re-download all the resources.

701
00:29:33,280 --> 00:29:36,290
But what it means for a normal
pageload sequence is that

702
00:29:36,290 --> 00:29:38,810
we've downloaded the page and
the first thing the browser

703
00:29:38,810 --> 00:29:41,340
processes is the HTML node.

704
00:29:41,340 --> 00:29:43,510
And it sees the manifest
attribute, and then right then

705
00:29:43,510 --> 00:29:44,750
and there, it starts
downloading

706
00:29:44,750 --> 00:29:46,330
this AppCache file.

707
00:29:46,330 --> 00:29:48,920
So that means while you're on
the critical path of trying to

708
00:29:48,920 --> 00:29:52,370
render your content, you've
initiated a new download

709
00:29:52,370 --> 00:29:53,550
happening in parallel.

710
00:29:53,550 --> 00:29:55,440
So you're creating resource
contention, and that's why we

711
00:29:55,440 --> 00:29:56,690
see the rendering hit.

712
00:29:56,690 --> 00:29:58,920
However, this is pretty
acceptable, given that we're

713
00:29:58,920 --> 00:30:03,730
saving, as we saw, almost two
seconds in network load time.

714
00:30:03,730 --> 00:30:06,710
So that pretty far offsets the
tens of milliseconds that

715
00:30:06,710 --> 00:30:09,850
we're losing here.

716
00:30:09,850 --> 00:30:11,570
So AppCache sounds
pretty easy.

717
00:30:11,570 --> 00:30:13,870
I'm making it sound like a
silver bullet to improving

718
00:30:13,870 --> 00:30:15,140
your network time.

719
00:30:15,140 --> 00:30:17,550
But that's not actually
the case.

720
00:30:17,550 --> 00:30:18,500
It can be a real challenge.

721
00:30:18,500 --> 00:30:20,500
It can be a real nuisance, and
there's lots of things that

722
00:30:20,500 --> 00:30:23,000
can go wrong.

723
00:30:23,000 --> 00:30:24,050
Let's talk about why.

724
00:30:24,050 --> 00:30:26,970
And it requires a little bit
deeper understanding of how

725
00:30:26,970 --> 00:30:28,240
AppCache works.

726
00:30:28,240 --> 00:30:30,930
So what we're doing here is
looking at the Resources tab.

727
00:30:30,930 --> 00:30:33,670
This is showing us the AppCache
entry for the site on

728
00:30:33,670 --> 00:30:35,860
the local version that
I've created.

729
00:30:35,860 --> 00:30:38,000
These are all the files that
have been added to this

730
00:30:38,000 --> 00:30:40,100
AppCache entry.

731
00:30:40,100 --> 00:30:44,510
The manifest file is the key to
the AppCache entry the maps

732
00:30:44,510 --> 00:30:47,810
all the resources that are
cached in this entry.

733
00:30:47,810 --> 00:30:51,400
So all the resources that you
list in the manifest file--

734
00:30:51,400 --> 00:30:52,630
you can find them all here.

735
00:30:52,630 --> 00:30:55,000
These are the explicit
entries here.

736
00:30:55,000 --> 00:30:59,590
All of the HTML files that point
to this manifest file

737
00:30:59,590 --> 00:31:01,880
end up in here as
master entries.

738
00:31:01,880 --> 00:31:04,190
So if you have 10 pages on your
site, all pointing to the

739
00:31:04,190 --> 00:31:07,150
same manifest file, they'll
all appear here as master

740
00:31:07,150 --> 00:31:10,820
entries in your AppCache
entry.

741
00:31:10,820 --> 00:31:13,400
And then remember, when the
manifest file changes, that's

742
00:31:13,400 --> 00:31:16,800
the signal to the browser to
re-download the resources

743
00:31:16,800 --> 00:31:19,590
because the developer has
published an update to this

744
00:31:19,590 --> 00:31:22,240
application.

745
00:31:22,240 --> 00:31:26,360
So when that happens, you can
see how the browser behaves by

746
00:31:26,360 --> 00:31:29,390
looking at the developer
console when you're

747
00:31:29,390 --> 00:31:31,230
refreshing the page.

748
00:31:31,230 --> 00:31:35,340
So what happens is the browser
sees the manifest file has

749
00:31:35,340 --> 00:31:38,140
changed and then initiates
an AppCache update and

750
00:31:38,140 --> 00:31:40,840
re-downloads all these
resources.

751
00:31:40,840 --> 00:31:42,480
And what we see here is that
it's downloading these two

752
00:31:42,480 --> 00:31:46,360
HTML files at the same time.

753
00:31:46,360 --> 00:31:49,270
Let's look at an example of
why this can be so bad.

754
00:31:49,270 --> 00:31:51,820
Number one, user opens
a single page with

755
00:31:51,820 --> 00:31:53,320
five external resources.

756
00:31:53,320 --> 00:31:56,970
Let's say that totals 350
kilobytes of downloaded stuff.

757
00:31:56,970 --> 00:31:59,720
That goes into the
AppCache entry.

758
00:31:59,720 --> 00:32:02,850
The user then opens 10 more
pages on the site.

759
00:32:02,850 --> 00:32:04,430
Each of them are
200 kilobytes.

760
00:32:04,430 --> 00:32:07,920
All of these go into
the AppCache entry.

761
00:32:07,920 --> 00:32:10,850
Now we've published an update to
the web app by changing the

762
00:32:10,850 --> 00:32:12,570
manifest file.

763
00:32:12,570 --> 00:32:15,960
The user visits just one
of these 11 pages.

764
00:32:15,960 --> 00:32:18,480
The browser checks the manifest
file, sees a change,

765
00:32:18,480 --> 00:32:21,590
and initiates an AppCache
update.

766
00:32:21,590 --> 00:32:23,570
Now, what happens is the browser
downloads over 2

767
00:32:23,570 --> 00:32:27,880
megabytes of data in the
background, just by navigating

768
00:32:27,880 --> 00:32:30,010
to this one page.

769
00:32:30,010 --> 00:32:32,500
Say you had 10,000
users that day.

770
00:32:32,500 --> 00:32:35,830
You're serving up over 20
gigabytes of data versus what

771
00:32:35,830 --> 00:32:38,010
should have been only 20
megabytes of data if they were

772
00:32:38,010 --> 00:32:40,380
just loading those HTML
files by themselves.

773
00:32:40,380 --> 00:32:41,930
So not only could this be really
expensive for your

774
00:32:41,930 --> 00:32:45,700
users, but it can be really
expensive to you, depending on

775
00:32:45,700 --> 00:32:46,950
your server infrastructure.

776
00:32:46,950 --> 00:32:49,700

777
00:32:49,700 --> 00:32:49,860
OK.

778
00:32:49,860 --> 00:32:50,940
So how can we get around this?

779
00:32:50,940 --> 00:32:53,660
The obvious solution seems to
be, let's include one manifest

780
00:32:53,660 --> 00:32:56,060
file per HTML page.

781
00:32:56,060 --> 00:32:58,090
So for every page we're serving
up, it's going to have

782
00:32:58,090 --> 00:33:01,430
its own manifest file, it'll
have its own AppCache entry,

783
00:33:01,430 --> 00:33:03,060
and everything will be good.

784
00:33:03,060 --> 00:33:05,690
That's not actually
the case either.

785
00:33:05,690 --> 00:33:09,320
When you create several AppCache
entries, you can use

786
00:33:09,320 --> 00:33:12,830
Chrome, go into AppCache
Internals, and see how you're

787
00:33:12,830 --> 00:33:14,950
kind of affecting the
various AppCache

788
00:33:14,950 --> 00:33:17,280
entries in the system.

789
00:33:17,280 --> 00:33:19,570
So what I've done is I've
modified the local version to

790
00:33:19,570 --> 00:33:22,400
have several AppCache files for
those two HTML files that

791
00:33:22,400 --> 00:33:25,130
we were previously loading
in a single entry.

792
00:33:25,130 --> 00:33:28,610
What we see here is this one
here is over 350 kilobytes in

793
00:33:28,610 --> 00:33:32,885
size, and this one is also
very large, over 260.

794
00:33:32,885 --> 00:33:35,260
And what's happening is that all
of the external resources

795
00:33:35,260 --> 00:33:38,660
that our manifest files are
pointing to are being cached

796
00:33:38,660 --> 00:33:40,630
in both of these AppCache
entries.

797
00:33:40,630 --> 00:33:44,280
So the AppCache entries can't
share external resources

798
00:33:44,280 --> 00:33:45,630
amongst themselves.

799
00:33:45,630 --> 00:33:46,680
They need to cache
all the files

800
00:33:46,680 --> 00:33:48,480
explicitly in each entry.

801
00:33:48,480 --> 00:33:51,330
And so the sizes of these
are adding up quickly.

802
00:33:51,330 --> 00:33:53,680
And the reason that's a problem
is because the browser

803
00:33:53,680 --> 00:33:57,860
has a hard limit of 5 megabytes
per domain quota for

804
00:33:57,860 --> 00:34:00,650
your AppCache space.

805
00:34:00,650 --> 00:34:03,470
So just based on the pace that
we're going here, for

806
00:34:03,470 --> 00:34:09,949
html5rocks.com, by only adding
10 pages to this AppCache

807
00:34:09,949 --> 00:34:13,000
setup, we would exceed
that limit already.

808
00:34:13,000 --> 00:34:14,909
And what happens when you
exceed the limit is, the

809
00:34:14,909 --> 00:34:18,080
browser tries to download the
updates, and when it gets the

810
00:34:18,080 --> 00:34:20,449
update it tries to push
it into the cache.

811
00:34:20,449 --> 00:34:22,120
But when you've exceeded
your quota, that

812
00:34:22,120 --> 00:34:23,520
push will just fail.

813
00:34:23,520 --> 00:34:25,070
And there's nothing that you
can really do about it

814
00:34:25,070 --> 00:34:27,860
programmatically
in JavaScript.

815
00:34:27,860 --> 00:34:29,840
If your users get into this
situation, they can actually

816
00:34:29,840 --> 00:34:32,310
get stuck on a really stale
version of their site, because

817
00:34:32,310 --> 00:34:34,420
they can't actually update
to the new version.

818
00:34:34,420 --> 00:34:37,030
So this is a pretty big
problem that you

819
00:34:37,030 --> 00:34:37,790
should try to avoid.

820
00:34:37,790 --> 00:34:39,080
And if you get into this
problem, you're kind of

821
00:34:39,080 --> 00:34:41,389
screwed, because you can't
fix it after the fact.

822
00:34:41,389 --> 00:34:44,980
The only thing that you can do
is serve 404s on your AppCache

823
00:34:44,980 --> 00:34:48,380
requests, and this invalidates
the AppCache in the browser.

824
00:34:48,380 --> 00:34:52,060

825
00:34:52,060 --> 00:34:53,210
So it used to seem
really easy.

826
00:34:53,210 --> 00:34:54,100
Now it seems really hard.

827
00:34:54,100 --> 00:34:55,420
How can we actually
make this work?

828
00:34:55,420 --> 00:34:57,370
You have three options,
basically.

829
00:34:57,370 --> 00:35:00,560
You can decide to only include
a manifest file on

830
00:35:00,560 --> 00:35:01,530
a select few pages.

831
00:35:01,530 --> 00:35:04,300
So this means, maybe, your home
page or just a few really

832
00:35:04,300 --> 00:35:06,680
important pages include
a manifest

833
00:35:06,680 --> 00:35:08,270
file and use AppCache.

834
00:35:08,270 --> 00:35:11,240
So this is acceptable, maybe,
depending on your product

835
00:35:11,240 --> 00:35:12,280
requirements.

836
00:35:12,280 --> 00:35:15,130
But what this does is basically
limit the scope on

837
00:35:15,130 --> 00:35:17,890
how big your AppCache
entry can get.

838
00:35:17,890 --> 00:35:20,260
The next thing that you can
try is to implement your

839
00:35:20,260 --> 00:35:23,330
entire site as a single page.

840
00:35:23,330 --> 00:35:27,920
So this is more what those like,
webapps apps do, where

841
00:35:27,920 --> 00:35:32,590
it's just a single
HTML/JavaScript/CSS bundle

842
00:35:32,590 --> 00:35:34,100
sent to the client.

843
00:35:34,100 --> 00:35:37,180
Gmail and Twitter are both good
examples of single-page

844
00:35:37,180 --> 00:35:39,310
sites that use AppCache.

845
00:35:39,310 --> 00:35:41,390
And when you're doing this, you
don't run into the problem

846
00:35:41,390 --> 00:35:44,510
of many pages, because you
only have one page.

847
00:35:44,510 --> 00:35:49,410
And the other option is to just
not use AppCache at all.

848
00:35:49,410 --> 00:35:53,720
Google Search uses a really cool
technique where they want

849
00:35:53,720 --> 00:35:56,410
to cache lots of resources,
but they want those to be

850
00:35:56,410 --> 00:35:58,670
cached across all their URLs,
because when you do a search,

851
00:35:58,670 --> 00:36:02,430
it modifies the URL so that's
shareable and things.

852
00:36:02,430 --> 00:36:05,650
And so they're saving a lot of
stuff in localStorage and

853
00:36:05,650 --> 00:36:07,410
caching their resources that
way, such that they're

854
00:36:07,410 --> 00:36:08,870
available across all pages.

855
00:36:08,870 --> 00:36:12,660

856
00:36:12,660 --> 00:36:13,900
OK, so let's change
gears a bit.

857
00:36:13,900 --> 00:36:17,520
So far we've only talked,
really, about page load and

858
00:36:17,520 --> 00:36:18,882
rendering time.

859
00:36:18,882 --> 00:36:22,120
The next really important
thing on mobile is event

860
00:36:22,120 --> 00:36:23,520
handling time.

861
00:36:23,520 --> 00:36:25,850
Basically, everything that
happens after your page is

862
00:36:25,850 --> 00:36:29,070
loaded is an event handler
of some sort.

863
00:36:29,070 --> 00:36:31,600
And so what I really want to
focus on here is the user does

864
00:36:31,600 --> 00:36:34,470
some kind of interaction on the
page, and then we execute

865
00:36:34,470 --> 00:36:38,230
some JavaScript and publish an
update to the applications and

866
00:36:38,230 --> 00:36:40,730
we change the DOM so the user
sees something happen.

867
00:36:40,730 --> 00:36:44,740

868
00:36:44,740 --> 00:36:46,750
So there's a couple of
high-level guidelines here.

869
00:36:46,750 --> 00:36:50,250
First of all, everything on the
DOM is slow, so touch it

870
00:36:50,250 --> 00:36:52,120
as little as possible.

871
00:36:52,120 --> 00:36:55,350
And when you do touch it, we
want to batch all of the DOM

872
00:36:55,350 --> 00:36:56,510
changes together.

873
00:36:56,510 --> 00:36:58,570
If you were at the Jank
Busting talk that just

874
00:36:58,570 --> 00:37:02,560
happened an hour ago, they
showed a couple of really cool

875
00:37:02,560 --> 00:37:05,610
ways that you could debug
these kind of issues.

876
00:37:05,610 --> 00:37:06,980
And this is a little
bit of the same

877
00:37:06,980 --> 00:37:10,130
thing, but kind of different.

878
00:37:10,130 --> 00:37:14,110
So here's an example of a really
bad event handler.

879
00:37:14,110 --> 00:37:16,820
And this is how you can debug
it and see what's going on.

880
00:37:16,820 --> 00:37:19,950
So using the Events timeline,
we see, here

881
00:37:19,950 --> 00:37:21,040
is the event handler.

882
00:37:21,040 --> 00:37:22,780
And I've expanded this, and
now we can see what's

883
00:37:22,780 --> 00:37:24,450
happening in this
event handler.

884
00:37:24,450 --> 00:37:25,950
And what we see here--

885
00:37:25,950 --> 00:37:30,630
these are Recalculate
Style events.

886
00:37:30,630 --> 00:37:34,120
What we see here is we executed
some JavaScript and

887
00:37:34,120 --> 00:37:35,265
then we have a style
recalculation.

888
00:37:35,265 --> 00:37:38,450
Then we execute some more, and
we have a style recalculation.

889
00:37:38,450 --> 00:37:40,660
And every time there's a style
recalculation, this is what's

890
00:37:40,660 --> 00:37:43,080
really expensive, especially
on mobile.

891
00:37:43,080 --> 00:37:44,910
This is where the browser
says hey, wait, I

892
00:37:44,910 --> 00:37:46,240
gotta update stuff.

893
00:37:46,240 --> 00:37:50,480
And it basically does a reflow
of the entire document to

894
00:37:50,480 --> 00:37:54,140
calculate how large all the
blocks on the page are.

895
00:37:54,140 --> 00:37:56,120
And that's why we see this
big time gap here.

896
00:37:56,120 --> 00:37:58,760
This time here is the browser
just taking time to

897
00:37:58,760 --> 00:38:00,670
lay itself out again.

898
00:38:00,670 --> 00:38:03,000
And then we have another reflow
here, and another one.

899
00:38:03,000 --> 00:38:06,670
And then here's the
Paint event here.

900
00:38:06,670 --> 00:38:09,320
And this is the real goal of
the event handler, is to

901
00:38:09,320 --> 00:38:12,120
respond to the user's event and
Paint as soon as possible.

902
00:38:12,120 --> 00:38:15,310

903
00:38:15,310 --> 00:38:18,930
Here's the code that is the
implementation of this really

904
00:38:18,930 --> 00:38:20,610
bad event handler.

905
00:38:20,610 --> 00:38:24,410
So what we have here is a
bunch of DOM mutations

906
00:38:24,410 --> 00:38:25,790
sprinkled throughout
the event handler.

907
00:38:25,790 --> 00:38:28,460
And this is exactly what
we want to avoid.

908
00:38:28,460 --> 00:38:32,540
And then what we have is, we're
looking at offsetWidth

909
00:38:32,540 --> 00:38:34,160
on one of these divs.

910
00:38:34,160 --> 00:38:37,950
And using offsetWidth is
something that requires the

911
00:38:37,950 --> 00:38:40,540
browser to know how large
things are on the page.

912
00:38:40,540 --> 00:38:42,860
So it needs to do a style
recalculation.

913
00:38:42,860 --> 00:38:47,430
So each one of these offsetWidth
statements here is

914
00:38:47,430 --> 00:38:49,600
what causes the style
recalculation and is what's

915
00:38:49,600 --> 00:38:53,170
making this event
handler so slow.

916
00:38:53,170 --> 00:38:55,800
Here's a reimplementation just
simply rearranging this

917
00:38:55,800 --> 00:38:58,950
function so that it performs
significantly better.

918
00:38:58,950 --> 00:39:01,700
All of the DOM mutations
are batched together.

919
00:39:01,700 --> 00:39:03,690
And then based on these
statements here, we'll only

920
00:39:03,690 --> 00:39:06,250
end up with one style
recalculation.

921
00:39:06,250 --> 00:39:08,610
So here's what it
looks like now.

922
00:39:08,610 --> 00:39:12,320
The event handler fires, we
execute a bunch of JavaScript,

923
00:39:12,320 --> 00:39:14,320
we have one style recalculation,
and

924
00:39:14,320 --> 00:39:15,880
then we do our Paint.

925
00:39:15,880 --> 00:39:19,880
And so this is significantly
faster and will end up being

926
00:39:19,880 --> 00:39:22,390
much more responsive feedback to
our user, because the Paint

927
00:39:22,390 --> 00:39:24,570
happened so much closer
as to when they

928
00:39:24,570 --> 00:39:25,820
interacted with the page.

929
00:39:25,820 --> 00:39:29,340

930
00:39:29,340 --> 00:39:31,530
Here's the performance impact
this can actually have.

931
00:39:31,530 --> 00:39:35,500
So I ran just this simple bad
code snippet on desktop Chrome

932
00:39:35,500 --> 00:39:37,150
1,000 times.

933
00:39:37,150 --> 00:39:41,150
And it took nine seconds for the
bad case and 2.5 seconds

934
00:39:41,150 --> 00:39:42,800
for the good implementation.

935
00:39:42,800 --> 00:39:46,580
This is a 72% improvement in
the processing time of this

936
00:39:46,580 --> 00:39:47,150
event handler.

937
00:39:47,150 --> 00:39:48,160
So that's really significant.

938
00:39:48,160 --> 00:39:50,810
And then on mobile, I ran it
100 times on Chrome for

939
00:39:50,810 --> 00:39:54,220
Android, and similarly, I saw
66% improvement in the

940
00:39:54,220 --> 00:39:55,840
handling time.

941
00:39:55,840 --> 00:39:58,430
So this is really
important to do.

942
00:39:58,430 --> 00:40:02,260
For any time that your user on
your touch-based mobile web

943
00:40:02,260 --> 00:40:02,930
application--

944
00:40:02,930 --> 00:40:05,180
when they touch something, they
want to see an update as

945
00:40:05,180 --> 00:40:05,880
soon as possible.

946
00:40:05,880 --> 00:40:10,530
Because they a), want things to
be fast, but b), when they

947
00:40:10,530 --> 00:40:14,280
touch it, they need that kind
of tactile feedback in order

948
00:40:14,280 --> 00:40:17,460
to feel like the application is
really performing properly.

949
00:40:17,460 --> 00:40:21,150

950
00:40:21,150 --> 00:40:23,580
So the next thing that can
really hurt your interaction

951
00:40:23,580 --> 00:40:27,780
speed is the 300 millisecond
problem.

952
00:40:27,780 --> 00:40:30,290
This is the problem where all
click events on mobile

953
00:40:30,290 --> 00:40:33,900
browsers come 300 milliseconds
after the user actually taps

954
00:40:33,900 --> 00:40:35,420
the screen.

955
00:40:35,420 --> 00:40:37,190
And the reason that browsers
do this is because they're

956
00:40:37,190 --> 00:40:40,170
waiting to see if the user taps
the screen again, which

957
00:40:40,170 --> 00:40:42,120
would indicate a double-tap.

958
00:40:42,120 --> 00:40:44,650
And so a double-tap on mobile
browsers will perform a

959
00:40:44,650 --> 00:40:47,420
zoom-in operation, and so that's
why they introduced

960
00:40:47,420 --> 00:40:50,370
this delay.

961
00:40:50,370 --> 00:40:54,030
For us, if we're creating an app
and we have a button, we

962
00:40:54,030 --> 00:40:55,970
don't really want to have
to support the user

963
00:40:55,970 --> 00:40:57,170
zooming in on a button.

964
00:40:57,170 --> 00:40:59,880
We just want that button to
respond as fast as possible.

965
00:40:59,880 --> 00:41:02,430
And by the time 300 milliseconds
executes, we're

966
00:41:02,430 --> 00:41:03,730
way too late already.

967
00:41:03,730 --> 00:41:04,610
There's nothing we can do.

968
00:41:04,610 --> 00:41:07,370
No matter how efficient our
event handler is, it's going

969
00:41:07,370 --> 00:41:08,620
to be too slow.

970
00:41:08,620 --> 00:41:10,770

971
00:41:10,770 --> 00:41:14,210
So the way we fix this is
actually really hackey.

972
00:41:14,210 --> 00:41:16,980
I've got a code snippet here
that kind of illustrates how

973
00:41:16,980 --> 00:41:18,320
we can do this.

974
00:41:18,320 --> 00:41:21,220
This overrides the default
functionality of the click

975
00:41:21,220 --> 00:41:25,440
event, sets up touchend event
listeners on the button, and

976
00:41:25,440 --> 00:41:28,790
then on the touchend we'll do
whatever click behavior we

977
00:41:28,790 --> 00:41:31,320
wanted the button to do
in the first place.

978
00:41:31,320 --> 00:41:34,920
And then you can get a handle on
your buttons throughout the

979
00:41:34,920 --> 00:41:36,950
application in JavaScript
and decorate

980
00:41:36,950 --> 00:41:39,200
them with this behavior.

981
00:41:39,200 --> 00:41:40,240
And all of a sudden,
your buttons will

982
00:41:40,240 --> 00:41:42,630
be magically fast.

983
00:41:42,630 --> 00:41:46,210
So I make this code seem really
simple, but there's

984
00:41:46,210 --> 00:41:49,480
actually a lot of problems and
glitches that it introduces,

985
00:41:49,480 --> 00:41:50,910
and considerations.

986
00:41:50,910 --> 00:41:53,440
So for more details, check out
this article that I wrote a

987
00:41:53,440 --> 00:41:56,380
while ago on creating fast
buttons for mobile web

988
00:41:56,380 --> 00:41:57,100
applications.

989
00:41:57,100 --> 00:42:00,750
It explains all of the things
that you need to keep in mind

990
00:42:00,750 --> 00:42:02,890
while you're working
with this approach.

991
00:42:02,890 --> 00:42:05,300
And if you don't want to have
to write code yourself,

992
00:42:05,300 --> 00:42:09,170
because developers are lazy,
which is good, you can pull up

993
00:42:09,170 --> 00:42:13,340
this implementation here on
html5boilerplate.com/mobile

994
00:42:13,340 --> 00:42:15,010
and you can just drop
this into your app

995
00:42:15,010 --> 00:42:16,260
and start using it.

996
00:42:16,260 --> 00:42:18,680

997
00:42:18,680 --> 00:42:18,910
OK.

998
00:42:18,910 --> 00:42:22,890
So the next thing that we want
to be able to do when we're

999
00:42:22,890 --> 00:42:25,950
providing user with DOM updates
is to make sure, if

1000
00:42:25,950 --> 00:42:28,570
we're doing animations and
things like that, that they're

1001
00:42:28,570 --> 00:42:30,110
as smooth as possible.

1002
00:42:30,110 --> 00:42:32,920
Which will make the user
happy, hopefully.

1003
00:42:32,920 --> 00:42:34,970
And so the way that we need to
do that is make sure that all

1004
00:42:34,970 --> 00:42:38,180
of our animations and
document updates are

1005
00:42:38,180 --> 00:42:41,930
hardware-accelerated
when necessary.

1006
00:42:41,930 --> 00:42:46,200
So hardware-accelerated means
that you're going to take an

1007
00:42:46,200 --> 00:42:48,470
element, and it's going to be
turned into a layer that will

1008
00:42:48,470 --> 00:42:51,070
be uploaded to the GPU
for processing

1009
00:42:51,070 --> 00:42:52,360
off the main thread.

1010
00:42:52,360 --> 00:42:53,650
And this is what allows
it to be really

1011
00:42:53,650 --> 00:42:56,260
smooth and really fast.

1012
00:42:56,260 --> 00:42:58,310
Making something
hardware-accelerated in your

1013
00:42:58,310 --> 00:43:01,090
document is kind of
magical today.

1014
00:43:01,090 --> 00:43:06,070
You just have to do something to
put it into some 3D space,

1015
00:43:06,070 --> 00:43:09,470
and that will hopefully make
it hardware-accelerated.

1016
00:43:09,470 --> 00:43:12,640
So you can create a class
like this in your CSS

1017
00:43:12,640 --> 00:43:14,550
rules called .hwaccel.

1018
00:43:14,550 --> 00:43:17,210
Webkit-transform is the
identity transform.

1019
00:43:17,210 --> 00:43:18,570
And you can apply this
to elements.

1020
00:43:18,570 --> 00:43:21,460
It won't move it anywhere on the
page, but now updates to

1021
00:43:21,460 --> 00:43:25,130
this element will be
hardware-accelerated.

1022
00:43:25,130 --> 00:43:26,910
Now if you're moving
elements, you can

1023
00:43:26,910 --> 00:43:29,040
create a different class.

1024
00:43:29,040 --> 00:43:32,480
You can move elements using the
positioning attributes,

1025
00:43:32,480 --> 00:43:33,910
like left or top.

1026
00:43:33,910 --> 00:43:36,540
But it's actually much faster to
use the transform property

1027
00:43:36,540 --> 00:43:38,090
to move elements.

1028
00:43:38,090 --> 00:43:40,050
So this will ensure
the best hardware

1029
00:43:40,050 --> 00:43:41,660
acceleration possible.

1030
00:43:41,660 --> 00:43:44,340
So what we have here is a
little CSS rule to make

1031
00:43:44,340 --> 00:43:45,770
something transitionable.

1032
00:43:45,770 --> 00:43:48,460
We've applied transition,
which will be on

1033
00:43:48,460 --> 00:43:49,870
the transform property.

1034
00:43:49,870 --> 00:43:52,520
This transition will take 200
milliseconds to execute and

1035
00:43:52,520 --> 00:43:53,770
we'll use an easing function.

1036
00:43:53,770 --> 00:43:56,460

1037
00:43:56,460 --> 00:43:56,690
OK.

1038
00:43:56,690 --> 00:43:59,890
So we're going to put these
three ideas together now.

1039
00:43:59,890 --> 00:44:03,740
The three ideas were efficient
event handling, solving the

1040
00:44:03,740 --> 00:44:08,780
300-millisecond problem, and
smooth updating of elements

1041
00:44:08,780 --> 00:44:10,290
using hardware acceleration.

1042
00:44:10,290 --> 00:44:11,870
So consider a scenario.

1043
00:44:11,870 --> 00:44:14,320
In your mobile web app, you've
got a button, and when the

1044
00:44:14,320 --> 00:44:16,930
user taps that button, you
want to do a view slide

1045
00:44:16,930 --> 00:44:18,950
transition to the next page.

1046
00:44:18,950 --> 00:44:21,160
And you want this to happen
as fast as possible.

1047
00:44:21,160 --> 00:44:22,720
The next page isn't
rendered yet.

1048
00:44:22,720 --> 00:44:25,970
So we need to render it when
the user taps this.

1049
00:44:25,970 --> 00:44:28,290
And the next page needs to
become interactive as well.

1050
00:44:28,290 --> 00:44:30,360
So not only do we need to render
it, but we need to add

1051
00:44:30,360 --> 00:44:33,460
a bunch of event listeners to
it, and maybe load in some

1052
00:44:33,460 --> 00:44:36,090
images, and stuff like that.

1053
00:44:36,090 --> 00:44:37,570
So here's a nice approach
we can take.

1054
00:44:37,570 --> 00:44:40,450
First of all, we'll set up a
couple of CSS rules for our

1055
00:44:40,450 --> 00:44:44,790
two pages that will make
them transitionable.

1056
00:44:44,790 --> 00:44:48,270
Next we'll take our button and
make it a fast button to avoid

1057
00:44:48,270 --> 00:44:50,770
the 300 millisecond problem.

1058
00:44:50,770 --> 00:44:55,050
Now when the tap event occurs,
we'll get a handle on the

1059
00:44:55,050 --> 00:44:56,920
current page and
the next page.

1060
00:44:56,920 --> 00:44:58,900
We'll render the next page,
but we're going to be very

1061
00:44:58,900 --> 00:45:02,360
careful to only do a minimal
amount of rendering possible.

1062
00:45:02,360 --> 00:45:04,310
So we don't want to render
everything, because that will

1063
00:45:04,310 --> 00:45:04,810
take too long.

1064
00:45:04,810 --> 00:45:09,010
We want to start this animation
as soon as possible.

1065
00:45:09,010 --> 00:45:11,070
We then apply our transform
properties, because using

1066
00:45:11,070 --> 00:45:15,240
transforms is the better way
to reposition an element.

1067
00:45:15,240 --> 00:45:18,080
And we're going to do it such
that the current page animates

1068
00:45:18,080 --> 00:45:23,070
off the screen and the next page
animates onto the screen.

1069
00:45:23,070 --> 00:45:25,200
Remember, we want to make the
next page interactive.

1070
00:45:25,200 --> 00:45:27,000
As soon as we apply these
transforms, the

1071
00:45:27,000 --> 00:45:29,660
animation will start.

1072
00:45:29,660 --> 00:45:31,300
But we still have to do
additional work on the next

1073
00:45:31,300 --> 00:45:34,960
page to load in those extra
resources, images, maybe, and

1074
00:45:34,960 --> 00:45:36,660
add event listeners to it.

1075
00:45:36,660 --> 00:45:39,580
So we can add an event listener
which will fire as

1076
00:45:39,580 --> 00:45:41,240
soon as the transition ends.

1077
00:45:41,240 --> 00:45:44,480
And when it does, now this is
the appropriate time to do all

1078
00:45:44,480 --> 00:45:47,610
that additional rendering
and event setup.

1079
00:45:47,610 --> 00:45:50,480
So what we have here
is probably

1080
00:45:50,480 --> 00:45:51,990
the ideal event handler.

1081
00:45:51,990 --> 00:45:53,040
It's a fast button.

1082
00:45:53,040 --> 00:45:55,070
We do a minimal amount
of DOM changes.

1083
00:45:55,070 --> 00:45:57,390
And all of our DOM changes
are batched together.

1084
00:45:57,390 --> 00:46:00,150
And then we defer all of the
expensive work until after the

1085
00:46:00,150 --> 00:46:01,070
animation starts.

1086
00:46:01,070 --> 00:46:02,600
And our animation is
hardware-accelerated.

1087
00:46:02,600 --> 00:46:06,700

1088
00:46:06,700 --> 00:46:09,820
So that's all I have
for you today.

1089
00:46:09,820 --> 00:46:11,400
Here's a summary of the various

1090
00:46:11,400 --> 00:46:13,520
optimizations that we did.

1091
00:46:13,520 --> 00:46:16,810
And some of them were a little
bit surprising, so again,

1092
00:46:16,810 --> 00:46:18,900
that's why it's really good
that we measure things.

1093
00:46:18,900 --> 00:46:20,880
So we don't just assume what's
going to happen.

1094
00:46:20,880 --> 00:46:24,320
We confirm that it behaves
as expected.

1095
00:46:24,320 --> 00:46:25,780
And these are some of the
tools that we looked at.

1096
00:46:25,780 --> 00:46:27,610
Chrome dev tools, PageSpeed,
and webpagetest.org.

1097
00:46:27,610 --> 00:46:30,540

1098
00:46:30,540 --> 00:46:32,100
And if you're going to remember
anything, please

1099
00:46:32,100 --> 00:46:33,520
remember, don't waste
your time.

1100
00:46:33,520 --> 00:46:35,750
Always measure before
and after.

1101
00:46:35,750 --> 00:46:37,740
Verify all of your
assumptions.

1102
00:46:37,740 --> 00:46:40,160
And optimize what will make a
difference, not just what's

1103
00:46:40,160 --> 00:46:42,798
interesting to work on.

1104
00:46:42,798 --> 00:46:43,260
OK.

1105
00:46:43,260 --> 00:46:45,150
Thank you very much.

1106
00:46:45,150 --> 00:46:47,341
I'll happily take some questions
if people want.

1107
00:46:47,341 --> 00:46:53,000
[APPLAUSE]

1108
00:46:53,000 --> 00:46:54,180
AUDIENCE: Hey there.

1109
00:46:54,180 --> 00:46:55,960
RYAN FIORAVANTI: I can also
stick around for a bit after,

1110
00:46:55,960 --> 00:46:57,750
if people would like
to talk in person.

1111
00:46:57,750 --> 00:46:59,430
But if you want to ask a
question in front of everyone,

1112
00:46:59,430 --> 00:47:01,250
just step up to the mic.

1113
00:47:01,250 --> 00:47:05,340
AUDIENCE: I was wondering if you
know if jQuery mobile uses

1114
00:47:05,340 --> 00:47:10,310
most of the optimizations that
you were just showing.

1115
00:47:10,310 --> 00:47:11,860
RYAN FIORAVANTI: jQuery
mobile, I know--

1116
00:47:11,860 --> 00:47:15,200
I'm pretty sure they have the
tab functionality, like making

1117
00:47:15,200 --> 00:47:16,970
buttons fast.

1118
00:47:16,970 --> 00:47:18,750
I've also seen that they've
worked a lot on view

1119
00:47:18,750 --> 00:47:21,440
transitions and things.

1120
00:47:21,440 --> 00:47:24,620
When you're using these
frameworks, they can try and

1121
00:47:24,620 --> 00:47:25,590
do a lot of stuff for you.

1122
00:47:25,590 --> 00:47:27,730
But based on all of your
integration points, it's

1123
00:47:27,730 --> 00:47:30,170
really easy to introduce
slow points.

1124
00:47:30,170 --> 00:47:32,120
So it's really important, even
if you're using all these

1125
00:47:32,120 --> 00:47:34,770
libraries, that you really dig
and understand what can make

1126
00:47:34,770 --> 00:47:35,750
your app slow.

1127
00:47:35,750 --> 00:47:37,730
And look at if it's
being slow.

1128
00:47:37,730 --> 00:47:40,240
Maybe jQuery mobile does do
all of this stuff, but you

1129
00:47:40,240 --> 00:47:42,110
have to confirm that you're
using it properly.

1130
00:47:42,110 --> 00:47:45,490
Because there's so much you
can do to screw it up.

1131
00:47:45,490 --> 00:47:46,740
So yeah.

1132
00:47:46,740 --> 00:47:48,840

1133
00:47:48,840 --> 00:47:48,986
AUDIENCE: Yeah.

1134
00:47:48,986 --> 00:47:51,460
I have a question about your
really interesting technique

1135
00:47:51,460 --> 00:47:54,320
for making the JavaScript
load later by making

1136
00:47:54,320 --> 00:47:55,320
it a different type.

1137
00:47:55,320 --> 00:47:57,280
I've seen a lot of people do the
technique where they put

1138
00:47:57,280 --> 00:47:58,740
the JavaScript at the
bottom of the page

1139
00:47:58,740 --> 00:48:00,650
instead of in the head.

1140
00:48:00,650 --> 00:48:02,550
How does that play into
the decision?

1141
00:48:02,550 --> 00:48:04,770
RYAN FIORAVANTI: Yeah, so I
tried moving the JavaScript to

1142
00:48:04,770 --> 00:48:06,020
the bottom of page.

1143
00:48:06,020 --> 00:48:09,020

1144
00:48:09,020 --> 00:48:13,580
When it's at the bottom of the
page, the browser has just

1145
00:48:13,580 --> 00:48:15,750
finished receiving the
entire document.

1146
00:48:15,750 --> 00:48:19,680
And so it's not clear whether
it's being painted or not.

1147
00:48:19,680 --> 00:48:22,130
And it then encounters the
JavaScript, which may or may

1148
00:48:22,130 --> 00:48:23,230
not be mutating the DOM.

1149
00:48:23,230 --> 00:48:25,220
So it then executes
all of that.

1150
00:48:25,220 --> 00:48:27,230
So when I did that, it didn't
actually have an impact on my

1151
00:48:27,230 --> 00:48:29,440
experiments at all.

1152
00:48:29,440 --> 00:48:31,150
And it kind of makes sense.

1153
00:48:31,150 --> 00:48:34,060
Like if your script at the
bottom is going to change

1154
00:48:34,060 --> 00:48:36,550
everything in the document, then
the browser should wait

1155
00:48:36,550 --> 00:48:42,220
for that so that you can show
the user the proper content.

1156
00:48:42,220 --> 00:48:43,370
Does that answer your question?

1157
00:48:43,370 --> 00:48:45,470
Yeah.

1158
00:48:45,470 --> 00:48:48,560
AUDIENCE: What tool
did you use to get

1159
00:48:48,560 --> 00:48:51,960
the repeated pageloads?

1160
00:48:51,960 --> 00:48:53,630
RYAN FIORAVANTI: So at first--

1161
00:48:53,630 --> 00:48:54,300
I'll be honest--

1162
00:48:54,300 --> 00:48:56,950
I was actually just refreshing
the page and looking at some

1163
00:48:56,950 --> 00:48:58,980
of the timing output
in the dev console.

1164
00:48:58,980 --> 00:49:05,070
But then I got much smarter and
I created a loop, kind of,

1165
00:49:05,070 --> 00:49:07,620
where the page would load and
then it would take my timing.

1166
00:49:07,620 --> 00:49:10,380
I would save that in
localStorage and then I would

1167
00:49:10,380 --> 00:49:12,690
call window.location.reload.

1168
00:49:12,690 --> 00:49:15,550
And also in localStorage, I
would save the number of times

1169
00:49:15,550 --> 00:49:16,840
I ran this.

1170
00:49:16,840 --> 00:49:20,340
So when that counter
got to 50--

1171
00:49:20,340 --> 00:49:22,260
because I was running
50 samples--

1172
00:49:22,260 --> 00:49:24,410
then I would stop calling
reload, and I would just stop,

1173
00:49:24,410 --> 00:49:26,460
and I would alert the
average of all the

1174
00:49:26,460 --> 00:49:27,710
times that I was tracking.

1175
00:49:27,710 --> 00:49:30,210

1176
00:49:30,210 --> 00:49:30,770
So, no tool.

1177
00:49:30,770 --> 00:49:31,910
I just wrote something
that used

1178
00:49:31,910 --> 00:49:33,160
localStorage pretty quickly.

1179
00:49:33,160 --> 00:49:38,451

1180
00:49:38,451 --> 00:49:38,950
OK.

1181
00:49:38,950 --> 00:49:40,200
Thanks everybody.

1182
00:49:40,200 --> 00:49:42,048

