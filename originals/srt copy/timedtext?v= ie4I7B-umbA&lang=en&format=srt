1
00:00:07,339 --> 00:00:13,340
>>Boris Smus: All right. Hey, folks, good
to see so many people in the room. Can everyone

2
00:00:13,340 --> 00:00:18,650
hear me fine?
Great. So my name is Boris Smus. I'm an engineer

3
00:00:18,650 --> 00:00:23,640
in the Chrome developer relations team. And
this talk is called Fast User Interface for

4
00:00:23,640 --> 00:00:30,570
the cross-device Web. So before talking about
this, let me motivate the subject a little

5
00:00:30,570 --> 00:00:36,239
bit. Who cares?
And I care and you should care because this

6
00:00:36,239 --> 00:00:41,270
is the current state of mobile internet usage
compared to desktop internet usage. So you

7
00:00:41,270 --> 00:00:48,270
can see the projected cross-over point for
when mobile becomes more used, and this is

8
00:00:48,380 --> 00:00:55,000
sometime around 2013, 2014. This is all internet
use, so not just Web. The Web is currently

9
00:00:55,000 --> 00:01:02,000
about 10% of all -- mobile Web is about 10%
of all Web usage and it's been doubling every

10
00:01:02,510 --> 00:01:09,510
year, so expect this to change very drastically.
Note that I call the talk cross-device, and

11
00:01:11,280 --> 00:01:17,189
not mobile, because the term mobile is a little
bit overloaded. Does it include tablets?

12
00:01:17,189 --> 00:01:21,590
Does it include other kinds of devices like
TVs, cars, et cetera?

13
00:01:21,590 --> 00:01:24,279
And what is the opposite of mobile?
Stationary?

14
00:01:24,279 --> 00:01:29,369
Desktop?
Not clear. So I'm not going to jump into pedantic

15
00:01:29,369 --> 00:01:35,859
discussions about this. Instead, clearly,
this is not a mobile device, so this is a

16
00:01:35,859 --> 00:01:42,259
desktop, and many people still think of this
as the target for the Web. But, in fact, the

17
00:01:42,259 --> 00:01:48,009
Web looks a lot more like this. We have a
mass of devices that all access -- that all

18
00:01:48,009 --> 00:01:53,969
expect Web content to serve correctly for
them, tablets, SmartPhones, et cetera, it's

19
00:01:53,969 --> 00:01:59,630
very complex landscape, and it's only going
to get more complex and more interesting with

20
00:01:59,630 --> 00:02:06,630
future interactions that can include gestural
UIs, handtracking, full body tracking, et

21
00:02:07,099 --> 00:02:13,940
cetera, or audio input. So how can we talk
about this broad topic?

22
00:02:13,940 --> 00:02:18,299
There are still a set of common issues that
we need to tackle for all of these problems

23
00:02:18,299 --> 00:02:24,390
that I've discussed. We have a wide variety
of form factors, as you saw a couple of slides

24
00:02:24,390 --> 00:02:29,599
ago. In addition we have CPUs and networks
that are much, much slower and much less predictable

25
00:02:29,599 --> 00:02:35,189
in many cases on mobile devices. We need to
deal with new kinds of input, specifically

26
00:02:35,189 --> 00:02:40,390
touch and multi-touch, and we have issues
with developing when your host machine is

27
00:02:40,390 --> 00:02:45,730
not your target machine. So I'll talk more
about that, in addition. So this is -- these

28
00:02:45,730 --> 00:02:51,790
are all issues, but they're also -- this is
also a outline for the rest of the talk. So

29
00:02:51,790 --> 00:02:57,700
let's jump right in into the form factor question.
And how do we support multiple devices that

30
00:02:57,700 --> 00:03:04,700
access our site?
First extreme is we simply create one version.

31
00:03:05,909 --> 00:03:11,150
And some people do this. Some of the examples
of sites that do -- that take this approach

32
00:03:11,150 --> 00:03:17,640
are shown here. We have -- you can see text
that's not very clearly readable. It's very

33
00:03:17,640 --> 00:03:23,760
small on a mobile device. Text that's being
cut off because the developers didn't intend

34
00:03:23,760 --> 00:03:29,489
it to be used on such a screen, or in this
last example, we have actually two versions,

35
00:03:29,489 --> 00:03:33,459
one of which says the device doesn't work
on your phone, or the application doesn't

36
00:03:33,459 --> 00:03:39,379
work on your phone. Sorry. So this is not
a very good extreme to be at. The other opposite

37
00:03:39,379 --> 00:03:46,370
end of the spectrum is to create a version
for each device, so we have here a very incomplete

38
00:03:46,370 --> 00:03:52,249
list of sound devices in the market and you
can simply say, okay, let's develop a version

39
00:03:52,249 --> 00:03:56,689
for each. You can see this has ten devices,
there's probably hundreds, maybe thousands

40
00:03:56,689 --> 00:04:01,209
of devices out there. It's simply not feasible
to do this, especially if you take into account

41
00:04:01,209 --> 00:04:05,749
the number of browsers that exists on some
platforms. For example, Android supports a

42
00:04:05,749 --> 00:04:11,469
wide variety of browsers. So we need to find
some sort of middle ground, keeping in mind

43
00:04:11,469 --> 00:04:16,620
this tradeoff that the more versions you create
the better each one can be from a user experience

44
00:04:16,620 --> 00:04:23,220
perspective but the more effort it will require.
So the question then is where can we save

45
00:04:23,220 --> 00:04:27,680
some effort?
And how can we make this a -- how can we make

46
00:04:27,680 --> 00:04:34,680
a better decision what to build?
So we have two sort of axes to choose from.

47
00:04:35,830 --> 00:04:42,830
We have platforms and form factors. Let's
talk about platforms. So native platforms,

48
00:04:44,639 --> 00:04:51,000
this is a bit of an aside, they provide human
interface guidelines and UI frameworks, so

49
00:04:51,000 --> 00:04:56,509
this is on the -- on the right, example of
a human interface guideline for Android, it

50
00:04:56,509 --> 00:05:01,819
provides a set of common UI controls and the
corresponding UI framework makes it really

51
00:05:01,819 --> 00:05:08,280
easy to build that kind of UI for a developer.
So the point of this is to make it -- to have

52
00:05:08,280 --> 00:05:13,539
developers fall into a pit of success by default.
If you try to do this sort of thing on the

53
00:05:13,539 --> 00:05:20,539
Web, as some people have, you quickly run
into problems, so emulating native UIs is

54
00:05:22,050 --> 00:05:28,430
a perilous path. It's hard to implement. You're
going to be always slightly off and look and/or

55
00:05:28,430 --> 00:05:34,830
feel, and even once you've done this painstaking
effort that some people have taken, you still

56
00:05:34,830 --> 00:05:40,500
have to repeat that same process on every
other platform that you want to support. So

57
00:05:40,500 --> 00:05:44,979
if you want to read more about some pour soul
that did this, you should check out this guy's

58
00:05:44,979 --> 00:05:49,229
blog post. It's very detailed and good. He
goes into details like you can see a little

59
00:05:49,229 --> 00:05:56,229
bit of diagonal artifact here in the CSS version
of this platform. So that kind of level of

60
00:05:57,430 --> 00:06:03,580
detail. So generally speaking platform differences
vary -- platform differences are both small,

61
00:06:03,580 --> 00:06:09,419
so we can have different styles for buttons,
but some of them may appear bigger, for example,

62
00:06:09,419 --> 00:06:15,150
the placement of navigation bar, the Android
human interface guideline says to place it

63
00:06:15,150 --> 00:06:21,060
at the top of the screen whereas the IOS one
places it on the bottom. Fairly major change,

64
00:06:21,060 --> 00:06:25,940
but it's important to note that these are
differences that -- or, sorry, these are rules

65
00:06:25,940 --> 00:06:31,330
that are meant to be broken, and in many cases
are. So on Android many applications place

66
00:06:31,330 --> 00:06:36,569
the tool bar on the bottom, whereas on IOS
for example, on iPad the guidelines actually

67
00:06:36,569 --> 00:06:43,569
say to place it on the top. If we look at
form factor differences, though, these are

68
00:06:44,039 --> 00:06:48,940
much bigger. We have completely different
usage patterns, phones that you hold with

69
00:06:48,940 --> 00:06:55,599
one hand, and tablets that you hold with two.
Major variations in screen real estate. So

70
00:06:55,599 --> 00:07:02,599
these form factor differences I would say
trump platform differences, so as a first

71
00:07:03,240 --> 00:07:08,300
cut, and I'm not saying that this is perfect
for your application, we can consider having

72
00:07:08,300 --> 00:07:15,300
multiple versions of our site, and compromise
to phone, tablet and desktop, just as a starting

73
00:07:18,879 --> 00:07:24,110
point. So how do we actually build this?
We build this -- there's two possible angles

74
00:07:24,110 --> 00:07:28,349
to come at it from. We can start from single
version and make tweaks -- diversion tweaks

75
00:07:28,349 --> 00:07:34,120
to that version, or we can say up front we're
going to build three versions and serve the

76
00:07:34,120 --> 00:07:41,120
correct one. So the first version, many of
you are probably familiar with CSS media queries.

77
00:07:42,599 --> 00:07:49,419
In case you're not, it's an easy way to tweak
your CSS style sheets depending on properties

78
00:07:49,419 --> 00:07:55,979
of your device. So here I have a media query
which says if the screen is less than 1,000

79
00:07:55,979 --> 00:08:02,979
pixels, then hide the side bar. So this is
pretty straightforward, and is used to create

80
00:08:03,550 --> 00:08:10,550
websites that look like this. So here is a
German design magazine, and you can see, as

81
00:08:13,050 --> 00:08:20,050
I resize the page, the styling changes subtly.
You will see -- you'll notice also that Chrome

82
00:08:23,319 --> 00:08:28,969
has a minimum size. Let me show you a cool
trick that you can -- you may not know. I

83
00:08:28,969 --> 00:08:35,169
can actually resize the page using the developer
tools. Resize it back to the correct size

84
00:08:35,169 --> 00:08:41,980
here. Switch over to Dev Tools, and I will
override device metrics here and pick the

85
00:08:41,980 --> 00:08:48,980
resolution that I want. Just set it to 320
by 480, and you can see I've sized it down

86
00:08:49,440 --> 00:08:56,160
-- I couldn't use Chrome natively -- or sorry,
I couldn't resize Chrome to be this small.

87
00:08:56,160 --> 00:09:03,160
You can get a good preview of how these sites
look like using this feature. But there's

88
00:09:06,350 --> 00:09:11,260
limitations to this approach, right?
We're talking here about a shared DOM, shared

89
00:09:11,260 --> 00:09:17,060
JavaScript and simply tweaking the CSS. So
if we want to make big changes between form

90
00:09:17,060 --> 00:09:23,260
factors such as this example here where we
have Gmail native apps for Android, you can

91
00:09:23,260 --> 00:09:28,720
imagine the pain that you would have to go
through to use this same HTML and create these

92
00:09:28,720 --> 00:09:35,720
separate layouts. A lot of CSS tweaks, a lot
of hidden content, a lot of conditional CSS

93
00:09:36,010 --> 00:09:41,120
for the various -- for the two form factors.
Also, since we have shared JavaScript in this

94
00:09:41,120 --> 00:09:48,120
case, how do we load additional functionality?
So one middle ground here, between these -- between

95
00:09:50,840 --> 00:09:56,510
the two extremes of one version and separate
versions completely is using media queries

96
00:09:56,510 --> 00:10:02,970
in JavaScript, we can do this with the window
of match media call, and this lets you evaluate

97
00:10:02,970 --> 00:10:07,600
arbitrary media queries as in this sample,
you can see I'm evaluating this media query

98
00:10:07,600 --> 00:10:14,600
and I'm seeing if it matches or not. You can
also listen for changes with this event listener,

99
00:10:15,420 --> 00:10:21,520
syntax, and here in this example, I'm listening
for the orientation media query, and as soon

100
00:10:21,520 --> 00:10:27,070
as that changes, if I switch from portrait
to landscape, this will fire, and I can respond

101
00:10:27,070 --> 00:10:34,070
to that. It's a much nicer way of going about
things using orientation change.

102
00:10:36,500 --> 00:10:42,590
But if we want to completely separate the
two -- separate the versions that we want

103
00:10:42,590 --> 00:10:49,590
to create, we can take an approach like this.
This is really simple code that basically

104
00:10:49,600 --> 00:10:55,150
says default to a desk -- to the desktop version,
then check for touch support, if there's touch

105
00:10:55,150 --> 00:10:59,970
support and the screen is small, is there
a phone version, otherwise if the screen is

106
00:10:59,970 --> 00:11:06,970
large but touch is still enabled, serve the
tablet. So here we need to figure out how

107
00:11:07,100 --> 00:11:11,790
to know if there's touch or not. Right now
there's not a really good way of doing this

108
00:11:11,790 --> 00:11:18,490
on the open Web. So we can use modernizr or
other feature detection libraries to do this

109
00:11:18,490 --> 00:11:25,490
sort of thing. So modernizr.touch will return
true if touch is enabled. But we have media

110
00:11:26,520 --> 00:11:31,080
queries that are coming through the pipe.
They're not implemented anywhere yet. We have

111
00:11:31,080 --> 00:11:38,080
hover and pointer media queries which are
used to distinguish between pointer or mouse

112
00:11:38,270 --> 00:11:45,270
pointer type input and touch input. The other
question here is how do we know what's small

113
00:11:46,870 --> 00:11:50,520
enough?
Where do we draw the line between phones and

114
00:11:50,520 --> 00:11:54,110
tablets?
So we can evaluate the media query, but where

115
00:11:54,110 --> 00:12:01,110
do we set this boundary?
So here is a -- on the right -- diagram of

116
00:12:04,190 --> 00:12:10,890
various mobile devices and their resolutions
in CSS pixels, so it's important here for

117
00:12:10,890 --> 00:12:16,480
this discussion to remember that, CSS pixels
are not the same as device pixels. CSS pixels

118
00:12:16,480 --> 00:12:23,480
are scaled to the -- they're scaled by the
device pixel ratio to be virtually sized,

119
00:12:25,960 --> 00:12:32,550
essentially, so the history here is when Apple
released iPhone 4, they had doubled the resolution

120
00:12:32,550 --> 00:12:37,120
of both dimensions, creating four times as
many pixels on the screen. So if they did

121
00:12:37,120 --> 00:12:42,300
nothing about this, then sites would render
at half size, so they introduced this notion

122
00:12:42,300 --> 00:12:49,300
of device pixel ratio, and sites render the
same way on iPhone 4 and iPhone 3, and other

123
00:12:49,850 --> 00:12:55,200
device vendors have been embracing this and
providing device pixel ratios sometimes of

124
00:12:55,200 --> 00:13:02,200
2, sometimes of 1.5, sometimes somewhat irrational
numbers so it's a little bit interesting and

125
00:13:04,070 --> 00:13:10,790
you should definitely be aware of this -- this
concept. So if we take a look at the diagram,

126
00:13:10,790 --> 00:13:17,000
we can say, well, let's just draw the line
at, let's see, 400, somewhere between 400

127
00:13:17,000 --> 00:13:21,980
and 600, that's pretty straightforward, right?
But we should remember that all these devices

128
00:13:21,980 --> 00:13:26,980
have landscape mode as well, in which case
width becomes height, height becomes width.

129
00:13:26,980 --> 00:13:33,720
So the actual picture is something more like
this, if we take a look at the max of the

130
00:13:33,720 --> 00:13:38,430
two dimensions for phones and they're meant
for tablets, so we can draw the line roughly

131
00:13:38,430 --> 00:13:44,640
at 650 pixels, and this will work most of
the time with some exceptions. For example,

132
00:13:44,640 --> 00:13:51,640
some -- some tablets in portrait mode, in
this case will get the phone version. So if

133
00:13:53,360 --> 00:13:57,410
you're specifying multiple versions of your
site, you may be sharing a URL or you may

134
00:13:57,410 --> 00:14:04,410
have separate URLs. If you have separate URLs,
then you can declaratively define all the

135
00:14:04,510 --> 00:14:08,920
versions of your site in your head section,
and you can do that with the link rel equals

136
00:14:08,920 --> 00:14:15,650
alternate and the idea here is you specify
the URLs and the associated media queries

137
00:14:15,650 --> 00:14:20,840
for each of these versions. This is good for
crawlers that are indexing your site so that

138
00:14:20,840 --> 00:14:27,390
they can know which versions exist and to
crawl them with these different settings.

139
00:14:27,390 --> 00:14:32,700
So one thing that you might want to do is
based on these versions that you've declared

140
00:14:32,700 --> 00:14:39,700
up front, redirect correctly. So the Web doesn't
do this for you, so I worked on a project

141
00:14:40,580 --> 00:14:46,310
called device.js which tries to formalize
this approach, and what it does is it parses

142
00:14:46,310 --> 00:14:52,420
the link alternates in your head section,
matches the media queries and then redirects

143
00:14:52,420 --> 00:14:59,420
you to the right version, if necessary. So
let me quickly show you how this works. So

144
00:15:00,040 --> 00:15:07,040
I'll -- I'll load up a really simple application.
This is a fake to do list. Now, if I send

145
00:15:07,370 --> 00:15:14,370
it over to Chrome, on my phone, and switch
it, switch the camera here, let me just load

146
00:15:27,500 --> 00:15:34,500
it up... one second... all right. Okay. So
I've -- I've loaded the same exact URL on

147
00:15:41,120 --> 00:15:47,440
both devices, here I've been redirected to
the phone version. Let me do that again. I'll

148
00:15:47,440 --> 00:15:54,440
try loading to desktop version. Sorry. Hmmm...
it's going to work, trust me. Could you guys

149
00:16:33,490 --> 00:16:33,740
turn off your internet?
[chuckling]

150
00:16:33,540 --> 00:16:37,110
>>Boris Smus: I should have done that Steve
Jobs thing.

151
00:16:37,110 --> 00:16:44,110
[ Laughter ]
>>Boris Smus: Thanks. Let's try this one.

152
00:16:58,910 --> 00:17:05,910
The pipes are clogged. It's terrible. Ah,
amazing. Watch this. It's loading. So the

153
00:17:08,439 --> 00:17:15,439
same URL loaded a completely different version,
so let me just show you for comparison here,

154
00:17:18,470 --> 00:17:24,589
the desktop version, the phone version, so
it's useful to still provide a fall-back mechanism

155
00:17:24,589 --> 00:17:29,299
so that you're able to specify a different
version if you prefer it, so device.js does

156
00:17:29,299 --> 00:17:35,169
that as well, and here if I switch to layout
-- landscape mode, I may actually prefer the

157
00:17:35,169 --> 00:17:42,169
tablet version, so if I pick it, then I can
override the default version that was served

158
00:17:42,350 --> 00:17:49,350
to me and this will eventually load, so we
can move on for now. So for more details about

159
00:17:49,509 --> 00:17:56,509
this project, take a look at the GitHub page,
and you're welcome to collaborate with me

160
00:17:56,870 --> 00:18:03,720
on it, so that's the clientside story, so
we've taken a look at both of these approaches,

161
00:18:03,720 --> 00:18:10,720
separate versions and one shared version,
but the client has performance penalties for

162
00:18:10,799 --> 00:18:16,529
doing redirection, so if we do a redirect
that costs somewhere between 100 and 1,000

163
00:18:16,529 --> 00:18:22,539
milliseconds, on the server we can save on
that redirection in some cases, so the only

164
00:18:22,539 --> 00:18:27,620
problem with the server is we have much less
features than we do on the client. We don't

165
00:18:27,620 --> 00:18:33,179
have JavaScript. We don't have media queries.
All we have is a user agent string, and this

166
00:18:33,179 --> 00:18:40,179
string gets sent with every request, so the
server can decide what to do with this. You

167
00:18:40,350 --> 00:18:45,990
can see it's a bit of a mess, so this is what
Chrome for Android user agent string looks

168
00:18:45,990 --> 00:18:52,159
like, and this is pretty much as complicated
as most other browsers. You can see there's

169
00:18:52,159 --> 00:18:58,480
mentions of pretty much every single browser
that has ever existed. I'm exaggerating. But

170
00:18:58,480 --> 00:19:03,980
it's kind of a messy thing to deal with. Let
me show you a couple of tools that can make

171
00:19:03,980 --> 00:19:10,980
this a bit easier. Firstly, let me show you
how pervasive this use is of user agent strings

172
00:19:10,980 --> 00:19:17,980
on the net. So here is YouTube. If I open
Dev Tools, and I'll turn off this screen scaling

173
00:19:18,070 --> 00:19:23,519
device metrics feature that I had before.
I can override the user agent, so why don't

174
00:19:23,519 --> 00:19:30,519
I set it to Galaxy Nexus on Android 402, you'll
notice the device metrics have been set for

175
00:19:30,519 --> 00:19:36,679
me, automatically, based on a little database
that you just send the developer tools, but

176
00:19:36,679 --> 00:19:43,679
when I over -- when I reload the page here,
now I've -- I've used a new -- I've reset

177
00:19:43,740 --> 00:19:49,230
my user agent header and YouTube has sent
me a completely different version of the page,

178
00:19:49,230 --> 00:19:55,190
so just for comparison, this is the mobile
version, and if I reload, I just the regular

179
00:19:55,190 --> 00:20:00,610
YouTube version, it's a completely separate
page, so many, many Web properties use this

180
00:20:00,610 --> 00:20:07,610
service side detection and redirect you without
you even knowing. So how do they do it?

181
00:20:09,679 --> 00:20:16,679
Generally, they have some sort of device database.
These are typically large databases of known

182
00:20:17,309 --> 00:20:22,110
user agents and their capabilities and what
device databases do is they try to find the

183
00:20:22,110 --> 00:20:29,110
closest known UA and give you information
based on your client. So a couple of them

184
00:20:30,870 --> 00:20:36,620
are device applets in WURFL. They have drawbacks
in that they're nonfree for commercial use.

185
00:20:36,620 --> 00:20:42,779
They come in two flavors, typically, one as
an API service, so you can make a request

186
00:20:42,779 --> 00:20:48,779
every time you get a new client connected
and ask a service somewhere else in the Cloud

187
00:20:48,779 --> 00:20:54,509
what that user agent is, or you can set it
up yourself, but it's not that simple to do,

188
00:20:54,509 --> 00:21:01,509
so that's the state-of-the-art right now.
And just to recap this multiple versions idea.

189
00:21:02,289 --> 00:21:08,379
If you're separating your versions upfront,
I would recommend to start with device.js

190
00:21:08,379 --> 00:21:13,419
or some other similar solution in the client,
measure performance overhead, see if that

191
00:21:13,419 --> 00:21:20,419
performance of mobile or of clientside redirection
is too high, and if that penalty is too high,

192
00:21:20,440 --> 00:21:27,440
then switch to user side. So at this point
you're probably thinking this guy is telling

193
00:21:27,769 --> 00:21:34,769
me to create multiple versions of my app.
This is terrible. I'm not going to do this.

194
00:21:35,639 --> 00:21:40,100
And I am probably -- I'm thinking you're probably
using a model view controller or if not, you

195
00:21:40,100 --> 00:21:46,610
should be. So if you don't know what this
pattern is, it is a way to separate the presentation

196
00:21:46,610 --> 00:21:53,220
layer of your code from the structure and
data logic, business logic of your application.

197
00:21:53,220 --> 00:22:00,220
So with a cross-device approach, we can simply
swap out the views, create form factor specific

198
00:22:01,580 --> 00:22:08,580
views and serve them to the various devices
sharing a lot of code. Okay. So that's the

199
00:22:11,049 --> 00:22:15,850
story for multiple versions, single versions.
Let's talk about some technical things about

200
00:22:15,850 --> 00:22:22,850
building a great UI. Firstly, what makes a
great UI?

201
00:22:22,960 --> 00:22:29,960
On the Web, on the mobile Web, I would say
single page sites are examples of that. Some

202
00:22:30,159 --> 00:22:35,870
features of single page sites are limited
zooming so the user gets text that's readable

203
00:22:35,870 --> 00:22:40,889
immediately, they don't have to pinch zoom
around. Fixed headers and footers. So content

204
00:22:40,889 --> 00:22:46,289
that scrolls independently of one another
or having a header placed that's fixed to

205
00:22:46,289 --> 00:22:53,179
the viewport as opposed to content, and smooth
transitions, animations between states as

206
00:22:53,179 --> 00:23:00,179
well as just loading links. The most basic
fundament mobile thing to do is the viewport,

207
00:23:04,139 --> 00:23:09,999
viewport is a virtual viewing area that's
scaled down to your phones or your mobile

208
00:23:09,999 --> 00:23:16,720
device's display, and you can configure this
viewport by setting the metatag called viewport

209
00:23:16,720 --> 00:23:23,440
inside your head, and by default it's set
to something ridiculous, like 980 pixels,

210
00:23:23,440 --> 00:23:30,370
which is wider than most devices. You can
configure it by setting its width to some

211
00:23:30,370 --> 00:23:37,370
value, but if you set it to a fixed value,
say 320 pixels, that won't work on many devices

212
00:23:38,850 --> 00:23:44,749
that aren't 320 pixels wide and you will have
the problem of when you switch from landscape

213
00:23:44,749 --> 00:23:50,190
or from portrait to landscape, text will be
scaled in interesting ways, so the best practice

214
00:23:50,190 --> 00:23:55,419
here, at minimum, at minimum, is to set the
width to be the device width, which evaluates

215
00:23:55,419 --> 00:24:00,850
to be the current width for your device in
its current orientation. And you can see without

216
00:24:00,850 --> 00:24:07,850
a viewport the text is hardly readable on
the left. With a viewport set as I recommend,

217
00:24:08,240 --> 00:24:15,240
it's much more readable and everyone is happy.
We can take this one step further and prevent

218
00:24:15,240 --> 00:24:22,240
zooming entirely to sort of be closer to the
user experience of a mobile -- native mobile

219
00:24:23,389 --> 00:24:28,929
application. We can do this by setting initial
minimum and maximum scale to 1. Just adding

220
00:24:28,929 --> 00:24:33,679
that to the viewport, and know that you should
separate these directives with commas, not

221
00:24:33,679 --> 00:24:40,539
semi colons, a lot of Web samples on the Web
use semi colons unfortunately, that is not

222
00:24:40,539 --> 00:24:46,869
the standard thing to do. Also avoid user
scalable equals no or supplement it with these

223
00:24:46,869 --> 00:24:53,519
media queries, or, sorry, these content directives,
because it's not supported in Chrome -- user

224
00:24:53,519 --> 00:25:00,240
scalable, no, is not supported in Android
-- other Android browsers and some other that

225
00:25:00,240 --> 00:25:07,240
I've tested. So generally speaking, on the
mobile Web, or on any Web, anywhere, really,

226
00:25:09,389 --> 00:25:16,389
we want our animations to be smooth, and what
this means is we want -- we want them to be

227
00:25:16,429 --> 00:25:23,429
approaching the limits of human perception,
so 60 frames per second is the animation refresh

228
00:25:23,820 --> 00:25:30,080
rate above which we can't really tell the
difference, so on mobile devices, this is

229
00:25:30,080 --> 00:25:35,909
hard, because we have CPUs that are far less
powerful than desktops, and because of this

230
00:25:35,909 --> 00:25:39,740
we want to utilize hardware acceleration as
much as possible because these devices come

231
00:25:39,740 --> 00:25:46,740
with pretty powerful CPUs, so an example of
this, to keep an element fixed in relation

232
00:25:47,529 --> 00:25:52,019
to scrolling of content, the old style way
of doing this, you would position something

233
00:25:52,019 --> 00:25:58,070
absolutely, listen to scroll events and then
kind of jitter as you try to reposition your

234
00:25:58,070 --> 00:26:04,690
element every time you scroll. With position
fixed, what you're essentially saying is you're

235
00:26:04,690 --> 00:26:11,690
telling your GPU that this is a separate layer
and composite in a -- composite it separate

236
00:26:13,789 --> 00:26:20,789
from my CPU, and this is a much more, much
less janky experience, and much more smooth.

237
00:26:22,610 --> 00:26:29,610
Similar -- similar tactic applies for scrolling.
Often we want sub element scrolling, so an

238
00:26:29,940 --> 00:26:36,940
example here is Gmail. Or any two pane tablet
application. So we have a list view and a

239
00:26:39,279 --> 00:26:45,409
content view on the right, and we can enable
independent scrolling of elements with overflow

240
00:26:45,409 --> 00:26:52,409
auto, so this is old news. The new thing here
is Webkit overflow scrolling.

241
00:26:53,379 --> 00:26:58,860
This is a custom Webkit property which works
on IOS and Chrome for Android and it essentially

242
00:26:58,860 --> 00:27:05,860
forces hardware accelerated scrolling. Let
me quickly show you a demo here. So I'll send

243
00:27:06,419 --> 00:27:09,539
this -- these are beautiful Chrome ponies.
Chronies?

244
00:27:09,539 --> 00:27:16,539
I'm not sure. So I'm going to load this on
the device. Mobile Web scrolling. I'm going

245
00:27:25,240 --> 00:27:32,240
to load it on both devices. See which one
is faster. It's going to be a race. So you

246
00:27:40,070 --> 00:27:47,070
can watch them race. Anyway, while it's loading,
the idea here is here with overflow hidden,

247
00:27:56,799 --> 00:28:02,429
we see we can't scroll this region at all,
I'm trying to scroll, we can't. Overflow auto

248
00:28:02,429 --> 00:28:08,039
is scrolling, but with this Webkit overflow
scrolling touch edition, we get really, really

249
00:28:08,039 --> 00:28:14,860
fast scrolling on mobile devices, and this
is what I'm trying to show you with this demo,

250
00:28:14,860 --> 00:28:21,860
and unfortunately it doesn't seem to want
to work. That's too bad. Okay, well, hopefully

251
00:28:30,980 --> 00:28:37,980
it will load eventually. Okay. So scrolling.
Often we want to go beyond scrolling and have

252
00:28:46,169 --> 00:28:51,460
transformations of an arbitrary nature, animations,
et cetera, and we still want this to be as

253
00:28:51,460 --> 00:28:58,009
fast as possible. 60 frames a second. A key
thing here is being able to position elements

254
00:28:58,009 --> 00:29:04,580
arbitrarily on the screen. You would use position
absolute to do this, but this isn't slow and

255
00:29:04,580 --> 00:29:10,049
takes the software path -- or this isn't fast,
and takes the software path, so the hardware

256
00:29:10,049 --> 00:29:14,879
accelerated approach, which is very useful
on mobile, is to use the WebKit transform

257
00:29:14,879 --> 00:29:21,700
and the WebKit translate -- I'm sorry, WebKit
transform and translate transformations, this

258
00:29:21,700 --> 00:29:28,200
will trigger hardware accelerated rendering,
especially with translate 3D, this gives a

259
00:29:28,200 --> 00:29:34,860
hint to the GPU that, hey, you're doing something
fancy and probably GPU mode should be enabled.

260
00:29:34,860 --> 00:29:40,360
You can of course also do rotations and scales
in this fashion, and it looks like our demo

261
00:29:40,360 --> 00:29:45,850
has loaded, which is great, so let me switch
back to the projector here for both screens.

262
00:29:45,850 --> 00:29:52,850
We have our beautiful ponies, as you would
expect. As I scroll hidden -- attempt to scroll

263
00:29:53,649 --> 00:29:59,409
the hidden view, nothing works. Auto, you
can see it's scrolling. But it's kind of janky,

264
00:29:59,409 --> 00:30:06,409
I don't know if you can notice that on the
projector. Compare that to this.

265
00:30:06,600 --> 00:30:07,840
So this is what you get.
[ Laughter ]

266
00:30:07,840 --> 00:30:11,739
>>Boris Smus: Thanks, guys, this is what you
get with the WebKit overflowing scrolling

267
00:30:11,739 --> 00:30:18,739
touch. So on -- on Chrome for Android, this
is the -- basically the smoothness that you

268
00:30:19,200 --> 00:30:26,200
get, on iOS. You end up with -- with bounceback
effects. And inertial scrolling as well.

269
00:30:27,960 --> 00:30:34,960
So we'll do questions after.
So as I go into the next section, I'm going

270
00:30:35,929 --> 00:30:41,600
to preload this.
So in addition to regular transforms, we can

271
00:30:41,600 --> 00:30:47,690
do more advanced things. As I alluded, we
can do 3D transformations, we can apply perspective

272
00:30:47,690 --> 00:30:54,659
as well. Even arbitrary matrices, as in this
example here, if you are into linear algebra.

273
00:30:54,659 --> 00:31:01,659
And we can let CSS interpolate between the
various animation states by using the transition

274
00:31:02,470 --> 00:31:09,320
property and here we are transitioning between
-- or say -- sorry, we're transitioning the

275
00:31:09,320 --> 00:31:14,419
transform property, we're specifying its length
of time, one second, and an easing function

276
00:31:14,419 --> 00:31:21,419
as well. So these -- both the transition and
the transform property need vendor prefixes.

277
00:31:23,919 --> 00:31:30,919
So unfortunately the demo here is still loading.
But ... I'm gonna ... just gonna hope that

278
00:31:43,109 --> 00:31:45,889
it will load eventually.
Okay. We'll get back to that. We'll have reason

279
00:31:45,889 --> 00:31:50,989
to revisit.
So I talked a lot about output here. Let's

280
00:31:50,989 --> 00:31:57,989
talk about input. So for decades, 20, 30 years,
more, more than that, this has been the input

281
00:32:00,029 --> 00:32:07,029
mode of computing. Mouse and keyboard. And
for quite a long time, even into mobile, we've

282
00:32:09,559 --> 00:32:16,230
had very similar input devices. This is a
pretty new Blackberry with keyboard and essentially

283
00:32:16,230 --> 00:32:23,230
a mouse-like implement.
So the current state is much more interesting.

284
00:32:24,409 --> 00:32:29,129
Multi-touch pretty much changed the game completely.
And one thing that I want to emphasize here

285
00:32:29,129 --> 00:32:36,049
is touch is not the same as mouse. It's completely
different. There's no hover state in touch.

286
00:32:36,049 --> 00:32:41,080
There are multiple touch points. Input is
far less precise. You don't get the pixel

287
00:32:41,080 --> 00:32:46,879
accuracy of a mouse. And going forward, fingers
aren't just coordinates, but they also have

288
00:32:46,879 --> 00:32:53,879
shape and in the future we have all sorts
of interesting possibilities. Pressure input,

289
00:32:54,769 --> 00:33:00,779
haptic feedback, et cetera. Touch interface,
as I'm sure you are all familiar with, have

290
00:33:00,779 --> 00:33:05,009
essential building blocks. These are very
simple gestures. Well, they range from simple

291
00:33:05,009 --> 00:33:10,779
ones like tap and double tap to more complex
one like pinch-zoom and rotation and we can

292
00:33:10,779 --> 00:33:17,779
do all of these things on the Web using the
touch events. So here we have touchmove, touchstart

293
00:33:18,009 --> 00:33:21,269
and touchend.
These are pretty similar to their mouse equivalents,

294
00:33:21,269 --> 00:33:28,269
except instead of single coordinates, we have
lists of touches on the screen. There's a

295
00:33:28,369 --> 00:33:34,230
spec and you can read more about this.
So one of the first things that you'll notice

296
00:33:34,230 --> 00:33:41,200
is the browser has its own touch behavior.
So like I mentioned earlier, pinch-zoom is

297
00:33:41,200 --> 00:33:47,549
one of them, scrolling is another, tap switching
as you probably saw in the keynote this morning

298
00:33:47,549 --> 00:33:52,239
between tabs when you slide out from the side
of the bevel on some browsers and you can

299
00:33:52,239 --> 00:33:59,019
override some of these behaviors using the
event prevent default call in JavaScript.

300
00:33:59,019 --> 00:34:05,899
In IE it's a little bit different, you can
specify touch action none, this is IE 10,

301
00:34:05,899 --> 00:34:11,639
and you can even specify which specific kinds
of interactions to disable. So you can say

302
00:34:11,639 --> 00:34:18,639
enable no touch interactions by default or
you can say only enable pinch-zooms or only

303
00:34:19,450 --> 00:34:25,160
enable scrolls.
Touch performance is an interesting topic

304
00:34:25,160 --> 00:34:32,160
because as a Web developer, if you are not
creating touch specific input, you end up

305
00:34:32,220 --> 00:34:37,160
having events that are very heavily delayed.
The reason for this is, for example, if you

306
00:34:37,160 --> 00:34:44,160
do a double tap, the browser needs to decide
if it's a zoom gesture or if it's a click.

307
00:34:44,360 --> 00:34:49,390
So it waits for 300 milliseconds to wait for
that second tap and then if there's no other

308
00:34:49,390 --> 00:34:53,640
tap, it emits a click.
So this is not great, 300 milliseconds is

309
00:34:53,640 --> 00:34:59,370
definitely visible. You can see the delay
and the -- the workaround for this is to use

310
00:34:59,370 --> 00:35:05,640
touchend. Touchend will fire right away. As
soon as you release your finger from the screen

311
00:35:05,640 --> 00:35:10,570
and there's a nice guide about this on Google
developer docs.

312
00:35:10,570 --> 00:35:17,570
The other consideration here is with multi-touch,
events often come in very quickly, much faster

313
00:35:18,110 --> 00:35:24,350
than 60 frames per second. If you are touching
your screen with many fingers, every single

314
00:35:24,350 --> 00:35:29,770
finger will fire at whatever that rate is.
And if you draw, as soon as you handle the

315
00:35:29,770 --> 00:35:36,770
event, you will end up just having too many
things rendering at the same time and this

316
00:35:36,830 --> 00:35:43,830
will be very bad for your performance.
So the solution for this is to create separate

317
00:35:44,170 --> 00:35:51,170
handlers for input handling and create a separate
animation thread. Or animation timer in this

318
00:35:51,430 --> 00:35:54,100
case.
So here I'm doing exactly that. I've got a

319
00:35:54,100 --> 00:36:01,100
set interval call and the touch rendering
code goes here. We can do even better in Chrome

320
00:36:01,860 --> 00:36:08,860
for Android and Chrome and Safari and probably
other browsers, we just requestAnimationFrame.

321
00:36:09,070 --> 00:36:15,950
What this does is it's essentially a polite
request to the browser for animation frame

322
00:36:15,950 --> 00:36:22,950
so it aims to -- to fire roughly 60 to -- 60
times a second. But if something is overloading

323
00:36:24,810 --> 00:36:30,190
the -- the machine or the device, then it
scales back in an elegant way and you can

324
00:36:30,190 --> 00:36:35,980
get as smooth of an animation as you possible
can.

325
00:36:35,980 --> 00:36:40,320
So with this, let me show you an example of
that.

326
00:36:40,320 --> 00:36:46,260
Style switch over. The demo is already loaded.
That's awesome!

327
00:36:46,260 --> 00:36:51,980
So for this particular demo, I'm using a requestAnimationFrame
and the transitions and transforms that I

328
00:36:51,980 --> 00:36:58,980
talked about earlier, to have this pretty
smooth transition experience between multiple

329
00:37:00,380 --> 00:37:06,510
screens. So you can see it follows my finger
pretty closely. And when I let go, the transition

330
00:37:06,510 --> 00:37:13,510
will fire. And the content just shows up.
So this is using requestAnimationFrame WebKit

331
00:37:14,170 --> 00:37:20,600
transforms and transitions.
I also have another demo that I'm going to

332
00:37:20,600 --> 00:37:27,600
start loading now.
And I'll get to that in a second as soon as

333
00:37:32,180 --> 00:37:37,080
it loads.
So let's talk about some of the problems with

334
00:37:37,080 --> 00:37:44,070
-- with touch input.
The first is how do we handle both gracefully?

335
00:37:44,070 --> 00:37:51,070
Right? What if we want to support both?
This right now is not very pleasant. So what

336
00:37:51,790 --> 00:37:58,170
we end up with is two essentially completely
different input methods. Mouse and touch.

337
00:37:58,170 --> 00:38:04,050
And what we might do is we can extract the
positions of the relevant input. And then

338
00:38:04,050 --> 00:38:10,610
just relay them to a common handler. This
-- eh ... it's unnecessary boilerplate. It's

339
00:38:10,610 --> 00:38:16,820
not something that you want to do every single
time. So instead -- well, we'll talk about

340
00:38:16,820 --> 00:38:21,330
solutions to this in a second.
The other problem before I talk about solutions,

341
00:38:21,330 --> 00:38:25,820
is gestures are difficult. You saw that list
of gestures that I showed you that are common

342
00:38:25,820 --> 00:38:32,410
for mobile devices, but doing such a thing
without gesture events, which are only available

343
00:38:32,410 --> 00:38:39,410
on iOS, is pretty hard. So here's a pinch-zoom
snippet that recognizes the pinch-zoom gesture.

344
00:38:40,830 --> 00:38:47,830
It's a lot of code. And doing this every time
you want to pinch-zoom just is not reasonable.

345
00:38:48,140 --> 00:38:55,140
So Microsoft has a -- has an input model that
they're planning on using for metro. It's

346
00:38:59,310 --> 00:39:06,310
called MSPointer. And the idea is to consolidate
input, to consolidate mouse, touch and pointer

347
00:39:06,520 --> 00:39:11,640
into one single type.
And, of course, you can still distinguish

348
00:39:11,640 --> 00:39:18,170
between mouse and touch with -- with an event
property and it's a really nice idea. I like

349
00:39:18,170 --> 00:39:22,430
it a lot.
The problem is, with the current proposal,

350
00:39:22,430 --> 00:39:26,370
it's essentially just another input mechanism
to deal with. So now you have the mouse handler,

351
00:39:26,370 --> 00:39:33,370
the touch handler and the MSPointer handler
and it's just not necessarily great.

352
00:39:33,460 --> 00:39:39,860
So pointer.js is a project that I worked on
to try to consolidate this input problem between

353
00:39:39,860 --> 00:39:45,710
browsers. Using a similar idea as MSPointer
events except to take all of these different

354
00:39:45,710 --> 00:39:52,410
event models and make an abstraction layer
around them to make it really easy for developers.

355
00:39:52,410 --> 00:39:59,410
So let me show you this in action.
And here I have a -- a space shooter. And

356
00:40:00,990 --> 00:40:07,160
actually let me show you this on the device
instead. So this is a -- this is a demo that

357
00:40:07,160 --> 00:40:13,570
was created by a friend of mine called Seb
and you can see it's essentially just a -- a

358
00:40:13,570 --> 00:40:18,130
space shooter thing demo. It's kind of neat
because you can place your control anywhere

359
00:40:18,130 --> 00:40:23,240
you want and then just shoot on the -- anywhere
on the right side of the screen.

360
00:40:23,240 --> 00:40:30,240
So this is using pointerevents. One of the
benefits of this, it was initially using just

361
00:40:30,600 --> 00:40:37,600
touchevents. So on the desktop nothing would
work at all. With pointerevents, though, I

362
00:40:37,910 --> 00:40:44,910
can have essentially the same experience in
-- on both mouse and touch input. So this

363
00:40:45,410 --> 00:40:52,410
is a quick and straightforward pointer example.
Pointer.js also aspires to have gesture recognizers

364
00:40:56,070 --> 00:41:00,920
on top of the consolidated input model. For
more details about this, check out the project

365
00:41:00,920 --> 00:41:07,920
page on GitHub.
So let me quickly talk about mobile Web development.

366
00:41:14,900 --> 00:41:21,900
One second.
So I've been trying to show you some features

367
00:41:24,750 --> 00:41:31,750
of the Chrome developer tools as we go. And,
of course, the easiest path to getting started

368
00:41:32,240 --> 00:41:36,960
with mobile development is to emulate it on
the desktop. You don't have to deal with extra

369
00:41:36,960 --> 00:41:42,570
devices. You don't have any of that headache
of trying to -- having to touch around all

370
00:41:42,570 --> 00:41:49,280
of the time. So it's nice. And I have shown
you how to emulate screen size, how to override

371
00:41:49,280 --> 00:41:56,280
the User-Agent string and let me just show
you one more thing ... 
this is part of the mobile Chrome experiments

372
00:42:03,780 --> 00:42:08,070
that you may or may not have seen. If you
haven't seen it, check it out, it's on the

373
00:42:08,070 --> 00:42:12,830
second floor in the Chrome booth. So this
is a Chrome experiment. And it's essentially

374
00:42:12,830 --> 00:42:18,850
a scroll view. With a twist.
So to show you the twist, I have to scroll,

375
00:42:18,850 --> 00:42:25,680
but you'll notice here that it's using touchevents.
And when I try to scroll, nothing works. So

376
00:42:25,680 --> 00:42:32,680
let me open up devtools.
And show you a cool feature that's very useful.

377
00:42:33,380 --> 00:42:40,380
I can emulate touchevents. So what this will
do, when I reload the page, and switch back

378
00:42:41,500 --> 00:42:48,280
to it, now when I mouse around these mouse
events are being translated into touches,

379
00:42:48,280 --> 00:42:53,210
so instead of a mouse down I get a touch start,
et cetera. You can see this is using again

380
00:42:53,210 --> 00:43:00,210
requestAnimationFrame and Hakim here has a
whole bunch of cool effects to just give you

381
00:43:00,350 --> 00:43:06,730
a sense of how performant you can have these
nice transitions. On both Chrome and -- it

382
00:43:06,730 --> 00:43:13,730
works just great on Chrome for Android as
well. You should check it out in the Chrome

383
00:43:13,750 --> 00:43:19,380
experiments booth.
So that's -- that's some Chrome devtools features.

384
00:43:19,380 --> 00:43:26,380
You can also emulate multi-touch events on
the Mac. And this is a fun little project

385
00:43:26,830 --> 00:43:33,830
that I worked on. It requires a bit of setup.
But once you've got it set up, then you can

386
00:43:36,430 --> 00:43:43,160
-- you can essentially create multi-touch
prototyping, you can do multi-touch prototyping

387
00:43:43,160 --> 00:43:49,490
on any Mac with a magic touch track pad. So
here you can see I've got a single touch that's

388
00:43:49,490 --> 00:43:55,170
coming from my Mac track pad and I can do
multiple touches, too.

389
00:43:55,170 --> 00:44:00,320
And I can do this arbitrarily. So it's kind
of cool if you're doing complex multi-touch

390
00:44:00,320 --> 00:44:03,210
interactions. This game is just like a fruit
ninja clone that I whipped up, except with

391
00:44:03,210 --> 00:44:10,210
browsers. It doesn't really make sense. You
hit a blink tag and you get a 406. [Laughter

392
00:44:10,540 --> 00:44:14,870
]
>>Boris Smus: Right? Anyway, so that's multi-touch.

393
00:44:14,870 --> 00:44:21,430
And, of course, you want to test on your device,
ultimately. You can do these emulations, you

394
00:44:21,430 --> 00:44:25,980
can use these tricks, but ultimately you need
to test on your device. And Chrome for Android

395
00:44:25,980 --> 00:44:31,750
has great support for remote debugging, and
we have plenty of resources about that. In

396
00:44:31,750 --> 00:44:34,870
the interest of time I won't burden you, but
you should check it out. And I will make these

397
00:44:34,870 --> 00:44:41,870
slides available afterward.
So thank you all for listening. We've got

398
00:44:41,980 --> 00:44:47,460
some time for questions.
And, um ... so, yeah, right, we have microphones

399
00:44:47,460 --> 00:44:52,420
on both sides. So feel free to ask anything
and I'll be available in the Chrome area as

400
00:44:52,420 --> 00:44:59,420
well afterward.
[ Applause ]

401
00:45:01,940 --> 00:45:06,950
>>> You -- I guess the mic is off. There we
go.

402
00:45:06,950 --> 00:45:09,990
>>Boris Smus: I think it's on.
>>> You showed examples of how to get the

403
00:45:09,990 --> 00:45:15,430
GPU hardware acceleration enabled. Why don't
those turn on by defaults? Why do you have

404
00:45:15,430 --> 00:45:22,430
to play tricks to get it to work reasonably?
>>Boris Smus: Right, this is -- I agree -- a

405
00:45:23,160 --> 00:45:30,160
problem that we are tackling currently. So
the Chrome GPU team is working very hard to

406
00:45:30,190 --> 00:45:36,630
try to make these -- to try to make more of
the rendering part of the GPU pipeline, essentially.

407
00:45:36,630 --> 00:45:41,950
So like you are saying, part of the problem
is you don't really know which tricks will

408
00:45:41,950 --> 00:45:47,330
render GPU mode, which ones won't, it's very
implicit. And generally, of course, the whole

409
00:45:47,330 --> 00:45:51,230
rendering path should be done on the GPU as
much as possible. So GPU team is definitely

410
00:45:51,230 --> 00:45:55,850
looking at this and trying to optimize it
as much as possible. It's on my radar.

411
00:45:55,850 --> 00:46:01,980
>>> All right.
>>Boris Smus: Yes, go ahead.

412
00:46:01,980 --> 00:46:08,230
>>> If you are trying to emulate more of a
mobile native experience, the address bar

413
00:46:08,230 --> 00:46:13,180
gets in the way or -- and is there anything
more elegant than just scroll one pixel when

414
00:46:13,180 --> 00:46:17,590
your app starts up?
>>Boris Smus: Um, yeah. So -- right, as you

415
00:46:17,590 --> 00:46:23,570
are saying, the current hacks are around using
Scroll 2, which is a JavaScript function that

416
00:46:23,570 --> 00:46:28,240
you just call and say scroll to the top and
in most browsers, in some browsers, it will

417
00:46:28,240 --> 00:46:35,240
hide the location bar. We're working on evaluating
what a full screen API might look like. So

418
00:46:36,570 --> 00:46:42,160
this is an example of there's an open Web
API that lets you make a browser go into full-screen

419
00:46:42,160 --> 00:46:47,630
mode. So this would be a nice application.
That said, right now in Chrome for Android,

420
00:46:47,630 --> 00:46:54,630
we have an Omnibox that's always there. There's
good reasons for that as well. Just if you

421
00:46:54,670 --> 00:47:00,180
have your URL bar always present, it's an
indication that you are in the browser, you

422
00:47:00,180 --> 00:47:05,440
are not being phished, you know exactly where
you are, and it's also very easy to navigate

423
00:47:05,440 --> 00:47:11,950
away, like, to any other page.
Oftentimes on iOS I'll have hard time getting

424
00:47:11,950 --> 00:47:18,080
back to the URL bar, especially if someone
is overriding the default scrolling behavior.

425
00:47:18,080 --> 00:47:21,100
>>> I see.
>>Boris Smus: It's hard to get back. So ... but,

426
00:47:21,100 --> 00:47:26,540
yeah, I agree, it's totally a hack.
>>> Should be a new GitHub project for you.

427
00:47:26,540 --> 00:47:30,640
Fullscreen.js --
>>Boris Smus: Thanks. Yes?

428
00:47:30,640 --> 00:47:34,680
>>> I was just wondering, you were always
saying it's important on iOS and on Chrome

429
00:47:34,680 --> 00:47:38,970
for Android. What about stock browser that
gets shipped?

430
00:47:38,970 --> 00:47:44,630
>>Boris Smus: Right. So the stock browser
on Ice Cream Sandwich is actually quite good.

431
00:47:44,630 --> 00:47:51,630
And there's a lot of -- there are many features
that are supported on it that I discussed

432
00:47:51,950 --> 00:47:58,950
today. Don't quote me, I believe requestAnimationFrame
maybe. Anyway the inertial scrolling certainly

433
00:47:59,900 --> 00:48:03,160
is.
So -- yeah. Thanks.

434
00:48:03,160 --> 00:48:10,160
>>> I was curious. So we provide a third-party
widget that you can embed on your page. So

435
00:48:12,440 --> 00:48:19,130
we don't have control over things like the
meta tags, some of the stuff that you showed.

436
00:48:19,130 --> 00:48:22,900
I'm kind of curious, we were thinking of using
the new implementation of position fixed to

437
00:48:22,900 --> 00:48:26,410
allow our chat box to show up.
>>Boris Smus: Yep.

438
00:48:26,410 --> 00:48:30,890
>>> But you don't get kind of zoom fixed on
it. So when you zoom in, then like eventually

439
00:48:30,890 --> 00:48:34,310
this position fix thing just takes over the
whole screen.

440
00:48:34,310 --> 00:48:38,830
>>Boris Smus: Yep.
>>> Anything new that we could take advantage

441
00:48:38,830 --> 00:48:41,670
of?
>>Boris Smus: Yeah, it's a good question.

442
00:48:41,670 --> 00:48:47,030
Position fixed is a little interesting if
you don't have control over the fixed viewport.

443
00:48:47,030 --> 00:48:51,990
Because it -- it actually varies quite a bit
in its behavior depending on the browser.

444
00:48:51,990 --> 00:48:58,540
So, yeah, I think you have a pretty unique
case in that you're like a third period JavaScript

445
00:48:58,540 --> 00:49:03,410
plug-in. I can't think of anything off the
top of my head that you could do that with.

446
00:49:03,410 --> 00:49:07,190
Maybe we should talk offline.
>>> Sure thing.

447
00:49:07,190 --> 00:49:13,990
>>Boris Smus: Great, thanks. All right? No
other questions? Find me later, I'll be hanging

448
00:49:13,990 --> 00:49:15,160
out in the Chrome booth.

