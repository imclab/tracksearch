1
00:00:01,934 --> 00:00:03,234
Ager: So my name
is Mads Ager.

2
00:00:03,234 --> 00:00:05,167
I'm a software engineer
at Google.

3
00:00:05,167 --> 00:00:08,033
And I work
on the V8 JavaScript engine.

4
00:00:08,033 --> 00:00:12,434
And this talk is going
to be about the internals of V8.

5
00:00:12,434 --> 00:00:16,167
So what did we do,
uh, to make V8 fast

6
00:00:16,167 --> 00:00:20,601
and what were our design,
uh, decisions when making V8?

7
00:00:20,601 --> 00:00:22,267
So here's the agenda
of the talk.

8
00:00:22,267 --> 00:00:26,934
So the main part of the talk
will be about the design goals

9
00:00:26,934 --> 00:00:30,534
and the overall goals
that we had for V8.

10
00:00:30,534 --> 00:00:32,834
And, um, the internals.

11
00:00:32,834 --> 00:00:34,467
So what did we actually do?

12
00:00:34,467 --> 00:00:38,901
Uh, what are the techniques
that we used to make V8 fast?

13
00:00:40,534 --> 00:00:44,234
Um, and that involves
things like hidden classes,

14
00:00:44,234 --> 00:00:48,367
uh, native code generation
using inline caching,

15
00:00:48,367 --> 00:00:50,968
and precise generational
garbage collection.

16
00:00:50,968 --> 00:00:52,868
So that'll be the main part
of the talk

17
00:00:52,868 --> 00:00:55,133
where I explain
these--these things.

18
00:00:55,133 --> 00:00:57,767
So, um, after that,
I'll tell you something

19
00:00:57,767 --> 00:01:00,367
about a couple of recent
developments in V8.

20
00:01:00,367 --> 00:01:02,033
So the first one
is that we implemented

21
00:01:02,033 --> 00:01:04,234
a new JavaScript regular
expression engine

22
00:01:04,234 --> 00:01:05,834
completely from scratch.

23
00:01:05,834 --> 00:01:07,300
And the other one
is that we've built

24
00:01:07,300 --> 00:01:08,601
a new compile
infrastructure.

25
00:01:08,601 --> 00:01:10,067
I'm just going
to briefly mention those

26
00:01:10,067 --> 00:01:11,801
and tell you a bit
about them.

27
00:01:11,801 --> 00:01:13,467
Um, and then I'll go
into something

28
00:01:13,467 --> 00:01:16,534
that, um, I think
is really important.

29
00:01:16,534 --> 00:01:19,567
Uh, and I've called it
object heap scalability here.

30
00:01:19,567 --> 00:01:21,367
Or JavaScript scalability.

31
00:01:21,367 --> 00:01:24,501
And that's all about how well
your JavaScript engine deals

32
00:01:24,501 --> 00:01:27,067
with running really,
really big web applications

33
00:01:27,067 --> 00:01:29,067
where you have
a lot of objects.

34
00:01:29,067 --> 00:01:31,601
Uh, and therefore,
extra pressure

35
00:01:31,601 --> 00:01:33,701
on your memory management
system.

36
00:01:33,701 --> 00:01:35,300
Um, and I think that
this is really important.

37
00:01:35,300 --> 00:01:38,934
And I think that it has been
underemphasized so far.

38
00:01:38,934 --> 00:01:41,434
Um, so I'm going to spend
a bit of time

39
00:01:41,434 --> 00:01:42,801
talking about that.

40
00:01:42,801 --> 00:01:44,300
And then at the end,
I'm going to just,

41
00:01:44,300 --> 00:01:48,000
uh, tell you a bit about some
of the performance bottlenecks

42
00:01:48,000 --> 00:01:51,167
that we have in V8 right now,
uh, which will give you

43
00:01:51,167 --> 00:01:53,567
sort of an indication
of the kind of things

44
00:01:53,567 --> 00:01:56,100
that we like to, uh,
to work on in V8

45
00:01:56,100 --> 00:02:00,133
to make it even faster.

46
00:02:00,133 --> 00:02:01,801
Okay, so for this talk,

47
00:02:01,801 --> 00:02:04,868
the first question is really
why did Google want

48
00:02:04,868 --> 00:02:08,067
to build a new JavaScript
engine?

49
00:02:08,067 --> 00:02:10,067
And the answer
is pretty simple.

50
00:02:10,067 --> 00:02:12,534
So we believe that

51
00:02:12,534 --> 00:02:15,000
in order
to build, uh, the next wave

52
00:02:15,000 --> 00:02:18,000
of big,
uh, web applications,

53
00:02:18,000 --> 00:02:21,000
you need better JavaScript
performance.

54
00:02:21,000 --> 00:02:24,834
Um, and at the time
when the V8 project started,

55
00:02:24,834 --> 00:02:26,634
the existing
JavaScript engines

56
00:02:26,634 --> 00:02:28,901
were not very fast.

57
00:02:28,901 --> 00:02:31,400
So basically
they were all interpreters

58
00:02:31,400 --> 00:02:34,968
working on abstract syntax trees
or on bytecodes.

59
00:02:34,968 --> 00:02:38,567
And they had, uh, poor memory
management systems,

60
00:02:38,567 --> 00:02:41,000
which led
to big pause times,

61
00:02:41,000 --> 00:02:44,467
um, and maybe even,
uh, memory leaks.

62
00:02:44,467 --> 00:02:47,801
Um, so we wanted
to try to change this picture.

63
00:02:47,801 --> 00:02:52,000
We wanted to try to push,
uh, JavaScript performance.

64
00:02:52,000 --> 00:02:53,934
Uh, and we thought that
the best way to do that

65
00:02:53,934 --> 00:02:55,968
was to build a completely
new JavaScript engine

66
00:02:55,968 --> 00:02:58,801
from scratch so that we could do
our own designs

67
00:02:58,801 --> 00:03:01,868
and start completely
from scratch.

68
00:03:01,868 --> 00:03:05,100
Um, so the overall goal
for V8

69
00:03:05,100 --> 00:03:07,567
is to push the performance bar
for JavaScript.

70
00:03:07,567 --> 00:03:10,434
Not only for Google Chrome
and for V8,

71
00:03:10,434 --> 00:03:13,033
but we wanted to kind of try
to push the industry

72
00:03:13,033 --> 00:03:16,334
and see if we can get, uh,
better JavaScript performance

73
00:03:16,334 --> 00:03:17,834
in browsers in general,

74
00:03:17,834 --> 00:03:19,334
which will benefit
all of us.

75
00:03:19,334 --> 00:03:21,133
It'll benefit Google
because we can do better

76
00:03:21,133 --> 00:03:22,467
web applications.

77
00:03:22,467 --> 00:03:23,968
And it'll benefit
the users as well

78
00:03:23,968 --> 00:03:27,834
because, well, users like
web applications as well.

79
00:03:30,501 --> 00:03:34,634
So we wanted to build
a really fast JavaScript engine.

80
00:03:34,634 --> 00:03:37,501
So why is that a challenge?

81
00:03:37,501 --> 00:03:41,701
Well, JavaScript is a very,
very dynamic language.

82
00:03:41,701 --> 00:03:44,734
So objects are basically
just HashMaps.

83
00:03:44,734 --> 00:03:47,901
So you can add and remove
properties,

84
00:03:47,901 --> 00:03:51,400
um, to and from objects
on the fly

85
00:03:51,400 --> 00:03:52,901
in any order you like.

86
00:03:52,901 --> 00:03:55,000
And you have,
uh, no type structure.

87
00:03:55,000 --> 00:03:58,067
So if you want to do,
uh, a property lookup

88
00:03:58,067 --> 00:04:00,200
on an object in JavaScript,

89
00:04:00,200 --> 00:04:03,167
you don't know anything
statically about the object.

90
00:04:03,167 --> 00:04:04,400
So if you have an object,

91
00:04:04,400 --> 00:04:06,267
you want to search
for the X-property,

92
00:04:06,267 --> 00:04:07,267
you have to do exactly that.

93
00:04:07,267 --> 00:04:08,601
You have to search.

94
00:04:08,601 --> 00:04:10,100
So you have to look
in your HashMap.

95
00:04:10,100 --> 00:04:11,400
If it's not there,

96
00:04:11,400 --> 00:04:13,634
you need to traverse
the prototype chain

97
00:04:13,634 --> 00:04:14,667
and look for it there.

98
00:04:14,667 --> 00:04:16,033
And that's, like,
really slow.

99
00:04:16,033 --> 00:04:17,934
So if you compare that
to static,

100
00:04:17,934 --> 00:04:19,868
object-oriented languages

101
00:04:19,868 --> 00:04:23,467
where you have a notion of type,
where you have classes,

102
00:04:23,467 --> 00:04:25,667
if you do a property load
in a language

103
00:04:25,667 --> 00:04:28,100
where you have a notion
of class,

104
00:04:28,100 --> 00:04:31,667
well, then the class tells you
the layout of your object.

105
00:04:31,667 --> 00:04:34,067
So if you want to access
an X-property

106
00:04:34,067 --> 00:04:36,067
on an object
that has a certain class,

107
00:04:36,067 --> 00:04:38,334
then the class tells you
the index

108
00:04:38,334 --> 00:04:40,934
in your object
for that property.

109
00:04:40,934 --> 00:04:42,968
So you can generate
just a few assembly line--

110
00:04:42,968 --> 00:04:47,133
assembly instructions
that will load your property.

111
00:04:47,133 --> 00:04:51,734
In JavaScript, if you just
do it, uh, like naively--

112
00:04:51,734 --> 00:04:54,334
implement JavaScript--
then you'll have a full search

113
00:04:54,334 --> 00:04:57,467
of--of a number
of HashMaps in a chain.

114
00:04:57,467 --> 00:04:59,534
And that's really slow.

115
00:04:59,534 --> 00:05:03,934
Um, right, so JavaScript
is highly dynamic.

116
00:05:03,934 --> 00:05:06,033
You can add properties
to objects.

117
00:05:06,033 --> 00:05:08,300
You can remove properties
from objects.

118
00:05:08,300 --> 00:05:11,934
Um, and, uh,
you can actually change

119
00:05:11,934 --> 00:05:15,634
prototype chains
as well dynamically.

120
00:05:15,634 --> 00:05:17,267
So you can change basically
everything,

121
00:05:17,267 --> 00:05:19,467
uh, in your program
on the fly.

122
00:05:19,467 --> 00:05:22,801
Also, JavaScript has a couple
of language features,

123
00:05:22,801 --> 00:05:27,834
um, that--that could
give you trouble as well.

124
00:05:27,834 --> 00:05:29,567
So one of them is eval.

125
00:05:29,567 --> 00:05:33,467
So eval is a function
that you can call with a string

126
00:05:33,467 --> 00:05:37,067
to evaluate that string
as JavaScript code.

127
00:05:37,067 --> 00:05:38,801
And that's actually
not so bad.

128
00:05:38,801 --> 00:05:41,100
The problem with it is that
it can also change

129
00:05:41,100 --> 00:05:43,067
the calling context.

130
00:05:43,067 --> 00:05:46,334
And that means that,
um, if you're trying

131
00:05:46,334 --> 00:05:48,601
to implement JavaScript,

132
00:05:48,601 --> 00:05:50,667
you really want to have
some scope information.

133
00:05:50,667 --> 00:05:52,167
So if you look for--

134
00:05:52,167 --> 00:05:54,834
if you access
a property X somewhere,

135
00:05:54,834 --> 00:05:57,667
you want to be able to--to see
basically in your scopes

136
00:05:57,667 --> 00:05:59,167
where is X declared?

137
00:05:59,167 --> 00:06:01,701
But if you have a call to eval,
basically, you don't know

138
00:06:01,701 --> 00:06:04,300
because eval can introduce
new bindings dynamically.

139
00:06:04,300 --> 00:06:06,501
So you could introduce
a new X variable

140
00:06:06,501 --> 00:06:09,434
in, uh, the context
where you're calling eval.

141
00:06:09,434 --> 00:06:11,000
So basically, you just have
to give up

142
00:06:11,000 --> 00:06:13,667
and say, statically,
I don't know.

143
00:06:13,667 --> 00:06:17,234
Um, and there's similar issues
with, uh, "with" statements

144
00:06:17,234 --> 00:06:18,634
in JavaScript.

145
00:06:18,634 --> 00:06:21,067
So "with" statements are used
to introduce a new object

146
00:06:21,067 --> 00:06:22,801
in your scope chain.

147
00:06:22,801 --> 00:06:25,434
So if you want easy access
to all the properties

148
00:06:25,434 --> 00:06:26,868
on the document object,

149
00:06:26,868 --> 00:06:30,300
you can say with document
and then have a blog of code,

150
00:06:30,300 --> 00:06:34,133
where if you just write a name
like "write"

151
00:06:34,133 --> 00:06:37,000
that will be looked up
in the document object

152
00:06:37,000 --> 00:06:40,534
so that will actually be
document.write.

153
00:06:40,534 --> 00:06:41,834
And that's all fine.

154
00:06:41,834 --> 00:06:46,167
But if you want to, uh,
have scope information again,

155
00:06:46,167 --> 00:06:48,267
you have to give up
inside of a "with" statement

156
00:06:48,267 --> 00:06:50,133
because you don't know.

157
00:06:50,133 --> 00:06:52,367
Because it might look
like a variable is declared

158
00:06:52,367 --> 00:06:53,968
and out of scope,

159
00:06:53,968 --> 00:06:56,567
but, uh, dynamically,
you might introduce an object

160
00:06:56,567 --> 00:06:58,501
with your "with" statement

161
00:06:58,501 --> 00:07:00,000
that has that property name
as well.

162
00:07:00,000 --> 00:07:01,701
And that's the one
that you need to get.

163
00:07:01,701 --> 00:07:04,767
So overall,
JavaScript is very dynamic.

164
00:07:04,767 --> 00:07:07,234
Um, and that makes it a bit
of a challenge

165
00:07:07,234 --> 00:07:10,968
to implement it efficiently.

166
00:07:10,968 --> 00:07:13,334
So let's talk
about what we did for V8

167
00:07:13,334 --> 00:07:16,667
and which design decisions
we took.

168
00:07:16,667 --> 00:07:21,467
So the goal for V8 was to create
a JavaScript engine

169
00:07:21,467 --> 00:07:26,200
that would make, um, large
object-oriented applications

170
00:07:26,200 --> 00:07:27,901
perform well.

171
00:07:27,901 --> 00:07:29,801
So if you have large
object-oriented applications,

172
00:07:29,801 --> 00:07:31,400
you're going to use
abstractions.

173
00:07:31,400 --> 00:07:33,067
And if you use abstractions,

174
00:07:33,067 --> 00:07:34,834
you're going to have a lot
of property accesses

175
00:07:34,834 --> 00:07:37,567
and you're going to have
a lot of--of function calls.

176
00:07:37,567 --> 00:07:40,534
And you're going to have
a lot of objects.

177
00:07:40,534 --> 00:07:42,334
So that means
that in order to make

178
00:07:42,334 --> 00:07:44,100
these kind of applications
run fast,

179
00:07:44,100 --> 00:07:45,300
you need fast property
access,

180
00:07:45,300 --> 00:07:47,234
you need fast property
calls,

181
00:07:47,234 --> 00:07:50,300
and you need fast and scalable
memory management.

182
00:07:50,300 --> 00:07:53,968
So you want to be able to handle
a large number of objects,

183
00:07:53,968 --> 00:07:58,100
um, efficiently.

184
00:07:58,100 --> 00:08:02,701
So these goals led
to three key components of V8.

185
00:08:02,701 --> 00:08:04,234
So the first component

186
00:08:04,234 --> 00:08:06,200
is something called
hidden classes

187
00:08:06,200 --> 00:08:08,601
and hidden class
transitions.

188
00:08:08,601 --> 00:08:09,901
Um, so hidden classes

189
00:08:09,901 --> 00:08:13,367
is basically our notion
of types.

190
00:08:13,367 --> 00:08:16,033
Um, so JavaScript does not have
any types.

191
00:08:16,033 --> 00:08:17,701
And we're not adding types
to JavaScript

192
00:08:17,701 --> 00:08:18,901
or anything like that.

193
00:08:18,901 --> 00:08:20,634
But internally
in the JavaScript engine,

194
00:08:20,634 --> 00:08:23,300
we have a notion of type
and that's our hidden class.

195
00:08:23,300 --> 00:08:25,534
And I'll--I'll tell you more
about that.

196
00:08:25,534 --> 00:08:28,667
So once we have that, we--
we, uh, we can use a technique

197
00:08:28,667 --> 00:08:30,467
called inline caching.

198
00:08:30,467 --> 00:08:33,567
Um, so we generate native code
for all of our JavaScript.

199
00:08:33,567 --> 00:08:35,667
And we also generate code
on the fly

200
00:08:35,667 --> 00:08:38,667
and use a technique
called inline caching.

201
00:08:38,667 --> 00:08:40,834
So these two things together,
hidden classes

202
00:08:40,834 --> 00:08:43,501
and native code generation
with inline caching,

203
00:08:43,501 --> 00:08:46,667
gives us fast property access
and fast function calls.

204
00:08:46,667 --> 00:08:48,868
So those are the two
first items.

205
00:08:48,868 --> 00:08:50,901
Um, so the second thing
that we wanted

206
00:08:50,901 --> 00:08:54,033
was, uh, a fast memory
management system.

207
00:08:54,033 --> 00:08:55,501
Um, so we use,

208
00:08:55,501 --> 00:08:57,467
uh, a generational garbage
collector.

209
00:08:57,467 --> 00:09:00,467
And it's pretty much standard,
but it works really well.

210
00:09:00,467 --> 00:09:02,133
Um, and that means that,

211
00:09:02,133 --> 00:09:06,300
uh, having a generational
garbage collector,

212
00:09:06,300 --> 00:09:09,501
we scale well to dealing
with a lot of objects.

213
00:09:09,501 --> 00:09:13,000
And I'll tell you some more
about that as well.

214
00:09:13,000 --> 00:09:17,000
Okay, so let's, uh,
let's dig in.

215
00:09:17,000 --> 00:09:18,601
So to set the scene,
let me start

216
00:09:18,601 --> 00:09:22,000
by telling you a bit
about V8's memory model.

217
00:09:22,000 --> 00:09:26,734
Um, so in V8, we use,
uh, 32-bit tagged pointers.

218
00:09:26,734 --> 00:09:29,467
Um, all of our objects
in our heap

219
00:09:29,467 --> 00:09:32,300
are, uh, 4-byte aligned.

220
00:09:32,300 --> 00:09:34,000
And that means
that if you have a pointer

221
00:09:34,000 --> 00:09:37,100
to a JavaScript object, uh,
the two least significant bits

222
00:09:37,100 --> 00:09:39,067
are going to be zero.

223
00:09:39,067 --> 00:09:41,767
So we can use that knowledge
to actually,

224
00:09:41,767 --> 00:09:43,634
um, do pointer tagging.

225
00:09:43,634 --> 00:09:45,801
Since we know that all pointers
should have

226
00:09:45,801 --> 00:09:47,868
the two least significant bits,
zero,

227
00:09:47,868 --> 00:09:50,501
we can actually put in
ones there,

228
00:09:50,501 --> 00:09:53,200
uh, to--to give
some extra information

229
00:09:53,200 --> 00:09:54,367
to our pointers.

230
00:09:54,367 --> 00:09:55,734
And then we just make sure
to strip them

231
00:09:55,734 --> 00:09:58,067
if we actually need
the actual pointer.

232
00:09:58,067 --> 00:10:01,534
Um, so what we use that for
is allowing 32--

233
00:10:01,534 --> 00:10:04,133
sor--sorry--
31-bit signed integers

234
00:10:04,133 --> 00:10:05,968
to be immediate values.

235
00:10:05,968 --> 00:10:09,000
And they're distinguished
from real pointers by tagging.

236
00:10:09,000 --> 00:10:11,868
So if you'll, uh, load a pointer
to a JavaScript object

237
00:10:11,868 --> 00:10:15,934
from a heap and the address
is even--

238
00:10:15,934 --> 00:10:17,133
it's actually not a pointer.

239
00:10:17,133 --> 00:10:18,734
It's an immediate
integer value.

240
00:10:18,734 --> 00:10:21,634
And you get the integer value
by just shifting,

241
00:10:21,634 --> 00:10:23,501
uh, one bit right.

242
00:10:23,501 --> 00:10:25,367
So basically shifting
the zero away.

243
00:10:25,367 --> 00:10:28,434
And that's going to be
you're, uh, integer value.

244
00:10:28,434 --> 00:10:30,133
So that means
that we can have efficient,

245
00:10:30,133 --> 00:10:33,000
um, we can deal with integers
efficiently,

246
00:10:33,000 --> 00:10:34,634
uh, because they're just
immediate values

247
00:10:34,634 --> 00:10:36,167
and we don't have
to do any heap allocation

248
00:10:36,167 --> 00:10:37,767
to handle integers.

249
00:10:37,767 --> 00:10:39,701
Um, so on the other hand,

250
00:10:39,701 --> 00:10:43,667
if you load, um, a pointer
to an object from our heap

251
00:10:43,667 --> 00:10:44,834
and it's odd,

252
00:10:44,834 --> 00:10:46,934
so it has the least significant
bit of one,

253
00:10:46,934 --> 00:10:48,934
then it is an actual pointer.

254
00:10:48,934 --> 00:10:52,300
And the pointer to the object
is this value

255
00:10:52,300 --> 00:10:53,501
where you subtract one.

256
00:10:53,501 --> 00:10:56,901
So where you clear the tag.

257
00:10:56,901 --> 00:11:00,901
Okay, so, um,

258
00:11:00,901 --> 00:11:05,634
our base JavaScript objects
consist of three words.

259
00:11:05,634 --> 00:11:09,267
The first word
is a hidden class pointer.

260
00:11:09,267 --> 00:11:12,334
Um, so this is our notion
of type as I told you before.

261
00:11:12,334 --> 00:11:16,067
And I'll--I'll get into details
on that in a second.

262
00:11:16,067 --> 00:11:18,734
Uh, and the two other pointers
are used

263
00:11:18,734 --> 00:11:20,734
to point to where
we actually hold

264
00:11:20,734 --> 00:11:22,601
the values of properties.

265
00:11:22,601 --> 00:11:25,467
So we split the property's
backing storage

266
00:11:25,467 --> 00:11:26,968
into two parts,

267
00:11:26,968 --> 00:11:31,868
one is for properties
that are named by strings.

268
00:11:31,868 --> 00:11:34,133
So like X, Y, and Z.

269
00:11:34,133 --> 00:11:36,334
And the other one
is for what we call "elements,"

270
00:11:36,334 --> 00:11:39,234
which are basically properties
which have integer names.

271
00:11:39,234 --> 00:11:42,033
So 012 and so on.

272
00:11:42,033 --> 00:11:44,701
Um, so all
of our JavaScript objects

273
00:11:44,701 --> 00:11:47,267
are these three-word
thingies.

274
00:11:47,267 --> 00:11:50,100
Okay, and the backing storage
for properties and for elements

275
00:11:50,100 --> 00:11:52,400
can be in two
different states,

276
00:11:52,400 --> 00:11:54,367
namely a fast case
and a slow case.

277
00:11:54,367 --> 00:11:56,067
So in the fast case,

278
00:11:56,067 --> 00:11:59,434
uh, a property's backing storage
or an element's backing storage

279
00:11:59,434 --> 00:12:00,767
is just an array,

280
00:12:00,767 --> 00:12:02,634
where we can do
direct indexing.

281
00:12:02,634 --> 00:12:05,033
And in the slow case,
it's going to be a dictionary

282
00:12:05,033 --> 00:12:08,901
or a HashMap.

283
00:12:08,901 --> 00:12:14,434
Okay, so now we're ready
to talk about hidden classes.

284
00:12:14,434 --> 00:12:16,033
So, uh, as I told you,

285
00:12:16,033 --> 00:12:18,501
in static, object-oriented,
uh, languages

286
00:12:18,501 --> 00:12:20,701
where you have classes,

287
00:12:20,701 --> 00:12:24,400
uh, you can do really fast
property access

288
00:12:24,400 --> 00:12:26,634
because the class describes
your object

289
00:12:26,634 --> 00:12:29,434
and you know exactly
where to find the properties

290
00:12:29,434 --> 00:12:30,767
of your object.

291
00:12:30,767 --> 00:12:33,300
So we wanted to have the same
ability for JavaScript.

292
00:12:33,300 --> 00:12:35,534
We wanted to be able to do,
like, a few,

293
00:12:35,534 --> 00:12:38,334
uh, assembly instructions
to load a property.

294
00:12:38,334 --> 00:12:41,534
Um, so to use these
normal optimization techniques,

295
00:12:41,534 --> 00:12:44,534
we needed to introduce
a notion of type.

296
00:12:44,534 --> 00:12:46,834
And for that, we use
hidden classes.

297
00:12:46,834 --> 00:12:51,601
So hidden classes,
uh, are classes,

298
00:12:51,601 --> 00:12:53,200
but they're only internal

299
00:12:53,200 --> 00:12:54,667
to the--
to the JavaScript engine.

300
00:12:54,667 --> 00:12:56,234
So it's something
that we keep track of

301
00:12:56,234 --> 00:12:58,000
and users don't know about.

302
00:12:58,000 --> 00:13:01,234
Um, and hidden classes
group objects

303
00:13:01,234 --> 00:13:03,734
that have the exact same
structure.

304
00:13:06,133 --> 00:13:09,701
Okay, so talking
about hidden classes,

305
00:13:09,701 --> 00:13:13,667
it's easiest to just,
uh, have an example.

306
00:13:13,667 --> 00:13:17,434
So, um, in JavaScript,
all objects are created

307
00:13:17,434 --> 00:13:20,567
from--from, uh,
from functions.

308
00:13:20,567 --> 00:13:22,634
Um, and here's
a point function,

309
00:13:22,634 --> 00:13:23,901
which is a constructive
function

310
00:13:23,901 --> 00:13:25,801
that we can use
to construct points.

311
00:13:25,801 --> 00:13:27,868
And it just takes two arguments
and assigns them

312
00:13:27,868 --> 00:13:32,834
to the, uh, X and Y properties
of the resulting object.

313
00:13:32,834 --> 00:13:36,133
Okay, so the goal here
is that any point

314
00:13:36,133 --> 00:13:39,467
that we construct
should end up having,

315
00:13:39,467 --> 00:13:41,701
uh, the point map, basically,

316
00:13:41,701 --> 00:13:43,534
the point hidden class.

317
00:13:43,534 --> 00:13:46,300
So JavaScript objects created
in the same way

318
00:13:46,300 --> 00:13:48,534
should end up having
the same hidden class

319
00:13:48,534 --> 00:13:53,200
because they'll have
the same internal structure.

320
00:13:53,200 --> 00:13:54,834
Okay.

321
00:13:54,834 --> 00:13:57,133
Um, so in this example,
I'm going to create two points.

322
00:13:57,133 --> 00:13:58,434
I'm going to show you
how they end up

323
00:13:58,434 --> 00:14:01,300
having the same
hidden class.

324
00:14:01,300 --> 00:14:05,701
So since all JavaScript objects
are created from functions,

325
00:14:05,701 --> 00:14:09,968
we create an initial class
for each function.

326
00:14:09,968 --> 00:14:11,200
So the point function here

327
00:14:11,200 --> 00:14:13,100
is going to have
an initial class,

328
00:14:13,100 --> 00:14:14,334
which is called class zero,

329
00:14:14,334 --> 00:14:15,734
which I've put up there.

330
00:14:15,734 --> 00:14:18,000
And this is the class--
the hidden class--

331
00:14:18,000 --> 00:14:21,868
that we're going to give,
uh, to all new objects created

332
00:14:21,868 --> 00:14:23,801
from the point function.

333
00:14:23,801 --> 00:14:28,167
So when we, uh, create
our first point here, p1,

334
00:14:28,167 --> 00:14:30,767
that's this three-word thing

335
00:14:30,767 --> 00:14:33,734
that has a pointer
to hidden class.

336
00:14:33,734 --> 00:14:35,534
And since this object
was created

337
00:14:35,534 --> 00:14:37,467
using the point function,

338
00:14:37,467 --> 00:14:40,000
it's initial class is going
to be the initial class

339
00:14:40,000 --> 00:14:42,734
of the point function,
class zero.

340
00:14:42,734 --> 00:14:44,734
And then it has properties
and elements as well.

341
00:14:44,734 --> 00:14:46,534
And in the beginning,
we're going to allocate

342
00:14:46,534 --> 00:14:48,734
a small piece of--
of backing storage

343
00:14:48,734 --> 00:14:51,067
both for properties
and for elements.

344
00:14:51,067 --> 00:14:53,033
Um, so that's--
that's the initial thing

345
00:14:53,033 --> 00:14:55,467
that you get
when you say a new point.

346
00:14:55,467 --> 00:14:57,367
And then we're going
to start executing the body

347
00:14:57,367 --> 00:15:01,033
of the point function
with this newly allocated object

348
00:15:01,033 --> 00:15:05,434
as the--this pointer.

349
00:15:05,434 --> 00:15:07,067
Okay, so the first thing
that we're going to do

350
00:15:07,067 --> 00:15:09,267
is add an X-property
to this object.

351
00:15:09,267 --> 00:15:11,501
So adding a property
to an object

352
00:15:11,501 --> 00:15:13,934
changes the structure
of the object,

353
00:15:13,934 --> 00:15:15,934
which means that we need
to change the hidden class

354
00:15:15,934 --> 00:15:17,868
of the object.

355
00:15:17,868 --> 00:15:21,501
So when we assign X
to this property,

356
00:15:21,501 --> 00:15:23,200
we need to create
a new class.

357
00:15:23,200 --> 00:15:26,334
And we do that by copying
the original class,

358
00:15:26,334 --> 00:15:27,701
which is class zero,

359
00:15:27,701 --> 00:15:29,868
and then adding the knowledge
to that class

360
00:15:29,868 --> 00:15:31,734
that we have an X-property.

361
00:15:31,734 --> 00:15:34,033
and that--that property
is at offset zero

362
00:15:34,033 --> 00:15:35,467
in our backing storage.

363
00:15:35,467 --> 00:15:37,701
And then we're going
to put the value

364
00:15:37,701 --> 00:15:40,667
into the backing storage
at offset zero.

365
00:15:40,667 --> 00:15:42,701
And importantly,
we're going to remember

366
00:15:42,701 --> 00:15:45,834
in class zero

367
00:15:45,834 --> 00:15:48,701
that if you have an object
that has class zero

368
00:15:48,701 --> 00:15:51,334
and you add a property
with the name X,

369
00:15:51,334 --> 00:15:53,868
then you need to transition
to class one.

370
00:15:53,868 --> 00:15:57,934
So that's what we call
a hidden class transition.

371
00:15:57,934 --> 00:16:01,000
Another similar thing happens
when we add the Y-property.

372
00:16:01,000 --> 00:16:03,067
So adding a new property
to an object

373
00:16:03,067 --> 00:16:04,601
changes its structure.

374
00:16:04,601 --> 00:16:08,033
And therefore it needs
to change its hidden class.

375
00:16:08,033 --> 00:16:10,534
So we create
a new hidden class

376
00:16:10,534 --> 00:16:12,667
by copying class one.

377
00:16:12,667 --> 00:16:15,501
We add the knowledge
that we have a Y-property

378
00:16:15,501 --> 00:16:17,167
and that the value
of the Y-property

379
00:16:17,167 --> 00:16:19,434
is at offset one
in our backing storage.

380
00:16:19,434 --> 00:16:21,133
We fill in value.

381
00:16:21,133 --> 00:16:23,534
And we, uh, update
the hidden class pointer

382
00:16:23,534 --> 00:16:25,667
to point
to this new class.

383
00:16:25,667 --> 00:16:27,667
And again, we remember
in class one

384
00:16:27,667 --> 00:16:30,400
that if you have an object
that has class one

385
00:16:30,400 --> 00:16:32,200
and you add a Y-property
to it,

386
00:16:32,200 --> 00:16:35,968
then you need to transition
to class two.

387
00:16:35,968 --> 00:16:38,300
Okay, so that finishes
the construction

388
00:16:38,300 --> 00:16:39,968
of our first point.

389
00:16:39,968 --> 00:16:42,133
So you see this is actually
a pretty heavy weight

390
00:16:42,133 --> 00:16:45,801
to construct the first object
from a constructive function

391
00:16:45,801 --> 00:16:48,601
because we need to create
all of these new classes

392
00:16:48,601 --> 00:16:52,501
by copying existing ones
and adding a bit of information.

393
00:16:52,501 --> 00:16:55,367
Um, but that only costs
on the first construction.

394
00:16:55,367 --> 00:16:57,234
So on the next construction,

395
00:16:57,234 --> 00:16:59,567
um, we're basically going
to do the same thing,

396
00:16:59,567 --> 00:17:02,234
but we're going
to reuse our classes.

397
00:17:02,234 --> 00:17:06,834
So if we go to the construction
of, uh, of p2,

398
00:17:06,834 --> 00:17:08,901
that will create
a new object,

399
00:17:08,901 --> 00:17:10,868
which is this
three-way thing.

400
00:17:10,868 --> 00:17:13,133
The initial class
is going to be the class

401
00:17:13,133 --> 00:17:15,200
associated
with the point function,

402
00:17:15,200 --> 00:17:17,934
which is going to be c0.

403
00:17:17,934 --> 00:17:19,133
Class zero.

404
00:17:19,133 --> 00:17:20,634
And then we're going
to execute the body

405
00:17:20,634 --> 00:17:22,300
of the point function.

406
00:17:22,300 --> 00:17:23,667
So the first thing
we're going to do

407
00:17:23,667 --> 00:17:28,667
is assign, um, is to add
an X-property to our object.

408
00:17:28,667 --> 00:17:32,300
So now this point
has class zero.

409
00:17:32,300 --> 00:17:34,501
And in class zero,
there's information

410
00:17:34,501 --> 00:17:37,334
that if you have an object
that has class zero,

411
00:17:37,334 --> 00:17:39,334
and you add a property
called X,

412
00:17:39,334 --> 00:17:41,834
well, then you need
to transition to class one.

413
00:17:41,834 --> 00:17:43,634
So that's what we're going
to do.

414
00:17:43,634 --> 00:17:46,167
So for the assignment to X,

415
00:17:46,167 --> 00:17:48,434
we're just going to update
the hidden class pointer

416
00:17:48,434 --> 00:17:50,801
and put the value
in the backing storage.

417
00:17:50,801 --> 00:17:52,400
And similarly for Y,

418
00:17:52,400 --> 00:17:54,467
we now have an object
of class one.

419
00:17:54,467 --> 00:17:57,067
In class one, we know
that if you add a Y property,

420
00:17:57,067 --> 00:17:59,234
you need to transition
to class two.

421
00:17:59,234 --> 00:18:00,634
So that's all we're going
to do.

422
00:18:00,634 --> 00:18:02,934
We're just going to update
the hidden class pointer

423
00:18:02,934 --> 00:18:07,934
and, uh, add the value
to the backing storage.

424
00:18:07,934 --> 00:18:10,534
So now we've created
two point objects.

425
00:18:10,534 --> 00:18:13,033
They've been created
in exactly the same way.

426
00:18:13,033 --> 00:18:17,934
And they end up sharing
the hidden class, class two.

427
00:18:17,934 --> 00:18:20,200
And the important thing here
is that in class two,

428
00:18:20,200 --> 00:18:23,234
we have a complete description
of our objects.

429
00:18:23,234 --> 00:18:26,267
We know that all objects
that have class two

430
00:18:26,267 --> 00:18:28,934
will have X at offset zero
in the backing storage

431
00:18:28,934 --> 00:18:31,167
and Y at offset one.

432
00:18:31,167 --> 00:18:35,100
And we can use that
to optimize property accesses.

433
00:18:37,534 --> 00:18:39,434
So let me revisit
my previous statement.

434
00:18:39,434 --> 00:18:41,968
So I said that JavaScript
is really challenging

435
00:18:41,968 --> 00:18:45,467
to implement because
it's really, really dynamic.

436
00:18:45,467 --> 00:18:46,667
And that's true.

437
00:18:46,667 --> 00:18:48,934
So in JavaScript,
you have a lot of features

438
00:18:48,934 --> 00:18:52,834
that allow you to write
really, really dynamic code.

439
00:18:52,834 --> 00:18:55,567
But it turns out
that if you write,

440
00:18:55,567 --> 00:18:59,300
uh, nice,
well-factored code,

441
00:18:59,300 --> 00:19:01,901
in most cases, you'll have,
like, parts of your code

442
00:19:01,901 --> 00:19:04,701
that deal with objects
that have a certain structure.

443
00:19:04,701 --> 00:19:06,934
So now that we have
hidden classes,

444
00:19:06,934 --> 00:19:08,667
we can instrument
our JavaScript engine

445
00:19:08,667 --> 00:19:12,234
to actually collect information
about the hidden classes

446
00:19:12,234 --> 00:19:13,901
that hit certain access sites.

447
00:19:13,901 --> 00:19:15,968
And it turns out that 90%
of the cases

448
00:19:15,968 --> 00:19:19,067
or maybe even more,
uh, only objects

449
00:19:19,067 --> 00:19:23,367
having the same hidden class
are ever seen.

450
00:19:23,367 --> 00:19:26,100
So that means that,
basically, you know something

451
00:19:26,100 --> 00:19:28,033
about the structure
of your objects

452
00:19:28,033 --> 00:19:31,567
when you've seen an object once
at an access site.

453
00:19:31,567 --> 00:19:33,501
And that's what we're, uh,
and that's what we're going

454
00:19:33,501 --> 00:19:36,234
to do to, uh, to--
to optimize.

455
00:19:36,234 --> 00:19:39,400
Um, so basically,
at runtime,

456
00:19:39,400 --> 00:19:41,634
JavaScript is not that
dynamic.

457
00:19:41,634 --> 00:19:44,167
You basically see things
that have the same structure

458
00:19:44,167 --> 00:19:46,667
again and again and again
and again.

459
00:19:46,667 --> 00:19:48,167
So we can use that.

460
00:19:48,167 --> 00:19:52,100
Um, so the only problem here

461
00:19:52,100 --> 00:19:55,501
is that when we generate
the JavaScript code--

462
00:19:55,501 --> 00:19:59,534
sorry, the native code
for our JavaScript code,

463
00:19:59,534 --> 00:20:02,067
um, we don't know
the hidden class

464
00:20:02,067 --> 00:20:04,534
of an object
at an access site,

465
00:20:04,534 --> 00:20:06,000
uh, because we have
no type information

466
00:20:06,000 --> 00:20:07,300
in the language.

467
00:20:07,300 --> 00:20:09,934
Um, so that means
that we only know something

468
00:20:09,934 --> 00:20:11,868
about our objects
when we see the first object

469
00:20:11,868 --> 00:20:13,834
at an access site.

470
00:20:13,834 --> 00:20:16,234
Um, so in order
to handle this,

471
00:20:16,234 --> 00:20:18,367
we use runtime
code generation.

472
00:20:18,367 --> 00:20:23,601
And we use a technique called
inline caching.

473
00:20:23,601 --> 00:20:25,100
So here's
a very simple picture

474
00:20:25,100 --> 00:20:26,834
of what inline caching
is like.

475
00:20:26,834 --> 00:20:28,100
So in the beginning,

476
00:20:28,100 --> 00:20:30,467
we just generate native code
for our JavaScript code.

477
00:20:30,467 --> 00:20:33,400
And at all access sites,
we have absolutely no knowledge.

478
00:20:33,400 --> 00:20:36,200
So if we want to load
an X-property,

479
00:20:36,200 --> 00:20:37,901
we're just going to call
a piece of code

480
00:20:37,901 --> 00:20:39,701
that's going to do
a completely generic

481
00:20:39,701 --> 00:20:42,534
full lookup, uh, through
our objects

482
00:20:42,534 --> 00:20:43,634
to see if they can find--

483
00:20:43,634 --> 00:20:46,767
uh, if it can find
the property.

484
00:20:46,767 --> 00:20:48,701
But once
we've done that once,

485
00:20:48,701 --> 00:20:50,200
we have some extra
information.

486
00:20:50,200 --> 00:20:52,167
We know the hidden class
of the object

487
00:20:52,167 --> 00:20:53,734
that we've just looked at.

488
00:20:53,734 --> 00:20:56,634
And we know, um,

489
00:20:56,634 --> 00:20:59,634
where we found the property
in this object.

490
00:20:59,634 --> 00:21:03,167
And based on that knowledge,
we can generate a small snippet

491
00:21:03,167 --> 00:21:07,000
of new code that's going to be
really fast.

492
00:21:07,000 --> 00:21:10,334
Um, and it's going to assume
that the next time we get here,

493
00:21:10,334 --> 00:21:14,067
we're going to see
the same hidden class again.

494
00:21:14,067 --> 00:21:15,901
So then we're going
to rewrite the code.

495
00:21:15,901 --> 00:21:17,234
So that at this access site,

496
00:21:17,234 --> 00:21:19,701
we're not going to go
to the fully generic code.

497
00:21:19,701 --> 00:21:23,634
But we're actually going
to hit the fast lookup code.

498
00:21:23,634 --> 00:21:25,801
And the only thing
the fast lookup code has to do

499
00:21:25,801 --> 00:21:27,634
is validate our assumptions.

500
00:21:27,634 --> 00:21:31,334
So it needs to check that
the next object that gets here

501
00:21:31,334 --> 00:21:32,634
actually has the same
hidden class

502
00:21:32,634 --> 00:21:33,667
as the first one.

503
00:21:33,667 --> 00:21:34,734
And if it does,

504
00:21:34,734 --> 00:21:36,334
then it knows exactly
where to load

505
00:21:36,334 --> 00:21:39,267
the--the property value.

506
00:21:39,267 --> 00:21:41,767
Okay, and if the assumptions
are broken--

507
00:21:41,767 --> 00:21:44,767
so if we get here
with another type of object--

508
00:21:44,767 --> 00:21:46,400
well, then we bail out
and then we go

509
00:21:46,400 --> 00:21:48,734
to the fully generic
lookup again.

510
00:21:48,734 --> 00:21:50,501
And again, that's the same
for all access sites.

511
00:21:50,501 --> 00:21:54,701
When we've seen the first,
uh, object at an access site,

512
00:21:54,701 --> 00:21:56,167
we generate a new piece
of code

513
00:21:56,167 --> 00:21:58,667
to do a fast lookup
the next time.

514
00:21:58,667 --> 00:22:00,267
Um, and that's
with the assumption

515
00:22:00,267 --> 00:22:03,000
that we get the same
hidden class again.

516
00:22:03,000 --> 00:22:05,033
If we don't,
then we bail out

517
00:22:05,033 --> 00:22:08,734
and do a full generate lookup.

518
00:22:08,734 --> 00:22:11,801
Okay, so what does
the fast case look like?

519
00:22:11,801 --> 00:22:13,467
So it looks like this.

520
00:22:13,467 --> 00:22:14,934
Um, and I've actually
given you

521
00:22:14,934 --> 00:22:17,400
all of the information
that you need to--

522
00:22:17,400 --> 00:22:18,901
to completely understand
what's going on here.

523
00:22:18,901 --> 00:22:20,901
So let me try to step--
step through it.

524
00:22:20,901 --> 00:22:23,767
So this is the--
the small snippet of code

525
00:22:23,767 --> 00:22:27,667
that we generate to access
a property on an object.

526
00:22:27,667 --> 00:22:29,968
So the first couple
of lines here,

527
00:22:29,968 --> 00:22:32,868
the first line
just loads the receiver

528
00:22:32,868 --> 00:22:37,968
from the stack
into register eax, okay?

529
00:22:37,968 --> 00:22:43,701
So as I told you,
we use tag pointers.

530
00:22:43,701 --> 00:22:46,000
So either--so now
we've loaded something.

531
00:22:46,000 --> 00:22:49,667
Okay. So now we need to check
if it's an object

532
00:22:49,667 --> 00:22:52,133
or if it's
an immediate value.

533
00:22:52,133 --> 00:22:54,801
Uh, maybe a small integer.

534
00:22:54,801 --> 00:22:56,801
So that's what the second line
here is doing.

535
00:22:56,801 --> 00:22:59,801
It--it, uh, tests
if the least significant bit

536
00:22:59,801 --> 00:23:01,334
of eax is one.

537
00:23:01,334 --> 00:23:03,367
If it is,
this is an object pointer.

538
00:23:03,367 --> 00:23:06,667
If it's not, it's an immediate
integer value

539
00:23:06,667 --> 00:23:09,167
for which this snippet
doesn't really do anything.

540
00:23:09,167 --> 00:23:12,033
So we're going to jump out
and go do the generic case

541
00:23:12,033 --> 00:23:13,868
if that's the--
if--if that's happening.

542
00:23:13,868 --> 00:23:16,734
So if we see an integer here,
we're just bailing out.

543
00:23:16,734 --> 00:23:19,234
So the--the first lines here
are just loading the receiver,

544
00:23:19,234 --> 00:23:22,200
checking that it's an object.

545
00:23:22,200 --> 00:23:23,968
So the next couple
of lines here

546
00:23:23,968 --> 00:23:25,901
are validating
our assumptions.

547
00:23:25,901 --> 00:23:27,901
And our assumption is
that we're going to see

548
00:23:27,901 --> 00:23:29,534
the same hidden class again.

549
00:23:29,534 --> 00:23:32,367
So this piece of code
was generated with the knowledge

550
00:23:32,367 --> 00:23:34,701
that the first,
uh, that the hidden class

551
00:23:34,701 --> 00:23:36,634
of the first object
that got here

552
00:23:36,634 --> 00:23:38,300
was at address
whatever's there.

553
00:23:38,300 --> 00:23:41,367
0xf78 and so on.

554
00:23:41,367 --> 00:23:44,734
Okay. So now we need to check
that the hidden class

555
00:23:44,734 --> 00:23:48,334
of a current object
is the same one.

556
00:23:48,334 --> 00:23:52,267
So we're going to load
from eax minus one.

557
00:23:52,267 --> 00:23:55,534
So that's removing the tagging
from the pointer

558
00:23:55,534 --> 00:23:57,834
and loading a pointer
from there,

559
00:23:57,834 --> 00:23:59,234
which is the map pointer,

560
00:23:59,234 --> 00:24:01,968
and we're just comparing that
to what we saw before.

561
00:24:01,968 --> 00:24:04,434
If it's the same,
we're happy

562
00:24:04,434 --> 00:24:06,767
and we load
the properties array

563
00:24:06,767 --> 00:24:08,367
from our object.

564
00:24:08,367 --> 00:24:09,901
And from the properties array,

565
00:24:09,901 --> 00:24:13,334
we load the property value
directly.

566
00:24:13,334 --> 00:24:14,534
And then we return.

567
00:24:14,534 --> 00:24:15,734
So in the fast case,

568
00:24:15,734 --> 00:24:17,200
all we need to do
is check our assumptions.

569
00:24:17,200 --> 00:24:19,133
We load the receiver.
Check that it's an object.

570
00:24:19,133 --> 00:24:21,234
Check that it has the correct
hidden class.

571
00:24:21,234 --> 00:24:22,968
And then directly load
the property.

572
00:24:22,968 --> 00:24:25,200
So that's a few assembly line
instructions.

573
00:24:25,200 --> 00:24:26,868
And that's really,
really fast.

574
00:24:26,868 --> 00:24:28,601
And if any of
our assumptions break,

575
00:24:28,601 --> 00:24:33,400
if we either get an integer
or if the class does not match,

576
00:24:33,400 --> 00:24:36,934
then we bail out and go
to a fully generic lookup.

577
00:24:39,834 --> 00:24:41,734
Okay, so basically,

578
00:24:41,734 --> 00:24:43,868
I've told you now
about two states

579
00:24:43,868 --> 00:24:45,601
that our inline caches
can be in.

580
00:24:45,601 --> 00:24:47,567
There's actually a third
as well.

581
00:24:47,567 --> 00:24:49,901
So the three inline cache states
that we have

582
00:24:49,901 --> 00:24:51,234
are uninitialized,

583
00:24:51,234 --> 00:24:52,667
which is where
everything begins.

584
00:24:52,667 --> 00:24:53,767
We don't know anything yet.

585
00:24:53,767 --> 00:24:56,100
We haven't seen
any objects here.

586
00:24:56,100 --> 00:24:58,067
So once we see
the first object,

587
00:24:58,067 --> 00:25:01,000
we transition
to monomorphic,

588
00:25:01,000 --> 00:25:03,133
which means that we've
only seen one hidden class

589
00:25:03,133 --> 00:25:05,133
at this access site.

590
00:25:05,133 --> 00:25:07,868
If we see more hidden classes
at the same access site,

591
00:25:07,868 --> 00:25:10,901
we go into what's called
a megamorphic state.

592
00:25:10,901 --> 00:25:13,801
And that just means
we've seen more types here.

593
00:25:13,801 --> 00:25:16,801
Um, and in that case,
we actually use a cache

594
00:25:16,801 --> 00:25:19,701
of generated
fast-case stubs.

595
00:25:19,701 --> 00:25:21,868
So if we've already generated
a stub

596
00:25:21,868 --> 00:25:24,834
for the, uh, this hidden class
that we're seeing

597
00:25:24,834 --> 00:25:26,434
and this property,
we use that.

598
00:25:26,434 --> 00:25:28,367
And otherwise, we go
to the full generic lookup.

599
00:25:28,367 --> 00:25:31,300
So even if we see,
uh, multiple different classes

600
00:25:31,300 --> 00:25:32,501
at the same access site,

601
00:25:32,501 --> 00:25:33,767
we're actually trying
to--to use

602
00:25:33,767 --> 00:25:37,367
some of our optimized stubs.

603
00:25:37,367 --> 00:25:39,567
Another thing worth,
uh, knowing

604
00:25:39,567 --> 00:25:41,434
about inline caches in V8

605
00:25:41,434 --> 00:25:44,834
is that we clear them
on full garbage collections.

606
00:25:44,834 --> 00:25:46,467
And that might sound odd.

607
00:25:46,467 --> 00:25:49,868
So we've just spent time
generating code on the fly.

608
00:25:49,868 --> 00:25:52,868
Uh, and now we just
throw it all away.

609
00:25:52,868 --> 00:25:55,334
So the reason for that is that,
first of all,

610
00:25:55,334 --> 00:25:58,601
it allows us to get rid
of unused code stubs.

611
00:25:58,601 --> 00:26:00,400
So all of the code
that we generate

612
00:26:00,400 --> 00:26:02,667
is allocated
in the JavaScript heap

613
00:26:02,667 --> 00:26:04,267
like any other JavaScript
object.

614
00:26:04,267 --> 00:26:06,400
And it flows freely around.

615
00:26:06,400 --> 00:26:10,100
Um, so in order to be able
to, uh, to throw it away,

616
00:26:10,100 --> 00:26:12,067
uh, we need to clear
inline caches

617
00:26:12,067 --> 00:26:16,100
so there are no pointers,
uh, to these stubs.

618
00:26:16,100 --> 00:26:19,367
Um, so if you have
an application

619
00:26:19,367 --> 00:26:22,334
where you have, like,
a couple of stages--

620
00:26:22,334 --> 00:26:24,934
so in the first stage,
you set up a lot of stuff.

621
00:26:24,934 --> 00:26:28,434
And you do a lot of things
with one piece of code.

622
00:26:28,434 --> 00:26:30,634
And then basically
you transition to some other--

623
00:26:30,634 --> 00:26:32,601
to--to, like, another phase
where you use, basically,

624
00:26:32,601 --> 00:26:34,234
another piece of code.

625
00:26:34,234 --> 00:26:36,567
We don't want to keep
all the code objects alive

626
00:26:36,567 --> 00:26:38,067
from the first piece of code

627
00:26:38,067 --> 00:26:39,767
because if they're not going
to be used anymore,

628
00:26:39,767 --> 00:26:41,200
that's a waste.

629
00:26:41,200 --> 00:26:44,367
Um, so clearing inline caches
at full garbage collections

630
00:26:44,367 --> 00:26:47,300
allows us to get rid
of unused code stubs.

631
00:26:47,300 --> 00:26:50,901
The other thing that clearing,
um, inline caches

632
00:26:50,901 --> 00:26:52,734
at full garbage collection
gives us

633
00:26:52,734 --> 00:26:55,267
is the ability
to actually go back

634
00:26:55,267 --> 00:26:58,033
to the fast case
if we hit the slow case

635
00:26:58,033 --> 00:27:00,400
where we've seen multiple
different hidden classes

636
00:27:00,400 --> 00:27:02,200
at an access site.

637
00:27:02,200 --> 00:27:04,167
But basically,
we've transitioned

638
00:27:04,167 --> 00:27:06,701
to another, like, phase
of the program

639
00:27:06,701 --> 00:27:09,100
where we're only seeing objects
with the same,

640
00:27:09,100 --> 00:27:11,467
uh, with the same
hidden class.

641
00:27:11,467 --> 00:27:13,400
Uh, then we basically
don't want to get stuck

642
00:27:13,400 --> 00:27:15,534
in the situation
where we think that we've seen

643
00:27:15,534 --> 00:27:17,367
multiple, uh, things.

644
00:27:17,367 --> 00:27:20,801
So clearing inline caches
on--on full garbage collection

645
00:27:20,801 --> 00:27:22,367
gives our inline caches
the ability

646
00:27:22,367 --> 00:27:25,801
to go back to the fast
monomorphic case again.

647
00:27:28,868 --> 00:27:34,267
Okay, so, um,

648
00:27:34,267 --> 00:27:36,501
that was,
uh, an introduction

649
00:27:36,501 --> 00:27:38,567
to how we make
property accesses fast.

650
00:27:38,567 --> 00:27:39,834
So there are
two things here.

651
00:27:39,834 --> 00:27:42,734
There are the hidden classes
and--and the transition

652
00:27:42,734 --> 00:27:44,367
between hidden classes.

653
00:27:44,367 --> 00:27:47,501
And there's native code
generation with inline caching.

654
00:27:47,501 --> 00:27:50,667
So the next thing I'd like
to--to tell you about

655
00:27:50,667 --> 00:27:53,767
is, uh,
our memory management.

656
00:27:53,767 --> 00:27:57,334
So we use a precise generational
garbage collector.

657
00:27:57,334 --> 00:28:00,634
And what we really want here
is, uh,

658
00:28:00,634 --> 00:28:02,767
to get in a situation
where the JavaScript engine

659
00:28:02,767 --> 00:28:04,367
scales well.

660
00:28:04,367 --> 00:28:06,434
So if you have a lot
of objects,

661
00:28:06,434 --> 00:28:09,701
uh, and a lot of, like,
big data structures

662
00:28:09,701 --> 00:28:11,467
when you run your program,

663
00:28:11,467 --> 00:28:14,033
we don't want
the garbage collector

664
00:28:14,033 --> 00:28:16,000
to have to look
at all of these objects

665
00:28:16,000 --> 00:28:20,534
every time it has to, uh,
uh, reclaim, uh, some memory

666
00:28:20,534 --> 00:28:23,667
because that's going to lead
to big pause times

667
00:28:23,667 --> 00:28:26,133
and it's going to degrade
your performance.

668
00:28:26,133 --> 00:28:28,868
Because every time you need
to get some free memory,

669
00:28:28,868 --> 00:28:30,033
it has to look at everything.

670
00:28:30,033 --> 00:28:31,300
So we don't want that.

671
00:28:31,300 --> 00:28:34,234
So instead, we use generational
garbage collection.

672
00:28:34,234 --> 00:28:38,234
Um, so we have
two generations.

673
00:28:38,234 --> 00:28:40,000
We have a young generation,

674
00:28:40,000 --> 00:28:42,634
which is one, small,
contiguous space,

675
00:28:42,634 --> 00:28:44,701
which would
garbage collect often,

676
00:28:44,701 --> 00:28:46,501
and then we have
an old generation,

677
00:28:46,501 --> 00:28:49,400
uh, which is divided
into a number of spaces.

678
00:28:49,400 --> 00:28:53,300
Um, and--and we only
occasionally garbage collect

679
00:28:53,300 --> 00:28:54,767
the old generation.

680
00:28:54,767 --> 00:28:57,534
So the reasoning here
is that, um,

681
00:28:57,534 --> 00:28:59,701
in object-oriented programs,

682
00:28:59,701 --> 00:29:03,033
most objects that you allocate
are going to be dead,

683
00:29:03,033 --> 00:29:04,234
like, really soon.

684
00:29:04,234 --> 00:29:06,868
You'll have a lot
of temporary objects.

685
00:29:06,868 --> 00:29:10,534
Um, and the ones
that do not die immediately

686
00:29:10,534 --> 00:29:12,767
are often long-lived.

687
00:29:12,767 --> 00:29:15,067
So we allocate
all of our objects

688
00:29:15,067 --> 00:29:17,133
in the young generation.

689
00:29:17,133 --> 00:29:18,567
When--when we run
out of space

690
00:29:18,567 --> 00:29:19,701
in the young generation,

691
00:29:19,701 --> 00:29:22,033
we need to do
a garbage collection.

692
00:29:22,033 --> 00:29:24,100
But we only garbage collect
the young generation.

693
00:29:24,100 --> 00:29:25,868
And since most objects
that are allocated

694
00:29:25,868 --> 00:29:27,434
die really young,

695
00:29:27,434 --> 00:29:29,634
there'll be a lot
of dead objects

696
00:29:29,634 --> 00:29:30,801
in our young generation.

697
00:29:30,801 --> 00:29:32,501
So we can get rid
of most of them.

698
00:29:32,501 --> 00:29:34,200
And then we'll be ready
to allocate again.

699
00:29:34,200 --> 00:29:36,767
So there's no reason for us
to look at the old generation

700
00:29:36,767 --> 00:29:38,467
if we can free enough,
uh, memory

701
00:29:38,467 --> 00:29:41,467
from the--from the young
generation.

702
00:29:41,467 --> 00:29:47,234
Um, so objects that survive
in the young generation

703
00:29:47,234 --> 00:29:50,434
will be promoted
to the old generation

704
00:29:50,434 --> 00:29:53,100
and then will continue.

705
00:29:53,100 --> 00:29:55,834
Okay, so, um, the old
generation, as I said,

706
00:29:55,834 --> 00:29:58,300
is divided up into a number
of spaces.

707
00:29:58,300 --> 00:30:00,400
And I'm not going to go
into a lot of details with that.

708
00:30:00,400 --> 00:30:03,601
But, so--so the reasons
for having multiple spaces

709
00:30:03,601 --> 00:30:05,133
is basically to be able

710
00:30:05,133 --> 00:30:09,234
to, uh, um, manage the--
the bookkeeping

711
00:30:09,234 --> 00:30:11,601
in our memory management
system.

712
00:30:11,601 --> 00:30:14,834
So for instance,
uh, we need--we have pages

713
00:30:14,834 --> 00:30:18,000
that are 8, uh, 8K big.

714
00:30:18,000 --> 00:30:19,934
So if we have objects
that are larger than that,

715
00:30:19,934 --> 00:30:21,601
then we're not going
to allocate them

716
00:30:21,601 --> 00:30:22,801
in the normal way.

717
00:30:22,801 --> 00:30:25,767
So we have a special space
for large objects.

718
00:30:25,767 --> 00:30:28,567
Uh, and also,
uh, as I said,

719
00:30:28,567 --> 00:30:31,701
we're dynamically generating
native code on the fly.

720
00:30:31,701 --> 00:30:35,434
Um, so we need one space
that's executable,

721
00:30:35,434 --> 00:30:37,734
uh, where we generate
our native code

722
00:30:37,734 --> 00:30:39,100
and run it from there.

723
00:30:39,100 --> 00:30:40,834
Um, so that's
the code space.

724
00:30:40,834 --> 00:30:43,834
And then there are a number
of other spaces.

725
00:30:43,834 --> 00:30:45,100
Good.

726
00:30:45,100 --> 00:30:48,868
So which types of garbage
collection do we use?

727
00:30:48,868 --> 00:30:50,968
Um, I'm sorry about that.

728
00:30:50,968 --> 00:30:53,501
My slides
are a bit messed up here.

729
00:30:53,501 --> 00:30:56,467
Uh, I think we'll be fine.

730
00:30:56,467 --> 00:31:00,133
So, um, we have three types
of garbage collection.

731
00:31:00,133 --> 00:31:02,234
So the first one
is a scavenge collect.

732
00:31:02,234 --> 00:31:03,834
A scavenge.

733
00:31:03,834 --> 00:31:05,734
And on a scavenge collection,

734
00:31:05,734 --> 00:31:08,067
uh, we only look
at the young generation.

735
00:31:08,067 --> 00:31:09,667
So this is what we do
all the time.

736
00:31:09,667 --> 00:31:12,934
Uh, and that's,
uh, copying collection.

737
00:31:12,934 --> 00:31:15,234
Um, which means
that it's leaning on the size

738
00:31:15,234 --> 00:31:16,868
of the live data.

739
00:31:16,868 --> 00:31:18,667
And as I told you,
a lot of data dies--

740
00:31:18,667 --> 00:31:21,267
a lot of objects die
really young.

741
00:31:21,267 --> 00:31:24,300
So that means
that most of your data

742
00:31:24,300 --> 00:31:26,501
in the young generation
is going to be dead.

743
00:31:26,501 --> 00:31:28,467
And since this, uh, garbage
collection technique

744
00:31:28,467 --> 00:31:30,133
is leaning on the size
of live objects,

745
00:31:30,133 --> 00:31:31,467
it's going to be really fast

746
00:31:31,467 --> 00:31:33,667
because there's not going
to be much live data.

747
00:31:33,667 --> 00:31:36,167
So typical pause times
for a scavenge

748
00:31:36,167 --> 00:31:37,834
is one to two milliseconds.

749
00:31:37,834 --> 00:31:41,734
Um, and we do that
all the time.

750
00:31:41,734 --> 00:31:43,167
Okay, so once in awhile,

751
00:31:43,167 --> 00:31:47,601
we've actually, uh, promoted
enough objects

752
00:31:47,601 --> 00:31:50,467
that we should, um, try
to clear up

753
00:31:50,467 --> 00:31:52,701
the old generation as well.

754
00:31:52,701 --> 00:31:56,100
Um, so once in awhile,
we do full garbage collections.

755
00:31:56,100 --> 00:31:57,934
And we have two flavors
of those.

756
00:31:57,934 --> 00:32:01,334
So the first one
is a non-compacting collection.

757
00:32:01,334 --> 00:32:03,334
So that's a mark-sweep
collection

758
00:32:03,334 --> 00:32:07,167
of both young and old
generation.

759
00:32:07,167 --> 00:32:10,000
And in the non-compacting
version,

760
00:32:10,000 --> 00:32:12,534
all free memory
gets added to free lists

761
00:32:12,534 --> 00:32:14,367
and we allocate from there.

762
00:32:14,367 --> 00:32:17,634
Um, and this might cause
fragmentation.

763
00:32:17,634 --> 00:32:21,234
So, um, so fragmentation's
not good.

764
00:32:21,234 --> 00:32:23,300
So that's why we have
a--another way

765
00:32:23,300 --> 00:32:25,467
of garbage collection.

766
00:32:25,467 --> 00:32:27,634
Um, okay, so a typical
pause time

767
00:32:27,634 --> 00:32:29,501
for, like, really big
applications

768
00:32:29,501 --> 00:32:32,767
for a full,
uh, non-compacting collection

769
00:32:32,767 --> 00:32:35,667
is up to 50 milliseconds.

770
00:32:35,667 --> 00:32:37,701
Often, you'll see
a lot smaller.

771
00:32:37,701 --> 00:32:40,467
But if you're building
really big applications,

772
00:32:40,467 --> 00:32:44,200
you can see pause times
up to 50 milliseconds.

773
00:32:44,200 --> 00:32:46,567
So the last type of garbage
collection that we have

774
00:32:46,567 --> 00:32:48,567
is a full compacting
collection.

775
00:32:48,567 --> 00:32:51,367
Uh, and that's
a mark-sweep-compact collection

776
00:32:51,367 --> 00:32:53,133
of both generations.

777
00:32:53,133 --> 00:32:55,133
And instead
of adding free memory

778
00:32:55,133 --> 00:32:56,634
to free lists,

779
00:32:56,634 --> 00:32:58,033
we compact everything.

780
00:32:58,033 --> 00:33:01,767
So we move all of the objects
to the beginning of pages

781
00:33:01,767 --> 00:33:04,300
um, to get rid
of the fragmentation.

782
00:33:04,300 --> 00:33:07,000
So basically, inside of V8,
we have a notion of--

783
00:33:07,000 --> 00:33:08,367
we have an idea
of how much fragmentation

784
00:33:08,367 --> 00:33:10,000
we've created.

785
00:33:10,000 --> 00:33:13,300
And when we reach
a certain threshold,

786
00:33:13,300 --> 00:33:15,634
we're going to do a non--
sorry, a compacting collection

787
00:33:15,634 --> 00:33:18,434
to get rid
of the fragmentation.

788
00:33:18,434 --> 00:33:19,934
Okay, so getting rid
of fragmentation

789
00:33:19,934 --> 00:33:22,501
means that we need
to copy a lot of objects.

790
00:33:22,501 --> 00:33:24,834
So if you're building
a really large application,

791
00:33:24,834 --> 00:33:29,767
uh, you might get pause times
of up to 100 milliseconds here.

792
00:33:29,767 --> 00:33:30,968
Yeah.

793
00:33:35,901 --> 00:33:38,400
Oh, so the question is
"how big is the, uh, is the--

794
00:33:38,400 --> 00:33:40,000
is the young generation?"

795
00:33:40,000 --> 00:33:42,667
Um, it's not very big.

796
00:33:42,667 --> 00:33:45,534
It's, like, wow,

797
00:33:45,534 --> 00:33:46,901
honestly,
I don't even remember.

798
00:33:46,901 --> 00:33:49,234
I think it's--it's--
it's a megabyte or two.

799
00:33:49,234 --> 00:33:51,033
Something like that.

800
00:34:04,667 --> 00:34:06,701
So the--so--I'm not sure
I understand the question.

801
00:34:06,701 --> 00:34:08,601
So you're saying
that if I have an application

802
00:34:08,601 --> 00:34:11,834
that allocates
a lot of small objects--

803
00:34:11,834 --> 00:34:14,267
a lot of small objects,
uh, and then you're saying

804
00:34:14,267 --> 00:34:15,567
that then
the young generation's

805
00:34:15,567 --> 00:34:18,000
going to be scanned
frequently?

806
00:34:18,000 --> 00:34:19,367
Well, no, not really.

807
00:34:19,367 --> 00:34:21,734
So--so the--so, um,
so if you allocate

808
00:34:21,734 --> 00:34:23,334
a lot of small objects,

809
00:34:23,334 --> 00:34:24,667
yes, they're going
to be allocated

810
00:34:24,667 --> 00:34:27,033
in the--
in the young generation.

811
00:34:27,033 --> 00:34:29,534
Um, so if--if when you--

812
00:34:29,534 --> 00:34:31,133
so when you fill out
the young generation

813
00:34:31,133 --> 00:34:32,367
and you don't have
any more room,

814
00:34:32,367 --> 00:34:34,100
you need to garbage collect.

815
00:34:34,100 --> 00:34:36,834
So at that point,
you look at all the live data

816
00:34:36,834 --> 00:34:38,567
and then it's true
that if all of your objects

817
00:34:38,567 --> 00:34:40,033
are still live,

818
00:34:40,033 --> 00:34:42,234
then you're going to look
through all of them, basically.

819
00:34:42,234 --> 00:34:44,467
But if they survive,
then you're going to move them

820
00:34:44,467 --> 00:34:45,701
to the old generation

821
00:34:45,701 --> 00:34:48,501
and you're not going to look
at them again.

822
00:34:48,501 --> 00:34:50,501
Yeah. But, yeah,
you're right.

823
00:34:50,501 --> 00:34:52,334
I mean, as long as you just
allocate,

824
00:34:52,334 --> 00:34:54,968
uh, and--and keep
everything alive,

825
00:34:54,968 --> 00:34:56,968
it's going to be allocated
in the young generation,

826
00:34:56,968 --> 00:34:58,200
and you're going
to scan all of them

827
00:34:58,200 --> 00:34:59,734
and basically move them
to the old generation

828
00:34:59,734 --> 00:35:03,033
so you don't have to look
at them the next time.

829
00:35:03,033 --> 00:35:06,968
Yeah.

830
00:35:06,968 --> 00:35:08,467
Oh, the timing of these?

831
00:35:08,467 --> 00:35:13,200
Uh, these are on, uh,
all desktop--desktop machines.

832
00:35:13,200 --> 00:35:17,400
Uh, and--and, uh, so basically
running inside of Chrome

833
00:35:17,400 --> 00:35:21,534
on, like, a modern machine--
desktop machine.

834
00:35:25,200 --> 00:35:27,767
Okay.

835
00:35:27,767 --> 00:35:32,834
So that covers the part
of how we made V8

836
00:35:32,834 --> 00:35:36,601
handle, um, property accesses,
function calls,

837
00:35:36,601 --> 00:35:41,534
and, um, uh, write really well
and be fast at that.

838
00:35:41,534 --> 00:35:43,400
And how we made V8 scale,

839
00:35:43,400 --> 00:35:46,000
uh, by using generational
garbage collection.

840
00:35:46,000 --> 00:35:48,000
So now let me talk
a bit about,

841
00:35:48,000 --> 00:35:50,100
uh, some recent developments.

842
00:35:52,400 --> 00:35:54,367
So recently, we've, uh,
we've implemented

843
00:35:54,367 --> 00:35:57,167
a new regular expression engine
for V8.

844
00:35:57,167 --> 00:35:59,133
It's called Irregexp.

845
00:35:59,133 --> 00:36:02,267
Um, so initially, V8,

846
00:36:02,267 --> 00:36:04,667
um, actually
in the beginning,

847
00:36:04,667 --> 00:36:06,167
like, completely
from the beginning

848
00:36:06,167 --> 00:36:08,334
to get V8 up and running,
we use PCRE,

849
00:36:08,334 --> 00:36:11,601
which is a standard library
for regular expression matching.

850
00:36:11,601 --> 00:36:14,100
Um, the problem with PCRE

851
00:36:14,100 --> 00:36:15,801
is that it does not match

852
00:36:15,801 --> 00:36:18,234
JavaScript regular expression
semantics.

853
00:36:18,234 --> 00:36:19,467
So you need something else.

854
00:36:19,467 --> 00:36:22,300
Either you need
to modify PCRE

855
00:36:22,300 --> 00:36:24,267
or you need to have,
like, a compatibility layer

856
00:36:24,267 --> 00:36:27,334
that basically translates
PCRE regular expressions--

857
00:36:27,334 --> 00:36:28,767
sorry, JavaScript regular
expressions

858
00:36:28,767 --> 00:36:30,767
to their equivalent
PCRE regular expression

859
00:36:30,767 --> 00:36:32,934
and then use PCRE.

860
00:36:32,934 --> 00:36:35,801
Um, so luckily,
at WebKit,

861
00:36:35,801 --> 00:36:39,200
they, uh, they had this problem
as well.

862
00:36:39,200 --> 00:36:42,334
And they created a library
called JSCRE,

863
00:36:42,334 --> 00:36:45,033
uh, which matched,
uh, JavaScript semantics.

864
00:36:45,033 --> 00:36:46,334
So we switched to that.

865
00:36:46,334 --> 00:36:50,100
So the initial version of V8
used a library,

866
00:36:50,100 --> 00:36:53,067
uh, from WebKit
called JSCRE.

867
00:36:53,067 --> 00:36:57,634
Um, so JSCRE did not fit V8
that well

868
00:36:57,634 --> 00:36:59,801
so it didn't really
perform well.

869
00:36:59,801 --> 00:37:03,667
And the reason for this
is that, uh, JSCRE,

870
00:37:03,667 --> 00:37:05,934
uh, expected a different string
representation

871
00:37:05,934 --> 00:37:08,167
than most strings in V8.

872
00:37:08,167 --> 00:37:11,634
So in order to actually
hand off a string to JSCRE,

873
00:37:11,634 --> 00:37:13,968
we would most of the time
have to do a string conversion.

874
00:37:13,968 --> 00:37:15,734
And that's really costly.

875
00:37:15,734 --> 00:37:18,901
Um, so this really didn't
perform very well.

876
00:37:18,901 --> 00:37:22,100
So, uh, and we thought
that we could do--do better.

877
00:37:22,100 --> 00:37:23,767
And we also thought
that we could do better

878
00:37:23,767 --> 00:37:25,334
when it comes to algorithms,

879
00:37:25,334 --> 00:37:27,834
uh, for regular expression
matching.

880
00:37:27,834 --> 00:37:30,834
Uh, so we implemented our own
regular expression matching,

881
00:37:30,834 --> 00:37:34,901
which has given us a 10x speedup
on regular expression matching

882
00:37:34,901 --> 00:37:36,601
on our benchmarks.

883
00:37:36,601 --> 00:37:39,367
Um, and our new library
implements

884
00:37:39,367 --> 00:37:41,968
all of, uh, JavaScript
regular expressions.

885
00:37:41,968 --> 00:37:44,567
So there's no fallback
to any other engines.

886
00:37:44,567 --> 00:37:48,067
It's a full JavaScript regular
expression implementation.

887
00:37:50,100 --> 00:37:51,167
So what's in there?

888
00:37:51,167 --> 00:37:53,300
Um, well, first of all,

889
00:37:53,300 --> 00:37:56,033
um, the new
regular expression engine

890
00:37:56,033 --> 00:37:58,467
is based on an automata
approach.

891
00:37:58,467 --> 00:38:01,200
So from an input regular
expression,

892
00:38:01,200 --> 00:38:03,200
we build an automaton.

893
00:38:03,200 --> 00:38:04,567
And then we perform
analysis

894
00:38:04,567 --> 00:38:07,501
and optimization
on that automaton.

895
00:38:07,501 --> 00:38:10,300
And then from the resulting
rewritten automaton,

896
00:38:10,300 --> 00:38:12,167
we generate native code.

897
00:38:12,167 --> 00:38:13,968
So all of your regular
expressions

898
00:38:13,968 --> 00:38:18,734
are now executed,
uh, using native code.

899
00:38:18,734 --> 00:38:23,033
And, um, in our analysis
and optimization phase,

900
00:38:23,033 --> 00:38:26,734
we use a number of tricks
to, uh, to make,

901
00:38:26,734 --> 00:38:29,133
um, regular expression matching
cheaper.

902
00:38:29,133 --> 00:38:31,167
So we try
to avoid backtracking

903
00:38:31,167 --> 00:38:32,934
and we try
to reorder operations

904
00:38:32,934 --> 00:38:34,334
so that we perform
the least--

905
00:38:34,334 --> 00:38:37,167
the least expensive
operations first.

906
00:38:37,167 --> 00:38:39,400
So when you do regular
expression matching,

907
00:38:39,400 --> 00:38:42,334
um, most of the time,
you do find a match

908
00:38:42,334 --> 00:38:44,868
because you actually know
that it's going to be there--

909
00:38:44,868 --> 00:38:48,934
at--at--that it's going
to be there somewhere.

910
00:38:48,934 --> 00:38:50,467
But you start
from the beginning, right?

911
00:38:50,467 --> 00:38:53,567
And maybe you have to scan,
uh, through a lot.

912
00:38:53,567 --> 00:38:56,400
So basically, the common case
for regular expression matching

913
00:38:56,400 --> 00:38:57,868
is that you don't have
a match.

914
00:38:57,868 --> 00:38:59,033
For the first position,

915
00:38:59,033 --> 00:39:00,567
you're probably not going
to have a match.

916
00:39:00,567 --> 00:39:01,634
And so on.

917
00:39:01,634 --> 00:39:03,267
Um, so reordering
operations

918
00:39:03,267 --> 00:39:05,901
to perform the least expensive
operations first

919
00:39:05,901 --> 00:39:08,200
gives us an opportunity
to--to fail

920
00:39:08,200 --> 00:39:09,400
as quickly as possible,

921
00:39:09,400 --> 00:39:10,934
which is actually
pretty important

922
00:39:10,934 --> 00:39:14,834
when you do regular expression
matching.

923
00:39:14,834 --> 00:39:16,667
Okay, so let me, uh,
let me give you

924
00:39:16,667 --> 00:39:18,934
a couple of examples here.

925
00:39:18,934 --> 00:39:21,267
Um, so one of the things
that we do,

926
00:39:21,267 --> 00:39:23,567
uh, which is to avoid
backtracking,

927
00:39:23,567 --> 00:39:27,801
is to search for common parts
of--in--in alternatives first.

928
00:39:27,801 --> 00:39:30,601
So if you want to look
for either "Sun" or "Mon,"

929
00:39:30,601 --> 00:39:33,701
then the common part
of this regular expression

930
00:39:33,701 --> 00:39:37,267
is that the character
at index two

931
00:39:37,267 --> 00:39:39,000
is going to be "n."

932
00:39:39,000 --> 00:39:40,000
Okay.

933
00:39:40,000 --> 00:39:42,901
So if, uh,
so if you search

934
00:39:42,901 --> 00:39:45,133
and at the current position,

935
00:39:45,133 --> 00:39:47,667
the thing that's at index two
is not an "n,"

936
00:39:47,667 --> 00:39:48,868
then you're done.

937
00:39:48,868 --> 00:39:50,234
Then you don't have to do
anything more

938
00:39:50,234 --> 00:39:51,834
because then you know
that it can't match here.

939
00:39:51,834 --> 00:39:53,367
So you need to move on.

940
00:39:53,367 --> 00:39:55,400
Okay, so the more traditional
approach here

941
00:39:55,400 --> 00:39:58,467
would be to start out
by the first alternative.

942
00:39:58,467 --> 00:40:00,467
So you try to look
for "Sun."

943
00:40:00,467 --> 00:40:02,834
So you might find S.
You might find u.

944
00:40:02,834 --> 00:40:05,234
And then
you might not find n.

945
00:40:05,234 --> 00:40:06,734
Then at that point,
all you know

946
00:40:06,734 --> 00:40:08,601
is that you didn't match
"Sun."

947
00:40:08,601 --> 00:40:11,234
So you have to try
the other alternative.

948
00:40:11,234 --> 00:40:14,033
Uh, and that'll fail,
uh, by looking at the M.

949
00:40:14,033 --> 00:40:15,367
All right.

950
00:40:15,367 --> 00:40:18,434
But by, uh, looking
for common parts first,

951
00:40:18,434 --> 00:40:19,767
we just have to do
one comparison

952
00:40:19,767 --> 00:40:21,400
and we know that it's not
going to be here

953
00:40:21,400 --> 00:40:23,234
for any of the alternatives.

954
00:40:23,234 --> 00:40:26,100
So that avoids
a lot of backtracking.

955
00:40:26,100 --> 00:40:29,467
Um, another nice thing

956
00:40:29,467 --> 00:40:31,968
about the--our new regular
expression engine

957
00:40:31,968 --> 00:40:34,968
is that, uh, in V8, we have
an ASCII representation

958
00:40:34,968 --> 00:40:36,501
for most strings.

959
00:40:36,501 --> 00:40:38,734
Uh, because a lot of strings
that are actually used

960
00:40:38,734 --> 00:40:41,334
in JavaScript programs
are still ASCII strings.

961
00:40:41,334 --> 00:40:42,334
Uh, and that means

962
00:40:42,334 --> 00:40:44,000
that in a single compare
instruction,

963
00:40:44,000 --> 00:40:46,467
you can actually, uh,

964
00:40:46,467 --> 00:40:48,667
match up to four characters
at a time.

965
00:40:48,667 --> 00:40:51,000
So in order to search
for "foobar,"

966
00:40:51,000 --> 00:40:54,033
you'll just, um,
in an ASCII string,

967
00:40:54,033 --> 00:40:58,367
you'll just load four bytes
into Word

968
00:40:58,367 --> 00:40:59,767
and then you'll do a compare

969
00:40:59,767 --> 00:41:02,534
against the bit parent
that's "foob."

970
00:41:02,534 --> 00:41:05,767
Um, and then you're going
to load the next two characters,

971
00:41:05,767 --> 00:41:07,267
which is two bytes,

972
00:41:07,267 --> 00:41:10,534
and then you're going to do
a two-byte compare for those.

973
00:41:10,534 --> 00:41:13,868
Um, so that's really nice
to have the ability

974
00:41:13,868 --> 00:41:15,868
to actually match
four characters at a time.

975
00:41:15,868 --> 00:41:18,400
That's really fast.

976
00:41:18,400 --> 00:41:20,634
Okay, so here's an example
that shows you something

977
00:41:20,634 --> 00:41:21,934
about reordering.

978
00:41:21,934 --> 00:41:23,667
Um, so here's
a regular expression

979
00:41:23,667 --> 00:41:25,133
that looks for "foobar"

980
00:41:25,133 --> 00:41:27,267
that can be spelled
either with a normal F

981
00:41:27,267 --> 00:41:28,334
or a capital F

982
00:41:28,334 --> 00:41:30,534
and a normal B
or a capital B.

983
00:41:30,534 --> 00:41:33,634
And then it's going to capture
whatever was matched.

984
00:41:33,634 --> 00:41:36,968
Okay, so we want to perform
the cheap operations first.

985
00:41:36,968 --> 00:41:39,968
So we're going to try
to begin by matching "oo"

986
00:41:39,968 --> 00:41:42,067
and "ar"
at position one and four

987
00:41:42,067 --> 00:41:43,234
because those are just,
like,

988
00:41:43,234 --> 00:41:45,067
simple character
comparisons.

989
00:41:45,067 --> 00:41:46,367
And those are really quick.

990
00:41:46,367 --> 00:41:47,434
And if one of them fail,

991
00:41:47,434 --> 00:41:49,567
well, then we can skip
all the rest.

992
00:41:49,567 --> 00:41:51,000
Okay, so the next thing
we're going to do

993
00:41:51,000 --> 00:41:52,601
is look for either F
or a capital F

994
00:41:52,601 --> 00:41:53,834
at position zero.

995
00:41:53,834 --> 00:41:55,300
And we're going to look for a B
or a capital B

996
00:41:55,300 --> 00:41:56,667
at position three.

997
00:41:56,667 --> 00:41:58,501
And then finally,
we're going to--to perform

998
00:41:58,501 --> 00:42:00,367
the actual capture
operation.

999
00:42:00,367 --> 00:42:03,968
Um, so the reordering here
is really just to get

1000
00:42:03,968 --> 00:42:06,567
the cheap operations first
because that allows us

1001
00:42:06,567 --> 00:42:08,968
to fail early and quickly.

1002
00:42:11,400 --> 00:42:12,934
Good.

1003
00:42:12,934 --> 00:42:15,267
So that's, uh, that's our new
regular expression engine.

1004
00:42:15,267 --> 00:42:17,200
So another thing
that we've done recently

1005
00:42:17,200 --> 00:42:19,501
is to change our compiler.

1006
00:42:19,501 --> 00:42:22,767
Uh, so the original compiler
was extremely simple.

1007
00:42:22,767 --> 00:42:25,300
Uh, just build an abstract
syntax tree.

1008
00:42:25,300 --> 00:42:27,801
It did no static analysis
of any kind.

1009
00:42:27,801 --> 00:42:29,467
It did no
register allocation.

1010
00:42:29,467 --> 00:42:31,767
So it just built an abstract
syntax tree.

1011
00:42:31,767 --> 00:42:33,701
And one pass
over the abstract syntax tree,

1012
00:42:33,701 --> 00:42:35,133
it--it would generate
a code.

1013
00:42:35,133 --> 00:42:36,634
Period.

1014
00:42:36,634 --> 00:42:39,467
Um, so we've now implemented
a new compile infrastructure,

1015
00:42:39,467 --> 00:42:41,734
which performs register
allocation.

1016
00:42:41,734 --> 00:42:43,300
It's still
a one-pass compiler.

1017
00:42:43,300 --> 00:42:45,234
Um, so for JavaScript,

1018
00:42:45,234 --> 00:42:48,601
since you get all of your code
over the network,

1019
00:42:48,601 --> 00:42:50,067
you need
your JavaScript engine

1020
00:42:50,067 --> 00:42:53,200
to--to be able
to run the code quickly.

1021
00:42:53,200 --> 00:42:56,934
So you need to, uh,
to have a fast compiler.

1022
00:42:56,934 --> 00:42:58,267
So it's still
a one-pass compiler.

1023
00:42:58,267 --> 00:42:59,901
But now it actually
does its best

1024
00:42:59,901 --> 00:43:02,367
to, uh, to do register
allocation as well.

1025
00:43:02,367 --> 00:43:04,133
And--and we're pretty
excited about this.

1026
00:43:04,133 --> 00:43:06,400
And we think that it'll--
that it'll form the basis

1027
00:43:06,400 --> 00:43:10,300
for further native code
optimizations in--in V8.

1028
00:43:13,133 --> 00:43:16,033
Okay, so that's what I wanted
to say about recent stuff.

1029
00:43:16,033 --> 00:43:18,367
Um, so now I'm going to talk
to something

1030
00:43:18,367 --> 00:43:19,934
that's quite different,

1031
00:43:19,934 --> 00:43:22,167
uh, but that I think
is really, really important.

1032
00:43:22,167 --> 00:43:26,767
Namely how well
your JavaScript engines scale

1033
00:43:26,767 --> 00:43:29,734
to deal with very large
applications.

1034
00:43:29,734 --> 00:43:34,267
Um, so why is that
important?

1035
00:43:34,267 --> 00:43:37,701
Well, so web applications
are becoming bigger and bigger

1036
00:43:37,701 --> 00:43:39,501
and more complex.

1037
00:43:39,501 --> 00:43:41,634
And with
the increased complexity,

1038
00:43:41,634 --> 00:43:43,267
you get more objects.

1039
00:43:43,267 --> 00:43:46,534
And more objects
put extra, uh, stress

1040
00:43:46,534 --> 00:43:48,701
on your memory management
system.

1041
00:43:48,701 --> 00:43:52,400
So if you do not have
a system that scale

1042
00:43:52,400 --> 00:43:53,601
to handle all of
these objects,

1043
00:43:53,601 --> 00:43:55,701
your performance
will suffer.

1044
00:43:55,701 --> 00:44:00,000
Um, so not only are applications
becoming bigger,

1045
00:44:00,000 --> 00:44:01,801
which means that they get
more objects,

1046
00:44:01,801 --> 00:44:04,968
but also, a lot of browsers
are still single process.

1047
00:44:04,968 --> 00:44:06,968
And most single process
browsers,

1048
00:44:06,968 --> 00:44:09,634
um, when you start up
multiple tabs

1049
00:44:09,634 --> 00:44:11,334
with multiple applications,

1050
00:44:11,334 --> 00:44:13,534
all of your JavaScript objects
are going to be allocated

1051
00:44:13,534 --> 00:44:16,334
in the same JavaScript
object heap.

1052
00:44:16,334 --> 00:44:19,467
Which means that you actually
get a lot of objects

1053
00:44:19,467 --> 00:44:21,300
in your JavaScript heap.

1054
00:44:21,300 --> 00:44:24,267
So if your memory management
system has to look

1055
00:44:24,267 --> 00:44:27,701
at all objects
for every garbage collection,

1056
00:44:27,701 --> 00:44:29,901
that's going to hurt you.

1057
00:44:29,901 --> 00:44:31,934
Um, right.

1058
00:44:31,934 --> 00:44:34,267
So it is actually
really important

1059
00:44:34,267 --> 00:44:38,534
that your JavaScript execution
is--is good

1060
00:44:38,534 --> 00:44:40,367
and is fast in these situations
as well.

1061
00:44:40,367 --> 00:44:41,667
And it's important now.

1062
00:44:41,667 --> 00:44:44,100
It's not--it's not only
for, like, the future.

1063
00:44:44,100 --> 00:44:45,767
It's also important now.

1064
00:44:45,767 --> 00:44:47,801
Um, right.

1065
00:44:47,801 --> 00:44:50,267
So our approach
to scalability

1066
00:44:50,267 --> 00:44:52,267
is to use generational
garbage collection,

1067
00:44:52,267 --> 00:44:54,100
as I've just
told you about.

1068
00:44:54,100 --> 00:44:57,434
Um, right.

1069
00:44:57,434 --> 00:45:00,234
So I've done a little
experiment here.

1070
00:45:00,234 --> 00:45:02,968
And I should say right now

1071
00:45:02,968 --> 00:45:05,200
that this is really,
really artificial.

1072
00:45:05,200 --> 00:45:08,100
So take all of this
with a grain of salt.

1073
00:45:08,100 --> 00:45:10,701
But it does--it does
illustrate my point.

1074
00:45:10,701 --> 00:45:13,434
Um, so my scalability
experiment,

1075
00:45:13,434 --> 00:45:16,167
um, was to take
the raytrace benchmark

1076
00:45:16,167 --> 00:45:19,067
from the V8 benchmark suite
and then run it

1077
00:45:19,067 --> 00:45:20,701
a number of times.

1078
00:45:20,701 --> 00:45:21,901
And on each iteration,

1079
00:45:21,901 --> 00:45:24,033
I'm going to allocate
some extra memory

1080
00:45:24,033 --> 00:45:25,868
in the JavaScript heap.

1081
00:45:25,868 --> 00:45:28,667
Um, and with V8,
the data structure

1082
00:45:28,667 --> 00:45:30,000
that I'm going to allocate,

1083
00:45:30,000 --> 00:45:32,534
I'm going to add one megabyte
of extra live data

1084
00:45:32,534 --> 00:45:33,934
per iteration.

1085
00:45:33,934 --> 00:45:36,634
And then I'm just going
to map out the performance--

1086
00:45:36,634 --> 00:45:39,734
so the benchmark score--
over these iterations

1087
00:45:39,734 --> 00:45:43,767
with an increased amount
of objects in your heap.

1088
00:45:43,767 --> 00:45:47,701
And the result looks like this
for, uh, for three browsers.

1089
00:45:47,701 --> 00:45:50,501
Um, so as you can see,

1090
00:45:50,501 --> 00:45:52,200
the performance
characteristics here

1091
00:45:52,200 --> 00:45:53,834
are quite different.

1092
00:45:53,834 --> 00:45:56,133
Um, so what we want
to get to here

1093
00:45:56,133 --> 00:45:59,400
is basically having
a straight line.

1094
00:45:59,400 --> 00:46:00,667
So as you can see,

1095
00:46:00,667 --> 00:46:04,634
uh, Chromium running V8
is not getting a straight line.

1096
00:46:04,634 --> 00:46:07,868
But it's also not, like,
dropping completely.

1097
00:46:07,868 --> 00:46:10,601
Um, and that's--that's pretty
much what you get

1098
00:46:10,601 --> 00:46:13,267
when you use a generational
garbage collection like we do.

1099
00:46:13,267 --> 00:46:16,100
So it does cost
to have larger heaps,

1100
00:46:16,100 --> 00:46:19,033
but your performance
does not completely degrade.

1101
00:46:19,033 --> 00:46:21,033
Um, so another
interesting thing

1102
00:46:21,033 --> 00:46:22,200
that you can see
from this graph

1103
00:46:22,200 --> 00:46:24,767
is that you have, like,
down spikes.

1104
00:46:24,767 --> 00:46:27,267
Um, so those down spikes
are when you get

1105
00:46:27,267 --> 00:46:29,400
to the full compacting
collections.

1106
00:46:29,400 --> 00:46:30,701
So if you actually get
to a point

1107
00:46:30,701 --> 00:46:33,067
where you need to do
a full compacting collection,

1108
00:46:33,067 --> 00:46:37,200
that's going to be visible
on graphs like, uh, like these.

1109
00:46:37,200 --> 00:46:38,300
So the interesting thing here

1110
00:46:38,300 --> 00:46:42,234
is that, like, Firefox 3.5,
beta 4,

1111
00:46:42,234 --> 00:46:43,400
uh, seems to be doing
very well

1112
00:46:43,400 --> 00:46:45,968
when it comes to scalability.

1113
00:46:45,968 --> 00:46:48,167
Uh, the benchmark score
is not that impressive

1114
00:46:48,167 --> 00:46:49,434
on the other hand.

1115
00:46:49,434 --> 00:46:52,901
Uh, Safari is doing really well
on the benchmark score.

1116
00:46:52,901 --> 00:46:54,667
Uh, but it seems
that there's something

1117
00:46:54,667 --> 00:46:57,934
like a full scan of the heap
on each garbage collection

1118
00:46:57,934 --> 00:47:01,801
because if you add extra data
to the heap,

1119
00:47:01,801 --> 00:47:04,567
then already at, like,
five megabytes,

1120
00:47:04,567 --> 00:47:07,033
they're at a third
of the speed that they had

1121
00:47:07,033 --> 00:47:11,267
with, uh, with a freshly,
uh, started browser.

1122
00:47:11,267 --> 00:47:13,300
Um, so I think
this really matters

1123
00:47:13,300 --> 00:47:16,133
because this is--I mean,
this is a benchmark, right?

1124
00:47:16,133 --> 00:47:18,901
So this is a benchmark
that's in our benchmark suite.

1125
00:47:18,901 --> 00:47:20,601
And this tells you something
about how valid

1126
00:47:20,601 --> 00:47:23,734
those benchmark results are
in the real world.

1127
00:47:23,734 --> 00:47:27,567
So if you have
a single process browser

1128
00:47:27,567 --> 00:47:29,133
and you open multiple tabs,

1129
00:47:29,133 --> 00:47:31,067
that's going to lead
to a lot of objects.

1130
00:47:31,067 --> 00:47:33,801
And, uh, and then
your performance

1131
00:47:33,801 --> 00:47:35,734
is going to be more like
what's on the right

1132
00:47:35,734 --> 00:47:38,367
of this, uh,
of this graph.

1133
00:47:38,367 --> 00:47:40,534
So I think that--that we need
to put some more emphasis

1134
00:47:40,534 --> 00:47:41,734
on this.

1135
00:47:41,734 --> 00:47:44,734
Uh, and I think
that it's really important,

1136
00:47:44,734 --> 00:47:48,133
um, because it's--
it's really important for--

1137
00:47:48,133 --> 00:47:50,234
for the real live
situations,

1138
00:47:50,234 --> 00:47:53,567
having many tabs
or having big applications.

1139
00:47:53,567 --> 00:47:56,100
Um, so in order
to put a bit of focus on this,

1140
00:47:56,100 --> 00:48:00,133
uh, we've, um, we've published
a new benchmark

1141
00:48:00,133 --> 00:48:01,934
in the V8 benchmark suite.

1142
00:48:01,934 --> 00:48:04,334
Which is again completely
artificial.

1143
00:48:04,334 --> 00:48:08,133
So it builds a splay tree,
uh, roughly the size

1144
00:48:08,133 --> 00:48:10,601
of, like, 30 megabytes,
something like that.

1145
00:48:10,601 --> 00:48:12,734
And then it just performs
operations on the splay tree.

1146
00:48:12,734 --> 00:48:14,534
Which means that it allocates
new nodes,

1147
00:48:14,534 --> 00:48:16,100
it modifies the splay tree,

1148
00:48:16,100 --> 00:48:19,934
and it garbage collects, uh,
nodes that have been removed.

1149
00:48:19,934 --> 00:48:21,300
Um, right,

1150
00:48:21,300 --> 00:48:23,067
so we really want to try
to, like,

1151
00:48:23,067 --> 00:48:24,801
put some emphasis on this.

1152
00:48:24,801 --> 00:48:27,701
Uh, we want scalability.
We want browsers to be scalable.

1153
00:48:27,701 --> 00:48:30,434
We want people to actually get
the JavaScript performance

1154
00:48:30,434 --> 00:48:31,801
that they expect

1155
00:48:31,801 --> 00:48:35,133
when they run the JavaScript
benchmarks out there.

1156
00:48:35,133 --> 00:48:38,567
Uh, those should basically
reflect what you get in reality.

1157
00:48:38,567 --> 00:48:41,267
So again, this experiment
is completely artificial.

1158
00:48:41,267 --> 00:48:44,868
Uh, if you want to try this,
uh, take your browsers,

1159
00:48:44,868 --> 00:48:47,901
load a number of tabs,
run benchmarks,

1160
00:48:47,901 --> 00:48:49,234
um, or try something else.

1161
00:48:49,234 --> 00:48:51,000
Try writing really big
web applications

1162
00:48:51,000 --> 00:48:53,267
and see how well,
uh, JavaScript behaves

1163
00:48:53,267 --> 00:48:56,934
under a bit of stress.

1164
00:48:56,934 --> 00:49:00,567
Good. So that finishes
my scalability rant.

1165
00:49:00,567 --> 00:49:02,300
Um, good.

1166
00:49:02,300 --> 00:49:03,334
So let me tell you a bit

1167
00:49:03,334 --> 00:49:04,801
about the performance
bottlenecks

1168
00:49:04,801 --> 00:49:07,734
that I see for--
for V8 currently.

1169
00:49:07,734 --> 00:49:13,701
Um, so one of the bottlenecks
that we have is that, um,

1170
00:49:13,701 --> 00:49:17,667
we only generate
one, uh, fully general version

1171
00:49:17,667 --> 00:49:19,801
of all code that we generate.

1172
00:49:19,801 --> 00:49:21,667
That means that we are not
basically allowed

1173
00:49:21,667 --> 00:49:24,267
to have that many assumptions
in our code.

1174
00:49:24,267 --> 00:49:28,734
Because we need to handle
all the special cases

1175
00:49:28,734 --> 00:49:31,667
in the code that we generate.

1176
00:49:31,667 --> 00:49:33,334
So that means that we have
a lot of checking

1177
00:49:33,334 --> 00:49:35,968
for basically exceptional
situations in our code,

1178
00:49:35,968 --> 00:49:39,934
like situations that basically
do not happen in reality.

1179
00:49:39,934 --> 00:49:43,634
Um, so one thing
that we should explore

1180
00:49:43,634 --> 00:49:47,601
is generating multiple versions
of the same code.

1181
00:49:47,601 --> 00:49:49,367
So generating--
uh, in the beginning,

1182
00:49:49,367 --> 00:49:52,968
generating a really optimized
version of the code

1183
00:49:52,968 --> 00:49:55,534
that avoids a lot
of the checking.

1184
00:49:55,534 --> 00:49:57,767
And then if some
of our checks fail,

1185
00:49:57,767 --> 00:50:00,701
then basically bail out
to a slower version of the code.

1186
00:50:00,701 --> 00:50:03,200
So at that point, generate
another version of the code.

1187
00:50:03,200 --> 00:50:06,901
So that should give us
a big performance gain.

1188
00:50:06,901 --> 00:50:11,501
Um, another,
uh, bottleneck

1189
00:50:11,501 --> 00:50:15,067
is that our use
of inline caching

1190
00:50:15,067 --> 00:50:18,400
is based on calls to stubs.

1191
00:50:18,400 --> 00:50:20,734
So we generate these stubs

1192
00:50:20,734 --> 00:50:22,334
and then we use,
like, a call instruction

1193
00:50:22,334 --> 00:50:24,234
to actually get
to that code.

1194
00:50:24,234 --> 00:50:28,501
Um, and that's good
for a code size

1195
00:50:28,501 --> 00:50:30,601
because we just have
a call instruction in there.

1196
00:50:30,601 --> 00:50:32,934
But it's not necessarily
the best thing we can do

1197
00:50:32,934 --> 00:50:34,133
for our performance.

1198
00:50:34,133 --> 00:50:35,400
So in some situations,

1199
00:50:35,400 --> 00:50:38,667
we might actually want
to inline the code instead

1200
00:50:38,667 --> 00:50:40,501
directly in the code stream.

1201
00:50:40,501 --> 00:50:42,434
So instead of having
the call,

1202
00:50:42,434 --> 00:50:44,234
we can just have the code
directly there.

1203
00:50:44,234 --> 00:50:46,434
Uh, and that
actually matters.

1204
00:50:46,434 --> 00:50:51,234
Uh, and we have done that
for a couple of simple cases

1205
00:50:51,234 --> 00:50:52,634
of loads.

1206
00:50:52,634 --> 00:50:54,167
And it really does matter.

1207
00:50:54,167 --> 00:50:56,067
So the downside to that
is code size.

1208
00:50:56,067 --> 00:51:01,400
So your code becomes bigger
when you actually inline.

1209
00:51:01,400 --> 00:51:02,734
Okay, so another issue,

1210
00:51:02,734 --> 00:51:04,901
which is basically,
uh, related

1211
00:51:04,901 --> 00:51:07,300
to doing more inlining

1212
00:51:07,300 --> 00:51:08,968
is our write barrier.

1213
00:51:08,968 --> 00:51:12,167
Um, so since we use
generational garbage collection,

1214
00:51:12,167 --> 00:51:15,067
um, and we, uh,

1215
00:51:15,067 --> 00:51:18,300
garbage collect
the young generation often,

1216
00:51:18,300 --> 00:51:20,567
we need to know
about all pointers

1217
00:51:20,567 --> 00:51:22,234
into the young generation.

1218
00:51:22,234 --> 00:51:23,934
And that includes
all of the pointers

1219
00:51:23,934 --> 00:51:25,667
from objects
in the old generation

1220
00:51:25,667 --> 00:51:27,801
to pointers
in the new generation.

1221
00:51:27,801 --> 00:51:30,133
And that means that whenever
we store a pointer

1222
00:51:30,133 --> 00:51:31,968
in an old generation object,

1223
00:51:31,968 --> 00:51:33,767
we might have
to record somewhere

1224
00:51:33,767 --> 00:51:35,968
that this object
is actually referring

1225
00:51:35,968 --> 00:51:37,534
to a new space object.

1226
00:51:37,534 --> 00:51:39,801
And that's done by something
called a write barrier.

1227
00:51:39,801 --> 00:51:41,467
And right now,

1228
00:51:41,467 --> 00:51:42,868
our write barrier is a bit
complicated.

1229
00:51:42,868 --> 00:51:46,901
It has a lot of instructions,
and it's a bit slow.

1230
00:51:46,901 --> 00:51:48,968
So we should experiment
with--with new ways

1231
00:51:48,968 --> 00:51:50,868
of implementing
our write barrier.

1232
00:51:50,868 --> 00:51:53,334
Um, and the reason
why that's related

1233
00:51:53,334 --> 00:51:55,667
to, uh, inlining more code

1234
00:51:55,667 --> 00:51:58,334
is that since our write
barrier's pretty big,

1235
00:51:58,334 --> 00:52:01,868
it's not really practical
to inline stores

1236
00:52:01,868 --> 00:52:03,767
directly in the code
because all stores

1237
00:52:03,767 --> 00:52:06,601
need to have the write barrier
inline as well.

1238
00:52:06,601 --> 00:52:08,801
And that will lead
to a lot of, uh,

1239
00:52:08,801 --> 00:52:12,801
of code size, uh, increase.

1240
00:52:12,801 --> 00:52:14,133
Okay,
and the last thing here,

1241
00:52:14,133 --> 00:52:15,901
I don't really want
to talk much about.

1242
00:52:15,901 --> 00:52:18,100
But--but basically,
there are a lot of global loads

1243
00:52:18,100 --> 00:52:19,567
in JavaScript code.

1244
00:52:19,567 --> 00:52:22,801
And we handle global loads
the same way as any other loads.

1245
00:52:22,801 --> 00:52:24,300
And basically,
we don't have to.

1246
00:52:24,300 --> 00:52:26,767
So we could generate
better code for that.

1247
00:52:26,767 --> 00:52:29,200
Um, so another thing
that I didn't put up here,

1248
00:52:29,200 --> 00:52:31,033
but which is also
really important,

1249
00:52:31,033 --> 00:52:32,801
is, uh, DOM performance.

1250
00:52:32,801 --> 00:52:35,801
And basically, we haven't
done much, uh, in that area

1251
00:52:35,801 --> 00:52:37,601
to really,
really optimize it.

1252
00:52:37,601 --> 00:52:39,601
Um, so that's another thing
that we should do.

1253
00:52:39,601 --> 00:52:42,300
Uh, we should look more
at DOM performance.

1254
00:52:42,300 --> 00:52:45,767
So the interaction
between JavaScript

1255
00:52:45,767 --> 00:52:48,300
and--and the DOM.

1256
00:52:51,000 --> 00:52:52,000
Good.

1257
00:52:52,000 --> 00:52:53,634
So to summarize,

1258
00:52:53,634 --> 00:52:55,601
V8 was designed
both for speed

1259
00:52:55,601 --> 00:52:57,934
and for scalability.

1260
00:52:57,934 --> 00:53:00,367
Uh, the goal of V8 is
to raise the performance bar

1261
00:53:00,367 --> 00:53:01,634
for JavaScript.

1262
00:53:01,634 --> 00:53:03,634
So we want to continue
to push

1263
00:53:03,634 --> 00:53:07,667
and see if we can make
JavaScript even faster.

1264
00:53:07,667 --> 00:53:12,667
And, um, we don't want
to just push

1265
00:53:12,667 --> 00:53:14,634
for Google
and for Google Chrome.

1266
00:53:14,634 --> 00:53:17,934
We really want to--
to try to see if we can--

1267
00:53:17,934 --> 00:53:22,667
if we can inspire other
JavaScript vendors as well.

1268
00:53:22,667 --> 00:53:25,534
And therefore,
our full source code

1269
00:53:25,534 --> 00:53:28,200
is available
under a BSD license.

1270
00:53:28,200 --> 00:53:29,501
And, unfortunately,

1271
00:53:29,501 --> 00:53:31,534
the URL scrolled out of
my slides here.

1272
00:53:31,534 --> 00:53:35,167
But it's at
code.google.com/p/v8.

1273
00:53:35,167 --> 00:53:37,167
Should be pretty easy
to find.

1274
00:53:37,167 --> 00:53:39,467
So the graph
that I've put up here

1275
00:53:39,467 --> 00:53:40,868
that I'd like to end with

1276
00:53:40,868 --> 00:53:44,100
is the, um,
is what has happened to

1277
00:53:44,100 --> 00:53:46,434
the V8 benchmark score
over time.

1278
00:53:46,434 --> 00:53:49,701
So, um, the versions
that you see on the left

1279
00:53:49,701 --> 00:53:51,367
are Google Chrome versions.

1280
00:53:51,367 --> 00:53:54,667
So this basically started
in September of 2008

1281
00:53:54,667 --> 00:53:56,901
with a 1.0 beta.

1282
00:53:56,901 --> 00:53:59,100
And since then,
we've just continued to push.

1283
00:53:59,100 --> 00:54:02,234
And we will continue
to do that.

1284
00:54:02,234 --> 00:54:04,300
So that's all.
Thanks.

1285
00:54:04,300 --> 00:54:08,234
[applause]

1286
00:54:11,701 --> 00:54:13,934
Questions.

1287
00:54:13,934 --> 00:54:16,467
Yes.

1288
00:54:23,901 --> 00:54:25,167
Yeah, that's a good point.

1289
00:54:25,167 --> 00:54:28,300
So the question is,
in my example of hidden classes

1290
00:54:28,300 --> 00:54:31,834
and hidden class transitions,
I added first X and then Y.

1291
00:54:31,834 --> 00:54:34,901
So what would happen
if I added Y first and then X?

1292
00:54:34,901 --> 00:54:37,601
And the, uh, and the answer is
that that would be

1293
00:54:37,601 --> 00:54:39,667
a different hidden class.

1294
00:54:39,667 --> 00:54:43,234
Um, so, uh,
it's really common

1295
00:54:43,234 --> 00:54:44,767
for objects to be allocat--

1296
00:54:44,767 --> 00:54:47,467
to be generated
in exactly the same way.

1297
00:54:47,467 --> 00:54:49,100
Um, so that's basically
what saves us.

1298
00:54:49,100 --> 00:54:50,501
But you're right.

1299
00:54:50,501 --> 00:54:52,434
They're objects that basically
have the same structure,

1300
00:54:52,434 --> 00:54:54,167
namely a Y-property
and an X-property,

1301
00:54:54,167 --> 00:54:57,167
um, they can actually
get completely different maps

1302
00:54:57,167 --> 00:55:00,167
if you first add Y and then X
and then in another place

1303
00:55:00,167 --> 00:55:01,400
add X and then Y.

1304
00:55:01,400 --> 00:55:05,667
Those would be separate
hidden classes.

1305
00:55:05,667 --> 00:55:10,601
Yeah.

1306
00:55:10,601 --> 00:55:12,467
Okay. So what if you declare
an object

1307
00:55:12,467 --> 00:55:14,767
through an object literal
and not through a function?

1308
00:55:14,767 --> 00:55:16,434
Uh, that's not going
to be a problem

1309
00:55:16,434 --> 00:55:18,767
because object literals
are also created

1310
00:55:18,767 --> 00:55:21,400
based on a function--
namely the object function.

1311
00:55:21,400 --> 00:55:24,567
And the object function
has an initial map.

1312
00:55:24,567 --> 00:55:28,567
Um, so basically,
uh, the same thing works.

1313
00:55:28,567 --> 00:55:30,901
Yeah.

1314
00:55:35,968 --> 00:55:37,100
Yeah, that's a good question.

1315
00:55:37,100 --> 00:55:38,434
So the question is

1316
00:55:38,434 --> 00:55:42,133
do we only apply this
to user-defined objects

1317
00:55:42,133 --> 00:55:45,267
or do we also use this
on, like, built-in stuff

1318
00:55:45,267 --> 00:55:47,501
like date, math, number,
whatever?

1319
00:55:47,501 --> 00:55:49,467
And the answer is that,
yes, we also do it

1320
00:55:49,467 --> 00:55:50,801
on built-in stuff.

1321
00:55:50,801 --> 00:55:54,033
Uh, and to go a bit deeper,

1322
00:55:54,033 --> 00:55:56,901
our built-in stuff is actually
implemented in JavaScript.

1323
00:55:56,901 --> 00:55:59,434
So we don't implement that
in C++.

1324
00:55:59,434 --> 00:56:02,133
We actually have it implemented
in JavaScript--a lot of it.

1325
00:56:02,133 --> 00:56:06,200
Um, so that means that basically
the same thing applies.

1326
00:56:06,200 --> 00:56:08,767
So it's going to go through
exactly the same path.

1327
00:56:08,767 --> 00:56:12,534
And the cool thing about that
is that if we improve

1328
00:56:12,534 --> 00:56:14,834
our overall JavaScript
performance,

1329
00:56:14,834 --> 00:56:18,334
we're also going to improve
the speed of our libraries.

1330
00:56:18,334 --> 00:56:20,868
Um, so that's one cool thing
about having libraries

1331
00:56:20,868 --> 00:56:22,367
written in JavaScript.

1332
00:56:22,367 --> 00:56:25,167
Another cool thing
is that, um,

1333
00:56:25,167 --> 00:56:29,801
uh, it's really easy and quick
to go change stuff.

1334
00:56:29,801 --> 00:56:32,734
Um, so it also does lead to--

1335
00:56:32,734 --> 00:56:34,868
to some extra complication

1336
00:56:34,868 --> 00:56:37,334
in the sense that in order
to set up

1337
00:56:37,334 --> 00:56:39,634
your math, number,
date objects,

1338
00:56:39,634 --> 00:56:43,067
you actually have to look
at JavaScript code.

1339
00:56:43,067 --> 00:56:44,968
You actually have to compile
JavaScript code.

1340
00:56:44,968 --> 00:56:48,067
So to overcome that,
uh, we--we use something

1341
00:56:48,067 --> 00:56:49,901
called snapshotting.

1342
00:56:49,901 --> 00:56:53,033
So, um, yes,

1343
00:56:53,033 --> 00:56:54,534
this is becoming
a longer explanation.

1344
00:56:54,534 --> 00:56:56,100
Sorry about that.

1345
00:56:56,100 --> 00:56:57,767
So--so basically,
in the beginning,

1346
00:56:57,767 --> 00:56:59,868
the first time that we--
that we, uh--

1347
00:56:59,868 --> 00:57:01,200
so when we build V8,

1348
00:57:01,200 --> 00:57:04,467
we start up V8 once,
we load the basic libraries.

1349
00:57:04,467 --> 00:57:07,667
That gives us a heap
that contains all of the code

1350
00:57:07,667 --> 00:57:09,033
for our basic libraries.

1351
00:57:09,033 --> 00:57:12,968
We dump that heap
as a binary image to a file.

1352
00:57:12,968 --> 00:57:16,734
And then we integrate
that binary data

1353
00:57:16,734 --> 00:57:19,167
into a new version of V8
that we built

1354
00:57:19,167 --> 00:57:20,767
so that when you start V8,

1355
00:57:20,767 --> 00:57:22,868
even though your libraries
are written in JavaScript,

1356
00:57:22,868 --> 00:57:25,534
you don't have to--to pass
and compile any JavaScript code

1357
00:57:25,534 --> 00:57:26,701
to get your native libraries.

1358
00:57:26,701 --> 00:57:29,000
All you do is just slurp
in that binary data

1359
00:57:29,000 --> 00:57:31,634
and you're up and running.

1360
00:57:31,634 --> 00:57:33,267
Yeah.

1361
00:57:40,067 --> 00:57:41,200
So the question is

1362
00:57:41,200 --> 00:57:43,200
"if there are any JavaScript
design patterns

1363
00:57:43,200 --> 00:57:46,100
that I know of that perform
better than others."

1364
00:57:46,100 --> 00:57:49,801
Um, so my answer to that
would be no.

1365
00:57:49,801 --> 00:57:52,033
But also, my answer to that
should be that,

1366
00:57:52,033 --> 00:57:55,267
uh, that it shouldn't matter
that much.

1367
00:57:55,267 --> 00:57:57,767
So basically, you shouldn't
worry about it.

1368
00:57:57,767 --> 00:58:00,167
We should hopefully be able
to make it fast.

1369
00:58:00,167 --> 00:58:02,834
Um, but as you've seen
with the techniques

1370
00:58:02,834 --> 00:58:04,267
that we used here,

1371
00:58:04,267 --> 00:58:08,167
we're kind of, uh, somehow
relying on user build to--

1372
00:58:08,167 --> 00:58:10,400
to do something
that's, like, well structured,

1373
00:58:10,400 --> 00:58:13,133
uses abstractions,
and does not,

1374
00:58:13,133 --> 00:58:17,834
like, uh, try
to be overly general

1375
00:58:17,834 --> 00:58:20,367
and try to have, like, code
that's, like, really using

1376
00:58:20,367 --> 00:58:21,701
a million different--

1377
00:58:21,701 --> 00:58:23,634
operating on a million
different types.

1378
00:58:23,634 --> 00:58:27,367
But, um, but that shouldn't
really be an issue

1379
00:58:27,367 --> 00:58:29,067
because in--

1380
00:58:29,067 --> 00:58:30,434
in most application code
that you write,

1381
00:58:30,434 --> 00:58:32,501
you might have parts
of the code that's like that

1382
00:58:32,501 --> 00:58:33,801
that's really generic

1383
00:58:33,801 --> 00:58:37,200
and then you have most
of your code, which is not.

1384
00:58:37,200 --> 00:58:38,968
So basically, you shouldn't
have to worry about it.

1385
00:58:38,968 --> 00:58:42,100
That should be, uh,
that should be us worrying.

1386
00:58:53,767 --> 00:58:55,167
Oh.

1387
00:58:59,167 --> 00:59:01,801
Okay, so, uh,
the question is if I can--

1388
00:59:01,801 --> 00:59:03,067
can give some information

1389
00:59:03,067 --> 00:59:06,367
about other browsers
that are starting to use--

1390
00:59:06,367 --> 00:59:07,868
that are using
these techniques

1391
00:59:07,868 --> 00:59:11,167
and, uh, also if it's being
fed back to WebKit.

1392
00:59:11,167 --> 00:59:12,167
Yeah.

1393
00:59:12,167 --> 00:59:15,467
So, um...

1394
00:59:15,467 --> 00:59:19,167
so, uh,
Apple's JavaScript engine,

1395
00:59:19,167 --> 00:59:21,634
I guess it's called Nitro
by now,

1396
00:59:21,634 --> 00:59:25,000
uh, is using
these techniques as well,

1397
00:59:25,000 --> 00:59:26,767
which is really cool.

1398
00:59:26,767 --> 00:59:28,300
So I think that's--
that's great.

1399
00:59:28,300 --> 00:59:30,133
And they're getting
great performance gains

1400
00:59:30,133 --> 00:59:32,968
the same way that we did
by using these techniques.

1401
00:59:32,968 --> 00:59:35,501
So they use, uh,
what we call hidden classes

1402
00:59:35,501 --> 00:59:37,934
and inline caching as well.

1403
00:59:37,934 --> 00:59:39,701
Uh, I think they call
their hidden classes

1404
00:59:39,701 --> 00:59:41,267
structure IDs or something
like that.

1405
00:59:41,267 --> 00:59:42,467
But they use
the same techniques,

1406
00:59:42,467 --> 00:59:43,667
which is really cool.

1407
00:59:43,667 --> 00:59:45,968
Um, feeding it back
to WebKit,

1408
00:59:45,968 --> 00:59:48,701
yes, we are doing that
in the sense

1409
00:59:48,701 --> 00:59:51,467
that the binding layer,
so the--

1410
00:59:51,467 --> 00:59:55,000
the layer that binds V8
into the DOM

1411
00:59:55,000 --> 00:59:57,367
is being upstreamed
to WebKit.

1412
00:59:57,367 --> 00:59:59,367
So that actually lives
at WebKit now.

1413
00:59:59,367 --> 01:00:03,567
Um, so hopefully it should be
fairly easy going forward

1414
01:00:03,567 --> 01:00:08,434
to use V8 instead of Nitro
if you want to in WebKit.

1415
01:00:08,434 --> 01:00:11,367
man: Any--over here.
Over here.

1416
01:00:11,367 --> 01:00:12,667
Ager: Oh, yes.

1417
01:00:12,667 --> 01:00:14,634
man:
Any performance boosts

1418
01:00:14,634 --> 01:00:18,467
to the lambda
functional closures

1419
01:00:18,467 --> 01:00:22,734
optimizing
the call stacks?

1420
01:00:22,734 --> 01:00:24,400
Ager: I'm not sure
I understand the question.

1421
01:00:24,400 --> 01:00:26,167
Could you repeat, please?

1422
01:00:26,167 --> 01:00:27,467
man: Is there
a performance boost

1423
01:00:27,467 --> 01:00:32,801
to the handling of the lambda
functions closures?

1424
01:00:32,801 --> 01:00:34,667
Ager: Oh, if we have
any performance boosts

1425
01:00:34,667 --> 01:00:36,467
on--on closures.

1426
01:00:36,467 --> 01:00:39,667
Uh...

1427
01:00:39,667 --> 01:00:41,501
so...

1428
01:00:41,501 --> 01:00:43,767
well, basically,
I mean, that code is handled

1429
01:00:43,767 --> 01:00:45,133
like--like all other code.

1430
01:00:45,133 --> 01:00:46,934
So it gets, like,
the same kind of benefits

1431
01:00:46,934 --> 01:00:48,534
that--that the rest
of the code does.

1432
01:00:48,534 --> 01:00:50,067
So--so yes.

1433
01:00:54,801 --> 01:00:56,767
So I think we're running
out of time.

1434
01:00:56,767 --> 01:00:58,534
So--so I think
I should stop now.

1435
01:00:58,534 --> 01:01:01,701
So you're all welcome
to come talk to me afterwards.

1436
01:01:01,701 --> 01:01:05,033
So if you have other questions,
please come talk to me.

1437
01:01:05,033 --> 01:01:07,901
[applause]

