1
00:00:03,000 --> 00:00:04,300
Russell:
Good afternoon.

2
00:00:04,300 --> 00:00:05,534
I'm Alex Russell.

3
00:00:05,534 --> 00:00:06,701
I'm a software engineer
on the Chrome Team.

4
00:00:06,701 --> 00:00:08,434
Thanks for tearing yourself
away from lunch

5
00:00:08,434 --> 00:00:10,200
to come hear
about JavaScript.

6
00:00:10,200 --> 00:00:14,501
So like I said, I'm an engineer
on the Chrome Team,

7
00:00:14,501 --> 00:00:15,767
and before I joined Google,

8
00:00:15,767 --> 00:00:18,400
I spent a lot of my life
working in JavaScript.

9
00:00:18,400 --> 00:00:21,534
I joined the Chrome Team from
a web development background,

10
00:00:21,534 --> 00:00:23,300
specifically working on open
source JavaScript tool kits

11
00:00:23,300 --> 00:00:24,567
and before that,

12
00:00:24,567 --> 00:00:26,934
working web application
development and security.

13
00:00:26,934 --> 00:00:30,934
And before my recent
detour into C++,

14
00:00:30,934 --> 00:00:33,033
I spent most of my day
trying to figure out

15
00:00:33,033 --> 00:00:35,767
how to make JavaScript
do interesting things.

16
00:00:35,767 --> 00:00:39,033
My personal history with
JavaScript started in 1997,

17
00:00:39,033 --> 00:00:42,334
I think when a lot of us started
to be cognizant of the web.

18
00:00:42,334 --> 00:00:44,534
And at the time, JavaScript
was this thing

19
00:00:44,534 --> 00:00:46,367
that was starting
to become powerful

20
00:00:46,367 --> 00:00:47,834
and somewhat standardized

21
00:00:47,834 --> 00:00:52,567
and somewhat widely available on
the back of the browser wars.

22
00:00:52,567 --> 00:00:54,868
So I want to talk a lot about

23
00:00:54,868 --> 00:00:56,634
how we got to where we are
today with JavaScript,

24
00:00:56,634 --> 00:00:58,434
why it's so important,
why that history,

25
00:00:58,434 --> 00:01:00,767
that long history continues

26
00:01:00,767 --> 00:01:03,167
to figure into the sorts of
things we try to do

27
00:01:03,167 --> 00:01:05,334
with JavaScript on
a day-to-day basis.

28
00:01:05,334 --> 00:01:07,667
And I want to take you
through what's really

29
00:01:07,667 --> 00:01:08,701
inside of JavaScript.

30
00:01:08,701 --> 00:01:10,767
What is it about
JavaScript that it is,

31
00:01:10,767 --> 00:01:12,367
that makes it so different
to the languages

32
00:01:12,367 --> 00:01:14,234
that you might be using
in your day-to-day work

33
00:01:14,234 --> 00:01:17,534
that aren't JavaScript,
because there's a lot that is.

34
00:01:17,534 --> 00:01:19,067
Exactly where
are we right now?

35
00:01:19,067 --> 00:01:20,601
Because I think
this is also sort of

36
00:01:20,601 --> 00:01:23,300
an ambiguous question, right?
If you're a browser bender,

37
00:01:23,300 --> 00:01:27,467
it's easy to say
we're this fast--easy-ish.

38
00:01:27,467 --> 00:01:28,634
If you're a web developer,

39
00:01:28,634 --> 00:01:29,801
you can look
in your deployed base

40
00:01:29,801 --> 00:01:31,667
and understand
who's got what,

41
00:01:31,667 --> 00:01:32,767
but that doesn't necessarily
tell you anything

42
00:01:32,767 --> 00:01:34,167
about the future.

43
00:01:34,167 --> 00:01:36,067
And I want to spend a lot
of time today talking about

44
00:01:36,067 --> 00:01:38,467
how it is that we are going
to get a different future

45
00:01:38,467 --> 00:01:39,601
for JavaScript,

46
00:01:39,601 --> 00:01:40,934
because JavaScript,
like the browsers,

47
00:01:40,934 --> 00:01:42,367
is starting to move again,

48
00:01:42,367 --> 00:01:46,667
and I want to
tear back the veil

49
00:01:46,667 --> 00:01:48,033
that covers each of
these topics

50
00:01:48,033 --> 00:01:49,767
and help you understand
exactly what's going on

51
00:01:49,767 --> 00:01:52,400
and how these parts relate to
each other, because they do.

52
00:01:52,400 --> 00:01:54,234
The history informs
the future,

53
00:01:54,234 --> 00:01:57,901
and the current state informs
what's going to happen next.

54
00:01:57,901 --> 00:02:00,033
So JavaScript is
a functional language.

55
00:02:00,033 --> 00:02:02,367
So how many of you write
in other functional languages

56
00:02:02,367 --> 00:02:04,000
or are familiar with
functional languages?

57
00:02:04,000 --> 00:02:05,267
Awesome.

58
00:02:05,267 --> 00:02:06,767
The front of this talk is
going to be something

59
00:02:06,767 --> 00:02:10,367
that maybe just warms your heart
and may not be new information.

60
00:02:10,367 --> 00:02:12,734
So JavaScript is
a functional language.

61
00:02:12,734 --> 00:02:18,534
In the sort of the history
of functional languages,

62
00:02:18,534 --> 00:02:19,834
it supports closures.

63
00:02:19,834 --> 00:02:21,200
Much like Scheme,

64
00:02:21,200 --> 00:02:25,300
it's got this nice
first class function system,

65
00:02:25,300 --> 00:02:30,567
and in 1995, Brenda and I hacked
it up as a little prototype

66
00:02:30,567 --> 00:02:32,434
which made its way
into Netscape 2,

67
00:02:32,434 --> 00:02:34,400
and Netscape 2
was the first browser

68
00:02:34,400 --> 00:02:36,767
to really have any serious
scripting supported.

69
00:02:36,767 --> 00:02:40,601
It had DOM level 0,
and soon afterwards,

70
00:02:40,601 --> 00:02:43,300
JavaScript sort of, you know,

71
00:02:43,300 --> 00:02:44,634
once it escaped
into the browser,

72
00:02:44,634 --> 00:02:46,968
started the standards
process at ECMA,

73
00:02:46,968 --> 00:02:48,300
not inside the W3C,

74
00:02:48,300 --> 00:02:52,367
because the W3C wasn't
the place for languages.

75
00:02:52,367 --> 00:02:55,501
And in 1997, we got
the first version of JavaScript

76
00:02:55,501 --> 00:02:56,767
as a standard.

77
00:02:56,767 --> 00:03:02,133
In 1996, Microsoft
shipped IE 3.0,

78
00:03:02,133 --> 00:03:03,868
and that was the first version
of JScript.

79
00:03:03,868 --> 00:03:05,801
So we now had two competing,

80
00:03:05,801 --> 00:03:07,400
mostly compatible
implementations

81
00:03:07,400 --> 00:03:09,501
of a scripting language
for the web.

82
00:03:09,501 --> 00:03:11,167
Nobody knew how big
the web was going to be,

83
00:03:11,167 --> 00:03:12,334
although, at the time,

84
00:03:12,334 --> 00:03:14,534
it looked like things
were trending up.

85
00:03:14,534 --> 00:03:15,801
Well, we know how
that story ends.

86
00:03:15,801 --> 00:03:17,968
Today, you can't ship
a credible platform

87
00:03:17,968 --> 00:03:19,634
that doesn't have the web.

88
00:03:19,634 --> 00:03:23,901
In 1999, ECMAScript
version 3

89
00:03:23,901 --> 00:03:27,434
was finalized at TC39,
which is the technical committee

90
00:03:27,434 --> 00:03:32,934
that is the standards body
for JavaScript.

91
00:03:32,934 --> 00:03:34,200
And from its humble roots

92
00:03:34,200 --> 00:03:39,400
as Mocha/LiveScript/JavaScript
in Netscape 2,

93
00:03:39,400 --> 00:03:43,834
JavaScript 3, ECMAScript 262-3,
the version or the standard

94
00:03:43,834 --> 00:03:48,701
that was released in 1999 has
powered us pretty much to today.

95
00:03:48,701 --> 00:03:51,100
It has been the thing
that for more than a decade

96
00:03:51,100 --> 00:03:54,167
has been what
we think of as JavaScript.

97
00:03:54,167 --> 00:03:57,000
And JavaScript, on the back
of that standard,

98
00:03:57,000 --> 00:03:58,767
has gone pretty much everywhere.

99
00:03:58,767 --> 00:04:01,868
JScript, the component that runs
JavaScript inside of IE,

100
00:04:01,868 --> 00:04:04,934
has been built in to the OS
for Windows since Windows 98.

101
00:04:04,934 --> 00:04:06,901
You can't get
a copy of Windows,

102
00:04:06,901 --> 00:04:08,334
you can't buy
a copy of Windows today

103
00:04:08,334 --> 00:04:11,133
that does not include
JavaScript in the OS,

104
00:04:11,133 --> 00:04:13,234
and every browser on the planet
now includes

105
00:04:13,234 --> 00:04:14,801
at least one implementation of
JavaScript,

106
00:04:14,801 --> 00:04:16,400
and these things are moving
really, really fast.

107
00:04:16,400 --> 00:04:20,200
I work on the Chrome Team;
therefore, I'm partial to V8.

108
00:04:20,200 --> 00:04:21,701
It goes nice and quickly,

109
00:04:21,701 --> 00:04:23,100
but these things
are all compatible

110
00:04:23,100 --> 00:04:24,601
to a very high degree.

111
00:04:24,601 --> 00:04:27,033
All of these implementations
are separate implementations,

112
00:04:27,033 --> 00:04:28,634
and they're competing
on things that aren't,

113
00:04:28,634 --> 00:04:30,033
"Oh, here's a new language
feature."

114
00:04:30,033 --> 00:04:31,968
We're collaborating
on language features

115
00:04:31,968 --> 00:04:33,033
in the standards committee,

116
00:04:33,033 --> 00:04:36,234
but we're competing
on performance,

117
00:04:36,234 --> 00:04:38,000
which is a really great place
to be for a language,

118
00:04:38,000 --> 00:04:39,467
because it takes
a lot of investment

119
00:04:39,467 --> 00:04:40,767
to make a language
a real success.

120
00:04:40,767 --> 00:04:42,100
It takes
a lot of deployment,

121
00:04:42,100 --> 00:04:43,901
a lot of competition,
and a lot of investment

122
00:04:43,901 --> 00:04:45,234
to sort of get
the really smart guys

123
00:04:45,234 --> 00:04:47,667
that it takes to go make
a VM go like hell.

124
00:04:47,667 --> 00:04:49,801
And so JavaScript has been
the beneficiary

125
00:04:49,801 --> 00:04:52,434
of this sort of ecosystem of
investment in a way

126
00:04:52,434 --> 00:04:54,667
that only a couple of languages
before it ever have.

127
00:04:54,667 --> 00:04:58,567
And as a result, today's
JavaScript runtimes

128
00:04:58,567 --> 00:05:00,634
and today's JavaScript
performance are vastly different

129
00:05:00,634 --> 00:05:03,734
than they have been in the past,
even the recent past.

130
00:05:03,734 --> 00:05:07,000
And so every device
that you get today,

131
00:05:07,000 --> 00:05:09,534
including the tablets that were
handed out to you yesterday

132
00:05:09,534 --> 00:05:15,400
and the Chrome books that you'll
be receiving as attendees

133
00:05:15,400 --> 00:05:17,467
on June 15th,

134
00:05:17,467 --> 00:05:21,000
these all have JavaScript as
a core part of their runtimes

135
00:05:21,000 --> 00:05:22,367
because the web
is the platform.

136
00:05:22,367 --> 00:05:24,234
The web is the way
that you're going to build

137
00:05:24,234 --> 00:05:25,400
a lot of the applications

138
00:05:25,400 --> 00:05:26,601
that your user
is going to care about,

139
00:05:26,601 --> 00:05:28,267
and it's the way to build
portably today.

140
00:05:28,267 --> 00:05:33,234
So JavaScript is everywhere,
and it's terribly misunderstood.

141
00:05:33,234 --> 00:05:36,334
And I think what I want to do
first here

142
00:05:36,334 --> 00:05:38,067
is to talk you
through the parts

143
00:05:38,067 --> 00:05:40,801
that most people don't
really have a sense of,

144
00:05:40,801 --> 00:05:42,133
when they talk about,

145
00:05:42,133 --> 00:05:43,901
like, what is it that makes
JavaScript different?

146
00:05:43,901 --> 00:05:45,067
Because we hear it's
a dynamic language.

147
00:05:45,067 --> 00:05:46,400
We hear it's
a functional language.

148
00:05:46,400 --> 00:05:48,434
But it looks a lot like C.
It looks a lot like Java.

149
00:05:48,434 --> 00:05:49,567
It looks a lot like C++.

150
00:05:49,567 --> 00:05:51,067
And some folks have been
doing a great job

151
00:05:51,067 --> 00:05:53,534
in the last couple of years at
sort of helping to tear back

152
00:05:53,534 --> 00:05:55,868
the blinders
that are on us,

153
00:05:55,868 --> 00:05:59,000
as folks who come from
a C or C++ background,

154
00:05:59,000 --> 00:06:01,367
and help lay out what it is.

155
00:06:01,367 --> 00:06:02,767
But I want to go
through it very briefly,

156
00:06:02,767 --> 00:06:04,834
because I think it's
important to understand

157
00:06:04,834 --> 00:06:06,267
what's actually in there,

158
00:06:06,267 --> 00:06:07,501
because when we understand
what's actually in there,

159
00:06:07,501 --> 00:06:09,467
we'll understand how
the language can evolve,

160
00:06:09,467 --> 00:06:11,767
because you don't want
necessarily separate--

161
00:06:11,767 --> 00:06:14,501
competing ideas to be existing
inside the same language.

162
00:06:14,501 --> 00:06:16,734
You want a language to sort of
have a theory of itself.

163
00:06:16,734 --> 00:06:20,234
You want it to be coherent
in ways that make it,

164
00:06:20,234 --> 00:06:21,734
so that when you understand
one part of the language,

165
00:06:21,734 --> 00:06:23,234
you can understand
the next part of it.

166
00:06:23,234 --> 00:06:24,767
And my interest in this is
coming from a background

167
00:06:24,767 --> 00:06:26,133
as a web developer,

168
00:06:26,133 --> 00:06:29,000
I serve as one of Google's
representatives to TC39,

169
00:06:29,000 --> 00:06:31,067
the standards committee
for JavaScript.

170
00:06:31,067 --> 00:06:32,868
And so I have a particular
and keen interest

171
00:06:32,868 --> 00:06:34,501
in making sure that we evolve
the language in ways

172
00:06:34,501 --> 00:06:38,534
that are reasonable
and solve real world problems

173
00:06:38,534 --> 00:06:39,801
that we've all got.

174
00:06:39,801 --> 00:06:43,734
So JavaScript only has
a couple of key languages.

175
00:06:43,734 --> 00:06:46,901
I said earlier that JavaScript
is a little functional language,

176
00:06:46,901 --> 00:06:49,100
and JavaScript started out as
a very small language entity.

177
00:06:49,100 --> 00:06:50,701
There aren't a lot
of core concepts.

178
00:06:50,701 --> 00:06:52,100
There's no type
system, per se.

179
00:06:52,100 --> 00:06:53,367
There are types.

180
00:06:53,367 --> 00:06:57,634
You can have a number,
or an object, or an array,

181
00:06:57,634 --> 00:06:59,033
but there's no
type testing.

182
00:06:59,033 --> 00:07:01,901
There's no way to define
your own types, necessarily,

183
00:07:01,901 --> 00:07:05,634
and have them participate at,
like, function call time

184
00:07:05,634 --> 00:07:07,400
and have the system throw
an exception for you,

185
00:07:07,400 --> 00:07:09,701
unless you do the testing
yourself.

186
00:07:09,701 --> 00:07:11,868
And JavaScript
reads top to bottom.

187
00:07:11,868 --> 00:07:13,701
JavaScript has
run-to-completion semantics.

188
00:07:13,701 --> 00:07:15,167
That means that if you
start a body of code,

189
00:07:15,167 --> 00:07:16,901
there's no multithreading
in the language.

190
00:07:16,901 --> 00:07:19,300
There's no way for you to sort
of fork off some other process.

191
00:07:19,300 --> 00:07:22,334
Anything that does that in
a JavaScript environment

192
00:07:22,334 --> 00:07:23,834
is doing it as a built-on.

193
00:07:23,834 --> 00:07:26,634
So browsers with their set
timeout and their set interval.

194
00:07:26,634 --> 00:07:29,701
That's all happening outside
of the core language semantics.

195
00:07:29,701 --> 00:07:31,067
JavaScript reads
top to bottom,

196
00:07:31,067 --> 00:07:33,667
and the interpreter
and runtimes read it exactly

197
00:07:33,667 --> 00:07:35,100
and run it exactly that way.

198
00:07:35,100 --> 00:07:36,601
If you see a block of
JavaScript code,

199
00:07:36,601 --> 00:07:39,868
it goes from top to bottom,
and that'll become important,

200
00:07:39,868 --> 00:07:42,367
as we see in
just a minute.

201
00:07:42,367 --> 00:07:44,167
Almost everything in
JavaScript is mutable.

202
00:07:44,167 --> 00:07:46,367
That means that you can
change nearly everything,

203
00:07:46,367 --> 00:07:50,968
and we'll talk about the
several exemptions to this rule,

204
00:07:50,968 --> 00:07:52,534
but those exemptions
are very small,

205
00:07:52,534 --> 00:07:55,234
and they're very narrow,
but they wind up being powerful.

206
00:07:55,234 --> 00:07:56,801
So that means that if you
get an object back from

207
00:07:56,801 --> 00:07:57,968
some function call,

208
00:07:57,968 --> 00:08:00,000
you can probably change it
in JavaScript.

209
00:08:00,000 --> 00:08:01,868
Closure is the way we do
private state, though,

210
00:08:01,868 --> 00:08:02,901
so if I get an object,

211
00:08:02,901 --> 00:08:04,334
and everything is mutable,

212
00:08:04,334 --> 00:08:05,734
it means, ah, I might be able
to surprise somebody else.

213
00:08:05,734 --> 00:08:07,033
I might be able to go
change some state out

214
00:08:07,033 --> 00:08:08,367
from underneath them.

215
00:08:08,367 --> 00:08:10,167
The thing that returned me
the object might expect it

216
00:08:10,167 --> 00:08:13,300
back in some
reasonably okay state.

217
00:08:13,300 --> 00:08:15,100
Well, the way we do data
hiding in JavaScript

218
00:08:15,100 --> 00:08:17,400
isn't through the private key
order,

219
00:08:17,400 --> 00:08:20,033
through some method that gives
you some sort of a private field

220
00:08:20,033 --> 00:08:21,968
that you can only see.

221
00:08:21,968 --> 00:08:24,334
Instead, we invert
the relationship

222
00:08:24,334 --> 00:08:26,734
between classes and functions,

223
00:08:26,734 --> 00:08:30,701
and we treat functions as
behavior that can carry data,

224
00:08:30,701 --> 00:08:31,834
versus classes,

225
00:08:31,834 --> 00:08:33,601
which are data that can
carry behavior.

226
00:08:33,601 --> 00:08:37,234
And so the last key concept is,
instead of having a class,

227
00:08:37,234 --> 00:08:38,534
as you understand it in
other languages,

228
00:08:38,534 --> 00:08:40,000
we have prototypes,

229
00:08:40,000 --> 00:08:43,534
which is to say we don't have
this strong "is a" relationship

230
00:08:43,534 --> 00:08:45,400
through a hierarchy
of classes.

231
00:08:45,400 --> 00:08:46,767
Instead, we say,
when I don't find it here,

232
00:08:46,767 --> 00:08:48,267
please look over there.

233
00:08:48,267 --> 00:08:52,767
It's delegation, and
it's a one-link chain delegation

234
00:08:52,767 --> 00:08:54,801
up to a root object
that everybody shares.

235
00:08:54,801 --> 00:08:57,467
So we'll talk a lot about
how exactly all this works,

236
00:08:57,467 --> 00:08:58,701
how it fits together,

237
00:08:58,701 --> 00:09:01,667
and hopefully you'll
understand at the end

238
00:09:01,667 --> 00:09:04,167
how it's going to inform
where we can go from here.

239
00:09:04,167 --> 00:09:07,000
I said earlier that
JavaScript runs top to bottom.

240
00:09:07,000 --> 00:09:09,400
That means if I see
a piece of code in JavaScript,

241
00:09:09,400 --> 00:09:10,734
one line before the next,

242
00:09:10,734 --> 00:09:13,100
before the next--because there
isn't necessarily

243
00:09:13,100 --> 00:09:14,400
a compile cycle.

244
00:09:14,400 --> 00:09:17,968
Most JavaScript runtimes
traditionally were interpreters.

245
00:09:17,968 --> 00:09:19,234
That means that the easiest way

246
00:09:19,234 --> 00:09:20,734
to think about your
JavaScript program

247
00:09:20,734 --> 00:09:26,400
is as something that is going
to happen in a live environment.

248
00:09:26,400 --> 00:09:28,167
So if you had
a command line,

249
00:09:28,167 --> 00:09:29,434
and you started typing in
commands,

250
00:09:29,434 --> 00:09:32,133
JavaScript runs almost
exactly the same way.

251
00:09:32,133 --> 00:09:34,601
Top to bottom,
line for line,

252
00:09:34,601 --> 00:09:40,968
it gets evaluated in the order
that it is written out

253
00:09:40,968 --> 00:09:42,968
in the program,
more or less.

254
00:09:42,968 --> 00:09:44,567
And so
statement to statement,

255
00:09:44,567 --> 00:09:47,400
your programs--they can change
in ways that are surprising

256
00:09:47,400 --> 00:09:48,834
in other languages.

257
00:09:48,834 --> 00:09:50,234
Where you might otherwise
have compile time exceptions,

258
00:09:50,234 --> 00:09:52,467
JavaScript just sort of
merrily goes on

259
00:09:52,467 --> 00:09:53,701
and runs the next line.

260
00:09:53,701 --> 00:09:56,367
So whenever we read
some JavaScript code,

261
00:09:56,367 --> 00:09:59,400
it's important to think about
it simply as running at the top

262
00:09:59,400 --> 00:10:00,534
and going to the bottom.

263
00:10:00,534 --> 00:10:03,534
It's not really
some big magical machine

264
00:10:03,534 --> 00:10:05,367
that's going to be out there
doing something for you,

265
00:10:05,367 --> 00:10:07,100
and then it's going to start
running your program.

266
00:10:07,100 --> 00:10:08,501
It's just running
top to bottom.

267
00:10:08,501 --> 00:10:09,968
So when you evaluate
JavaScript code,

268
00:10:09,968 --> 00:10:11,300
and you're trying to figure
out what's going on,

269
00:10:11,300 --> 00:10:13,133
remember that the line
before it may be the thing

270
00:10:13,133 --> 00:10:15,200
that caused the problem.

271
00:10:15,200 --> 00:10:18,367
And JavaScript is functional
and object-based.

272
00:10:18,367 --> 00:10:22,434
It's really important
to think of functions

273
00:10:22,434 --> 00:10:25,067
as first class in JavaScript.

274
00:10:25,067 --> 00:10:27,067
That means that they're
not simply a pointer out

275
00:10:27,067 --> 00:10:30,834
in the world that you
invoke against something.

276
00:10:30,834 --> 00:10:32,133
They are actual objects.

277
00:10:32,133 --> 00:10:33,234
I'm going to refer to them
through this talk

278
00:10:33,234 --> 00:10:34,701
as function objects,

279
00:10:34,701 --> 00:10:37,601
because function objects are
indeed objects that you can go

280
00:10:37,601 --> 00:10:38,834
and hang behavior off of.

281
00:10:38,834 --> 00:10:39,968
But you don't hang behavior
off of them

282
00:10:39,968 --> 00:10:42,701
by extending their public
API area.

283
00:10:42,701 --> 00:10:44,601
You don't say,
"I've got a function object.

284
00:10:44,601 --> 00:10:46,067
I'm going to add
some new property to it."

285
00:10:46,067 --> 00:10:49,534
Most of the time, you do that
by using functions as scopes.

286
00:10:49,534 --> 00:10:51,501
The only way to create
a new scope in JavaScript

287
00:10:51,501 --> 00:10:53,300
is to invoke a function.

288
00:10:53,300 --> 00:10:55,801
When you invoke a function,
it sort of creates a new scope.

289
00:10:55,801 --> 00:10:58,601
If statements, while statements,
for-in statements--

290
00:10:58,601 --> 00:10:59,834
those things
don't create scopes.

291
00:10:59,834 --> 00:11:03,100
Only functions do,
so we have this problem of

292
00:11:03,100 --> 00:11:04,234
how do we do beta hiding?

293
00:11:04,234 --> 00:11:05,734
Well, these scopes
are really smart,

294
00:11:05,734 --> 00:11:07,534
because these scopes
hold on to the variables

295
00:11:07,534 --> 00:11:10,501
that have been defined
above them in another scope.

296
00:11:10,501 --> 00:11:13,667
So what we've got here is
a function called get counter,

297
00:11:13,667 --> 00:11:15,534
and get counter defines
a local variable, I,

298
00:11:15,534 --> 00:11:18,400
and it returns
another function,

299
00:11:18,400 --> 00:11:22,534
and that function references
the variable I inside of it.

300
00:11:22,534 --> 00:11:26,734
In other languages
like C++ or Java,

301
00:11:26,734 --> 00:11:28,200
you really can't do
anything here,

302
00:11:28,200 --> 00:11:30,234
because that variable I
is going to go out of scope

303
00:11:30,234 --> 00:11:31,467
in the return function.

304
00:11:31,467 --> 00:11:32,767
We're allocating
a new function here,

305
00:11:32,767 --> 00:11:35,868
but that inner function is
going to hold on to I.

306
00:11:35,868 --> 00:11:39,133
It actually allocates private
memory to store a reference

307
00:11:39,133 --> 00:11:41,000
to I on the function object

308
00:11:41,000 --> 00:11:44,100
that's returned out of
this statement here.

309
00:11:44,100 --> 00:11:45,901
It, again, inverts
the relationship.

310
00:11:45,901 --> 00:11:48,667
It's not storage
with behavior.

311
00:11:48,667 --> 00:11:50,968
It's behavior
that has hidden storage.

312
00:11:50,968 --> 00:11:52,400
And so the way we do
private variables

313
00:11:52,400 --> 00:11:56,267
and the way we do
data hiding in JavaScript

314
00:11:56,267 --> 00:11:58,534
is to use this idea of a
closure, something that encloses

315
00:11:58,534 --> 00:11:59,934
its lexical scope

316
00:11:59,934 --> 00:12:01,601
and holds on to variables

317
00:12:01,601 --> 00:12:03,701
as a way
of passing behavior around.

318
00:12:03,701 --> 00:12:05,934
So we can call
the get counter function.

319
00:12:05,934 --> 00:12:07,501
It hands us back
a function object.

320
00:12:07,501 --> 00:12:10,100
We can call it multiple times,
and that state isn't gone.

321
00:12:10,100 --> 00:12:12,834
We can still see the variable I
from inside the outside one,

322
00:12:12,834 --> 00:12:14,367
but it isn't referenceable.

323
00:12:14,367 --> 00:12:17,300
We can't go and inspect some
property on that function object

324
00:12:17,300 --> 00:12:20,400
and find out which variables
it's holding references to.

325
00:12:20,400 --> 00:12:24,367
It gets GC'd just like
everything else in the language.

326
00:12:24,367 --> 00:12:25,734
So these are
first class functions.

327
00:12:25,734 --> 00:12:28,634
These are functions
that are things in the system.

328
00:12:28,634 --> 00:12:30,767
They're actually objects.
You can create them.

329
00:12:30,767 --> 00:12:33,734
You can add properties to them.
It can enclose scope.

330
00:12:33,734 --> 00:12:37,801
They're not simply inert
bodies of code that get run.

331
00:12:37,801 --> 00:12:39,801
They're participants
in the object model.

332
00:12:39,801 --> 00:12:42,300
They're participants
in the storage system.

333
00:12:42,300 --> 00:12:44,400
You can use them--I know
the fundamental concept

334
00:12:44,400 --> 00:12:46,334
that underpins
a lot of the patterns

335
00:12:46,334 --> 00:12:48,067
that we're going to see later.

336
00:12:48,067 --> 00:12:50,667
So these functions
work together

337
00:12:50,667 --> 00:12:52,934
with a lot of other
sort of functional ideas

338
00:12:52,934 --> 00:12:55,133
about how a program language
can be structured.

339
00:12:55,133 --> 00:12:57,167
In JavaScript, we have a filter,
map, reduce,

340
00:12:57,167 --> 00:13:00,133
and for each method
on the array prototype,

341
00:13:00,133 --> 00:13:02,534
which means that every array
in the system has these methods,

342
00:13:02,534 --> 00:13:05,234
which means that instead
of having an external iterator,

343
00:13:05,234 --> 00:13:06,434
you have
an internal iterator.

344
00:13:06,434 --> 00:13:08,400
You have something
that can call a function

345
00:13:08,400 --> 00:13:10,133
across some set of arguments,

346
00:13:10,133 --> 00:13:12,501
and so you wind up
creating a stack of stuff

347
00:13:12,501 --> 00:13:14,567
that you'd like to do
in terms of behavior.

348
00:13:14,567 --> 00:13:16,534
Instead of passing
data structures around

349
00:13:16,534 --> 00:13:18,734
and around and around, you pass
in arguments to functions,

350
00:13:18,734 --> 00:13:20,267
and that sort of
unwinds the thing

351
00:13:20,267 --> 00:13:21,400
that you were
trying to get done.

352
00:13:21,400 --> 00:13:23,501
You express
your program's intent

353
00:13:23,501 --> 00:13:25,601
in the form of
nested functions

354
00:13:25,601 --> 00:13:28,467
that are going to
unwind to some result,

355
00:13:28,467 --> 00:13:31,601
not linear code
that's going to be executed

356
00:13:31,601 --> 00:13:33,534
by passing in
the same data structures

357
00:13:33,534 --> 00:13:34,868
over and over
and over again.

358
00:13:34,868 --> 00:13:39,300
So these sorts of things
are not hard and fast rules

359
00:13:39,300 --> 00:13:40,434
about any programming
language.

360
00:13:40,434 --> 00:13:42,567
Like, you can have
an endless debate about

361
00:13:42,567 --> 00:13:44,634
what makes something a
functional programming language.

362
00:13:44,634 --> 00:13:45,767
Can it have side effects?

363
00:13:45,767 --> 00:13:48,567
Can it not have side effects?
You know--

364
00:13:48,567 --> 00:13:51,067
How completely does it
support some particular

365
00:13:51,067 --> 00:13:53,234
set of macro languages,
or hygienic macros,

366
00:13:53,234 --> 00:13:54,601
or whatever it is?

367
00:13:54,601 --> 00:13:57,534
Many people define functional
languages differently,

368
00:13:57,534 --> 00:13:59,334
but for the intents
and purposes here,

369
00:13:59,334 --> 00:14:00,334
we're just going to say
it has closures,

370
00:14:00,334 --> 00:14:01,701
first class functions,

371
00:14:01,701 --> 00:14:04,834
and some concept of
using those sorts of things

372
00:14:04,834 --> 00:14:08,300
to compose behavior
nicely together.

373
00:14:08,300 --> 00:14:10,501
So another important thing
to remember about JavaScript

374
00:14:10,501 --> 00:14:12,734
is that everything
is just an object.

375
00:14:12,734 --> 00:14:15,033
So there aren't a lot of
key concepts in JavaScript,

376
00:14:15,033 --> 00:14:18,067
and so you can think of it as
sort of a lazy language design.

377
00:14:18,067 --> 00:14:20,601
It doesn't really have
a lot of specialized,

378
00:14:20,601 --> 00:14:22,200
compartmentalized things

379
00:14:22,200 --> 00:14:23,200
to hold on
to different concepts

380
00:14:23,200 --> 00:14:24,400
that you might encounter.

381
00:14:24,400 --> 00:14:25,767
Instead, it just relies
on the same systems

382
00:14:25,767 --> 00:14:27,100
over and over again.

383
00:14:27,100 --> 00:14:31,234
One of those systems
is this small type system,

384
00:14:31,234 --> 00:14:35,000
where objects are objects,
that first object literal there.

385
00:14:35,000 --> 00:14:37,501
It's an instance of object.
Arrays are objects,

386
00:14:37,501 --> 00:14:39,834
which means that arrays are
instances of objects, too.

387
00:14:39,834 --> 00:14:42,167
And functions
are also objects.

388
00:14:42,167 --> 00:14:45,033
In this case,
I've got a paren here,

389
00:14:45,033 --> 00:14:47,033
which is going to create
a new expression.

390
00:14:47,033 --> 00:14:49,133
I've got a function,
which I define inside of here.

391
00:14:49,133 --> 00:14:50,734
It doesn't have a name.
It's an anonymous function.

392
00:14:50,734 --> 00:14:53,334
You can have anonymous
functions in JavaScript.

393
00:14:53,334 --> 00:14:54,968
And the result
of this expression

394
00:14:54,968 --> 00:14:57,000
is just going to be
that function object.

395
00:14:57,000 --> 00:15:01,167
And the function object also is
an instance of the object type,

396
00:15:01,167 --> 00:15:03,033
which means that nearly
everything in the system

397
00:15:03,033 --> 00:15:05,067
that you encounter
is going to be an object.

398
00:15:05,067 --> 00:15:06,434
This is really powerful,
because it means,

399
00:15:06,434 --> 00:15:07,767
as we'll see later,

400
00:15:07,767 --> 00:15:10,133
when we compose things,
and everything is mutable,

401
00:15:10,133 --> 00:15:11,467
we can start
to change the behavior

402
00:15:11,467 --> 00:15:13,767
of large parts of the system
all at once.

403
00:15:13,767 --> 00:15:16,100
And every object in the system
acts more or less like a map.

404
00:15:16,100 --> 00:15:18,033
There's no separate
map type in JavaScript.

405
00:15:18,033 --> 00:15:20,133
So if you want a map,
just take an object.

406
00:15:20,133 --> 00:15:22,501
This is where--
sort of where JSON comes from,

407
00:15:22,501 --> 00:15:24,901
this object literal syntax
that we've got here,

408
00:15:24,901 --> 00:15:26,100
where we're
defining an object

409
00:15:26,100 --> 00:15:28,234
with a single property
and a single value.

410
00:15:28,234 --> 00:15:30,267
It allows us to de-reference
properties the same way.

411
00:15:30,267 --> 00:15:32,868
So the data operator does
almost exactly the same thing

412
00:15:32,868 --> 00:15:34,234
as this map operator.

413
00:15:34,234 --> 00:15:36,200
It just finds a property
by its name

414
00:15:36,200 --> 00:15:37,601
and returns it out
the other side.

415
00:15:37,601 --> 00:15:40,400
So in JavaScript,
everything is an object.

416
00:15:40,400 --> 00:15:43,234
Objects operate like maps.
That's pretty cool.

417
00:15:43,234 --> 00:15:44,667
Arrays do exactly
the same thing.

418
00:15:44,667 --> 00:15:47,767
And arrays are very confusing
when you start out working

419
00:15:47,767 --> 00:15:48,968
in JavaScript,

420
00:15:48,968 --> 00:15:51,100
because you think array
is some separate thing

421
00:15:51,100 --> 00:15:53,667
over on the side.
Arrays are not objects.

422
00:15:53,667 --> 00:15:55,801
Arrays are this linear bag
of memory

423
00:15:55,801 --> 00:15:58,367
that you're going to access
with an integer someplace.

424
00:15:58,367 --> 00:16:00,667
And as a result of that,

425
00:16:00,667 --> 00:16:04,000
you're not going to be surprised
by some other identity.

426
00:16:04,000 --> 00:16:06,067
But you are, because
very often what happens is

427
00:16:06,067 --> 00:16:08,300
you go and extend an object.
You add a new property to it.

428
00:16:08,300 --> 00:16:11,200
In this case, we're going to add
this other greeting property

429
00:16:11,200 --> 00:16:15,300
to an object dynamically, and--
or to an array dynamically.

430
00:16:15,300 --> 00:16:18,367
And as a result,
when we go into a for-in loop,

431
00:16:18,367 --> 00:16:22,434
this is now an innumerable
property on this array.

432
00:16:22,434 --> 00:16:24,767
We might get surprised, because
we see these other things

433
00:16:24,767 --> 00:16:27,300
showing up in our object.

434
00:16:27,300 --> 00:16:29,100
Well, that's weird.

435
00:16:29,100 --> 00:16:32,067
I mean, we iterated
over the public properties.

436
00:16:32,067 --> 00:16:34,734
Isn't 0 just
an integer index thing?

437
00:16:34,734 --> 00:16:36,334
It's not a public
property, right?

438
00:16:36,334 --> 00:16:38,434
Well, remember that
everything in JavaScript

439
00:16:38,434 --> 00:16:40,667
just sort of falls back
on these core concepts.

440
00:16:40,667 --> 00:16:44,901
And if you think about
the array integer indexing

441
00:16:44,901 --> 00:16:47,834
working exactly the same way
that property indexing does,

442
00:16:47,834 --> 00:16:48,968
it all makes sense.

443
00:16:48,968 --> 00:16:50,300
Yeah,
in the implementation,

444
00:16:50,300 --> 00:16:52,033
there might be some special
machinery to make arrays

445
00:16:52,033 --> 00:16:53,634
efficient
or to pack them tightly,

446
00:16:53,634 --> 00:16:55,968
so that you don't wind up
slowing things down

447
00:16:55,968 --> 00:16:57,300
unnecessarily.

448
00:16:57,300 --> 00:16:58,901
But in the language semantics,

449
00:16:58,901 --> 00:17:00,067
what happens here
when I say,

450
00:17:00,067 --> 00:17:02,801
"Please give me item 0
out of this list,"

451
00:17:02,801 --> 00:17:05,000
is that it turns
that 0 into a string,

452
00:17:05,000 --> 00:17:06,801
and then does a map lookup.

453
00:17:06,801 --> 00:17:07,968
That's all it does.

454
00:17:07,968 --> 00:17:09,300
So the only magical thing
about arrays

455
00:17:09,300 --> 00:17:11,400
versus any other kind of object
in the system

456
00:17:11,400 --> 00:17:13,033
is that,
when I push onto an array

457
00:17:13,033 --> 00:17:15,467
or I set the length property,

458
00:17:15,467 --> 00:17:17,868
it actually affects
which properties are visible.

459
00:17:17,868 --> 00:17:19,567
The length property is
the only thing in an array

460
00:17:19,567 --> 00:17:21,067
that's actually magic.

461
00:17:21,067 --> 00:17:23,267
It has a little bit of syntax
for defining arrays naturally;

462
00:17:23,267 --> 00:17:25,534
but other than that,
arrays are just objects.

463
00:17:25,534 --> 00:17:28,067
Things get turned into strings
and then de-referenced that way.

464
00:17:28,067 --> 00:17:29,534
The spec is pretty clear
about this.

465
00:17:29,534 --> 00:17:33,167
So JavaScript doesn't have
that many core concepts.

466
00:17:33,167 --> 00:17:34,801
And if you understand them,
you can understand

467
00:17:34,801 --> 00:17:36,300
what's going on
in your system.

468
00:17:36,300 --> 00:17:38,934
So we've got mutable objects.
We've got closures,

469
00:17:38,934 --> 00:17:40,501
which are behavior
that carries data

470
00:17:40,501 --> 00:17:42,767
and not data
that carries behavior.

471
00:17:42,767 --> 00:17:44,701
We've got mutable objects,

472
00:17:44,701 --> 00:17:46,467
and we've got everything
being an object

473
00:17:46,467 --> 00:17:49,300
and everything being an object
also being a map.

474
00:17:49,300 --> 00:17:51,300
Okay, that's not a lot
of concepts, so far,

475
00:17:51,300 --> 00:17:52,834
for a programming language.

476
00:17:52,834 --> 00:17:56,267
And we can use these to build
some really powerful stuff.

477
00:17:56,267 --> 00:17:57,467
So I mentioned mutability,

478
00:17:57,467 --> 00:17:59,167
and I said
everything is mutable.

479
00:17:59,167 --> 00:18:01,801
Just a really quick example,
we can add new properties

480
00:18:01,801 --> 00:18:03,200
at runtime to every object.

481
00:18:03,200 --> 00:18:06,534
Remember how I said that
JavaScript runs top to bottom?

482
00:18:06,534 --> 00:18:08,100
When you're reading
a program like this,

483
00:18:08,100 --> 00:18:10,634
it's not like my object type
somehow was extended

484
00:18:10,634 --> 00:18:12,367
and, therefore, every object
of this type is going to have

485
00:18:12,367 --> 00:18:13,734
one of these properties.

486
00:18:13,734 --> 00:18:17,901
I'm just adding a new property
to the object directly.

487
00:18:17,901 --> 00:18:21,667
So in this case,
object.item is being replaced,

488
00:18:21,667 --> 00:18:24,767
and object.item2
is simply being added.

489
00:18:24,767 --> 00:18:26,434
These are exactly
the same operations,

490
00:18:26,434 --> 00:18:28,367
as far as JavaScript
is concerned.

491
00:18:28,367 --> 00:18:30,534
The dot operator
just finds you the object

492
00:18:30,534 --> 00:18:32,601
and then assigns to it.
That's all it's doing.

493
00:18:32,601 --> 00:18:34,501
Every object in the system
is extensible.

494
00:18:34,501 --> 00:18:36,567
Most of them are mutable.

495
00:18:36,567 --> 00:18:40,467
Most of the values are mutable,
and we run top to bottom.

496
00:18:40,467 --> 00:18:43,100
So that means
that when I come down here,

497
00:18:43,100 --> 00:18:44,901
and I delete a property
off of the object,

498
00:18:44,901 --> 00:18:46,400
the very next line
isn't going to see it.

499
00:18:46,400 --> 00:18:48,334
But if I had said
console.log(obj.item)

500
00:18:48,334 --> 00:18:50,534
one line above,
it would see it there.

501
00:18:50,534 --> 00:18:51,934
This is not
a compile time thing.

502
00:18:51,934 --> 00:18:55,100
It's just doing what you said,
line after line,

503
00:18:55,100 --> 00:18:57,601
statement after statement,
expression after expression.

504
00:18:57,601 --> 00:18:59,067
It seems really simple.

505
00:18:59,067 --> 00:19:01,400
It seems pretty obvious, but
very few programming languages

506
00:19:01,400 --> 00:19:03,300
that you might be using
in a compiled environment

507
00:19:03,300 --> 00:19:05,267
work this way.

508
00:19:05,267 --> 00:19:07,367
So I mentioned that closures
are the other side of classes,

509
00:19:07,367 --> 00:19:08,834
whereas classes
are sort of a nice way

510
00:19:08,834 --> 00:19:10,400
of saying,
"Here's a structure of data.

511
00:19:10,400 --> 00:19:12,133
"I'm going to associate
some properties with them,

512
00:19:12,133 --> 00:19:15,634
and maybe they'll have
some type behavior as well."

513
00:19:15,634 --> 00:19:18,200
In this case,
we're going to create something

514
00:19:18,200 --> 00:19:19,834
that we would call a class
in JavaScript.

515
00:19:19,834 --> 00:19:21,133
We know it's a class,

516
00:19:21,133 --> 00:19:23,167
because it's got
an uppercase B for the name.

517
00:19:23,167 --> 00:19:24,601
This is not a language
enforced semantic.

518
00:19:24,601 --> 00:19:28,634
JavaScript doesn't necessarily
have classes today.

519
00:19:28,634 --> 00:19:30,534
This is just a convention.
And as we'll see, conventions

520
00:19:30,534 --> 00:19:34,067
figure large in day-to-day
JavaScript programming.

521
00:19:34,067 --> 00:19:35,934
So remember
every object is mutable.

522
00:19:35,934 --> 00:19:38,667
So we're going to create
down here,

523
00:19:38,667 --> 00:19:42,801
we're going to create a new
instance of our behavior class.

524
00:19:42,801 --> 00:19:46,534
We're going to extend
the local object, this dot,

525
00:19:46,534 --> 00:19:48,534
with the variable that
was passed in the configuration,

526
00:19:48,534 --> 00:19:50,467
and then we're going to
extend the object again

527
00:19:50,467 --> 00:19:52,000
with a function called do it.

528
00:19:52,000 --> 00:19:53,334
In this case,

529
00:19:53,334 --> 00:19:56,734
when I call the do it method
of my behavior instance,

530
00:19:56,734 --> 00:19:57,834
it's then going to
run through,

531
00:19:57,834 --> 00:19:59,601
and it's going to say
this.config

532
00:19:59,601 --> 00:20:01,767
and go grab some flag
off the configuration.

533
00:20:01,767 --> 00:20:05,234
Okay, so we stored some property
and some behavior on the object.

534
00:20:05,234 --> 00:20:06,801
This looks a lot like
what you might expect out

535
00:20:06,801 --> 00:20:08,200
of another
object-oriented language.

536
00:20:08,200 --> 00:20:10,367
The declaration syntax
is a little bit funky,

537
00:20:10,367 --> 00:20:11,801
but you sort of
understand it, right?

538
00:20:11,801 --> 00:20:14,033
I've added a method.
I've added some data.

539
00:20:14,033 --> 00:20:16,100
The data operates on
the local objects method.

540
00:20:16,100 --> 00:20:18,300
Sweet--
or other way around.

541
00:20:18,300 --> 00:20:20,934
Strike that, reverse it.

542
00:20:20,934 --> 00:20:23,234
New behavior, passing a flag,
then I call it false.

543
00:20:23,234 --> 00:20:24,634
I get a behavior object,

544
00:20:24,634 --> 00:20:27,934
and now I can call a method
that uses that behavior, right?

545
00:20:27,934 --> 00:20:32,467
So it's going to look
at the local object, this,

546
00:20:32,467 --> 00:20:35,167
for the configuration,
and it may change its behavior

547
00:20:35,167 --> 00:20:38,534
based on that configuration by
passing some other value to it.

548
00:20:38,534 --> 00:20:41,133
Make sense?
Cool? All right.

549
00:20:41,133 --> 00:20:44,067
So this is maybe a little bit
more idiomatic for JavaScript.

550
00:20:44,067 --> 00:20:46,133
It's the flip side of that.

551
00:20:46,133 --> 00:20:49,033
Instead of creating a class
that I created an instance of,

552
00:20:49,033 --> 00:20:51,834
I'm going to
create a generator

553
00:20:51,834 --> 00:20:54,067
that's going to pass me
back a function object,

554
00:20:54,067 --> 00:20:55,667
which is going to hold
on to the state.

555
00:20:55,667 --> 00:20:57,100
I'm not going to go
create a class for it.

556
00:20:57,100 --> 00:20:59,400
I'm going to create
a behavior generator.

557
00:20:59,400 --> 00:21:01,200
You can think of them
doing the same thing,

558
00:21:01,200 --> 00:21:02,334
just the flip side of it.

559
00:21:02,334 --> 00:21:04,634
So instead of saying
new behavior,

560
00:21:04,634 --> 00:21:07,000
I'm going to say
bind me a behavior,

561
00:21:07,000 --> 00:21:09,100
which when I call this,

562
00:21:09,100 --> 00:21:11,400
note the lack of
the new keyword here,

563
00:21:11,400 --> 00:21:13,634
I'm going to pass
into configuration.

564
00:21:13,634 --> 00:21:14,901
Like we saw earlier,

565
00:21:14,901 --> 00:21:16,434
I'm going to pass back out
a function object.

566
00:21:16,434 --> 00:21:17,667
This is a new
function object.

567
00:21:17,667 --> 00:21:19,734
Every time I call this method,
bind behavior,

568
00:21:19,734 --> 00:21:22,167
it's going to pass me back out
a new function object.

569
00:21:22,167 --> 00:21:26,400
So I'm actually having a new
function object allocated here,

570
00:21:26,400 --> 00:21:28,567
and that function object
is going to have, again,

571
00:21:28,567 --> 00:21:30,701
some private storage,
and that private storage is

572
00:21:30,701 --> 00:21:32,834
going to hold on to
the config variable

573
00:21:32,834 --> 00:21:34,901
that was passed into
the outer function, right?

574
00:21:34,901 --> 00:21:36,501
Because each one of these
is a new scope,

575
00:21:36,501 --> 00:21:38,734
and because scopes
can hold on to the variables

576
00:21:38,734 --> 00:21:41,634
that they were able to see
when they were defined,

577
00:21:41,634 --> 00:21:43,701
the function object
that gets passed out of here now

578
00:21:43,701 --> 00:21:44,868
has a reference.

579
00:21:44,868 --> 00:21:47,467
It's holding on to
that local state.

580
00:21:47,467 --> 00:21:50,033
In this case, it's going to be
the object that was passed in.

581
00:21:50,033 --> 00:21:52,534
This might go out of scope here
in every other place

582
00:21:52,534 --> 00:21:53,834
in my program.

583
00:21:53,834 --> 00:21:55,434
I may not be able to get
a reference back to this object,

584
00:21:55,434 --> 00:22:00,267
but my behavior, the B variable
that was passed back out,

585
00:22:00,267 --> 00:22:02,033
will have access to that data

586
00:22:02,033 --> 00:22:03,734
because it's being held on to
internally.

587
00:22:03,734 --> 00:22:04,901
It's not going to be
garbage collected out

588
00:22:04,901 --> 00:22:06,200
from underneath me.

589
00:22:06,200 --> 00:22:08,133
Closures are the way to invert
the way you think

590
00:22:08,133 --> 00:22:09,434
about your programs.

591
00:22:09,434 --> 00:22:12,868
You don't create classes
that are state with data,

592
00:22:12,868 --> 00:22:14,367
state with behavior attached.

593
00:22:14,367 --> 00:22:17,267
You create behavior that holds
on to the state that it needs,

594
00:22:17,267 --> 00:22:18,601
and you can pass
that behavior around,

595
00:22:18,601 --> 00:22:22,234
because functions
are first class.

596
00:22:22,234 --> 00:22:25,767
So I mentioned earlier that
the last sort of big conceit

597
00:22:25,767 --> 00:22:28,434
in the language is that we
don't have a way of saying,

598
00:22:28,434 --> 00:22:30,868
hey, here's a class of stuff.

599
00:22:30,868 --> 00:22:33,601
Instead we say,
if you don't find it here,

600
00:22:33,601 --> 00:22:40,067
don't look at my like
chain of class inheritance.

601
00:22:40,067 --> 00:22:42,467
Instead, just go look
at that other object.

602
00:22:42,467 --> 00:22:44,367
Remember how I said
over and over again

603
00:22:44,367 --> 00:22:47,133
that JavaScript
just reads top to bottom?

604
00:22:47,133 --> 00:22:48,434
I get some code.

605
00:22:48,434 --> 00:22:52,334
The thing executes
front to back, top to bottom.

606
00:22:52,334 --> 00:22:54,033
We're going to see
the exact same thing here,

607
00:22:54,033 --> 00:22:56,767
because what happens every time
you call the .operator

608
00:22:56,767 --> 00:22:57,901
is exactly the same thing.

609
00:22:57,901 --> 00:22:59,834
I'm going to create
some variable

610
00:22:59,834 --> 00:23:01,133
that I'm going
to call my delegate.

611
00:23:01,133 --> 00:23:03,267
It's an object.
It's got a single property.

612
00:23:03,267 --> 00:23:04,767
Okay, cool.

613
00:23:04,767 --> 00:23:08,100
There's a new ECMAScript 5
method called object.create.

614
00:23:08,100 --> 00:23:09,534
There's other ways to do this
in older versions,

615
00:23:09,534 --> 00:23:10,534
but they're a little bit
mind bending,

616
00:23:10,534 --> 00:23:11,834
and we won't go over them.

617
00:23:11,834 --> 00:23:13,267
But object.create--
the easiest way to think of it

618
00:23:13,267 --> 00:23:17,033
is that it creates a new object
which will look at the object

619
00:23:17,033 --> 00:23:19,701
that you pass
as its first property

620
00:23:19,701 --> 00:23:23,067
if you don't find a value
with this same property name

621
00:23:23,067 --> 00:23:24,601
on that object.

622
00:23:24,601 --> 00:23:29,534
So let's say--and in this case,
I'm going to create object 2

623
00:23:29,534 --> 00:23:31,667
and have my delegate
be the delegate.

624
00:23:31,667 --> 00:23:34,934
And so when I reference
a property out of object 2,

625
00:23:34,934 --> 00:23:36,734
it's going to go look it
up dynamically,

626
00:23:36,734 --> 00:23:39,200
and if it doesn't find it
on object 2 directly,

627
00:23:39,200 --> 00:23:41,901
it's going to go look it up
off of the delegated 2 object.

628
00:23:41,901 --> 00:23:43,367
It's going to go,
dynamically go

629
00:23:43,367 --> 00:23:45,234
and try and find it
over there.

630
00:23:45,234 --> 00:23:47,868
Well, we created
another object.

631
00:23:47,868 --> 00:23:52,033
In this case, we're setting
a local property on that object,

632
00:23:52,033 --> 00:23:54,934
whose name is item,
whose value is value.

633
00:23:54,934 --> 00:23:56,701
And that means that
when I look it up at runtime

634
00:23:56,701 --> 00:23:58,834
directly top to bottom,
left to right,

635
00:23:58,834 --> 00:24:01,000
what I see is that
I don't get the value

636
00:24:01,000 --> 00:24:02,133
that was set on my delegate.

637
00:24:02,133 --> 00:24:03,834
I get the value that was
on the local object.

638
00:24:03,834 --> 00:24:06,367
The .operator doesn't fail
on the local lookup.

639
00:24:06,367 --> 00:24:07,901
It finds it on
the local object.

640
00:24:07,901 --> 00:24:09,434
And instead of looking up
the chain, it says,

641
00:24:09,434 --> 00:24:12,667
ah, I'll just give you this
object's value right back.

642
00:24:12,667 --> 00:24:14,634
So JavaScript is
incredibly dynamic

643
00:24:14,634 --> 00:24:17,133
when it comes even to looking up
properties on objects.

644
00:24:17,133 --> 00:24:19,501
There's not some fixed list
of stuff that you can do.

645
00:24:19,501 --> 00:24:20,734
You can change
the delegation,

646
00:24:20,734 --> 00:24:22,000
and you can change
the properties

647
00:24:22,000 --> 00:24:23,667
that are available
on every object

648
00:24:23,667 --> 00:24:26,200
that you're delegating to,
or your local object,

649
00:24:26,200 --> 00:24:27,634
and that changes what happens
when you go

650
00:24:27,634 --> 00:24:30,100
and look stuff up
at the very next line.

651
00:24:30,100 --> 00:24:31,300
So in this case,

652
00:24:31,300 --> 00:24:34,334
if I go and I change the value
on the delegate,

653
00:24:34,334 --> 00:24:35,834
I change the item value
on the delegate,

654
00:24:35,834 --> 00:24:38,033
remember that object 2
doesn't have a local property

655
00:24:38,033 --> 00:24:39,100
called item.

656
00:24:39,100 --> 00:24:41,367
If I fail on that lookup
on object 2,

657
00:24:41,367 --> 00:24:44,200
it just goes and says, ah, okay,
let's go consult my delegate,

658
00:24:44,200 --> 00:24:46,267
and that delegate is now
going to have the new value.

659
00:24:46,267 --> 00:24:48,234
So the new value has
been shadowed all the way

660
00:24:48,234 --> 00:24:49,634
through to everything else
in the system

661
00:24:49,634 --> 00:24:51,601
that is delegating
to that object.

662
00:24:51,601 --> 00:24:53,033
This is incredibly
powerful.

663
00:24:53,033 --> 00:24:55,334
The dynamic nature of
JavaScript means that

664
00:24:55,334 --> 00:24:56,634
because it reads
top to bottom,

665
00:24:56,634 --> 00:24:58,133
because almost everything
is mutable,

666
00:24:58,133 --> 00:25:00,367
and because I can delegate
to most other objects

667
00:25:00,367 --> 00:25:01,801
when I create something,

668
00:25:01,801 --> 00:25:05,200
I wind up in a place where
I can create brand-new behavior

669
00:25:05,200 --> 00:25:06,767
at runtime.

670
00:25:06,767 --> 00:25:09,100
I can compose things on the next
line that didn't exist before,

671
00:25:09,100 --> 00:25:10,501
or I can change
the behavior of other objects

672
00:25:10,501 --> 00:25:11,701
in the system,

673
00:25:11,701 --> 00:25:13,100
based on what
they're delegating to.

674
00:25:13,100 --> 00:25:15,167
This turns out to be
a great way

675
00:25:15,167 --> 00:25:17,000
to go build up
a lot of the constructs

676
00:25:17,000 --> 00:25:18,701
that we get in other languages
for ourselves,

677
00:25:18,701 --> 00:25:21,701
because JavaScript may not
give them to us naturally.

678
00:25:21,701 --> 00:25:24,434
This power is the sort of thing
that really drew me

679
00:25:24,434 --> 00:25:26,968
to JavaScript
as a young programmer.

680
00:25:26,968 --> 00:25:28,834
I didn't really understand
what I was dealing with.

681
00:25:28,834 --> 00:25:31,033
I remember I had a friend
who told me,

682
00:25:31,033 --> 00:25:34,234
after I'd written some article
about how to do

683
00:25:34,234 --> 00:25:36,367
signals and slots,
some sort of aspect-oriented

684
00:25:36,367 --> 00:25:38,834
event style thing,
he's like,

685
00:25:38,834 --> 00:25:40,300
"Well, why didn't you just use
a closure for that?"

686
00:25:40,300 --> 00:25:41,801
And it took me a long time,

687
00:25:41,801 --> 00:25:43,200
probably six months
or more after that,

688
00:25:43,200 --> 00:25:45,133
to sort of really understand
what it was

689
00:25:45,133 --> 00:25:47,200
that he meant when he said,
"Just use a closure for that."

690
00:25:47,200 --> 00:25:48,634
I didn't understand
that you could hide data

691
00:25:48,634 --> 00:25:49,834
inside of functions.

692
00:25:49,834 --> 00:25:51,033
I didn't understand
that JavaScript sort of

693
00:25:51,033 --> 00:25:53,234
ran top to bottom.

694
00:25:53,234 --> 00:25:55,434
But these core concepts
allow you to create

695
00:25:55,434 --> 00:25:59,367
all sorts of
really powerful stuff,

696
00:25:59,367 --> 00:26:02,501
assuming we understand what
happens with the word "this."

697
00:26:02,501 --> 00:26:04,300
So the word this
is really special.

698
00:26:04,300 --> 00:26:06,300
In order--Because we don't have
classes that wire up

699
00:26:06,300 --> 00:26:07,734
this inheritance hierarchy,

700
00:26:07,734 --> 00:26:09,734
and because we're always
delegating at runtime, right,

701
00:26:09,734 --> 00:26:13,234
every .operator sort of
does the dynamic lookup

702
00:26:13,234 --> 00:26:14,434
on the local object--

703
00:26:14,434 --> 00:26:16,267
looks at its delegate,
looks at its delegates.

704
00:26:16,267 --> 00:26:18,667
The this object
is a way of saying,

705
00:26:18,667 --> 00:26:21,501
okay, whatever scope I'm in,

706
00:26:21,501 --> 00:26:26,334
execute the next lookup
against the local object,

707
00:26:26,334 --> 00:26:29,701
which means that the this
keyword in any function

708
00:26:29,701 --> 00:26:31,834
isn't pointing
at some fixed object.

709
00:26:31,834 --> 00:26:34,667
It's not fixed
when I necessarily say,

710
00:26:34,667 --> 00:26:36,901
you know, create me an object.
It's promiscuous.

711
00:26:36,901 --> 00:26:39,067
The this keyword points
at whatever object my function

712
00:26:39,067 --> 00:26:40,901
is being called through.

713
00:26:40,901 --> 00:26:42,667
Right, remember function
objects are first class?

714
00:26:42,667 --> 00:26:46,434
They don't actually sort of
carry around relationships

715
00:26:46,434 --> 00:26:48,767
to their class or the thing
that they were defined in.

716
00:26:48,767 --> 00:26:50,100
They hold their own data.

717
00:26:50,100 --> 00:26:52,634
So the this keyword is
a nice little syntactic out

718
00:26:52,634 --> 00:26:58,434
which lets you say, okay,
whenever I look up a property,

719
00:26:58,434 --> 00:26:59,901
which happens to be
a function,

720
00:26:59,901 --> 00:27:04,934
and I call it, the .operator
for method calls says

721
00:27:04,934 --> 00:27:06,300
don't just return it.

722
00:27:06,300 --> 00:27:10,501
But if I evaluate it directly,
use the .call property

723
00:27:10,501 --> 00:27:11,934
of the function object

724
00:27:11,934 --> 00:27:14,767
that's returned and call it
in the scope of the object

725
00:27:14,767 --> 00:27:17,067
on the left hand side
of the .operator.

726
00:27:17,067 --> 00:27:18,634
I know this is a little bit
maybe tricky,

727
00:27:18,634 --> 00:27:21,634
but the easiest way to think
about this is that in order to

728
00:27:21,634 --> 00:27:23,100
wire up this behavior
correctly,

729
00:27:23,100 --> 00:27:26,434
so that it sort of does what you
expect out of other languages,

730
00:27:26,434 --> 00:27:28,434
we rely on the function
being first class,

731
00:27:28,434 --> 00:27:31,067
meaning it has its own call
and apply methods.

732
00:27:31,067 --> 00:27:33,934
You don't say necessarily,
hey, function,

733
00:27:33,934 --> 00:27:35,167
you're not going to work
if you're not called inside

734
00:27:35,167 --> 00:27:36,601
of some other object.

735
00:27:36,601 --> 00:27:40,000
I can call any function in
the scope of any other object.

736
00:27:40,000 --> 00:27:42,868
I can assign a function to any
other object and then call it

737
00:27:42,868 --> 00:27:45,734
through that object
dynamically, right?

738
00:27:45,734 --> 00:27:47,334
Everything is mutable.

739
00:27:47,334 --> 00:27:48,834
Functions are first class.
Why not?

740
00:27:48,834 --> 00:27:50,200
So in order to get
that to execute

741
00:27:50,200 --> 00:27:51,400
against the right object,

742
00:27:51,400 --> 00:27:52,968
you use the this keyword
to go grab

743
00:27:52,968 --> 00:27:54,567
the value out of the thing

744
00:27:54,567 --> 00:27:56,367
that was on
the left hand side of dot,

745
00:27:56,367 --> 00:27:58,234
which is exactly
the same thing as saying

746
00:27:58,234 --> 00:27:59,367
please call my function,

747
00:27:59,367 --> 00:28:00,767
which I pulled
out of that object,

748
00:28:00,767 --> 00:28:03,534
in the scope of the object
on the left hand side.

749
00:28:03,534 --> 00:28:05,200
Cool?

750
00:28:05,200 --> 00:28:06,701
All right.

751
00:28:06,701 --> 00:28:08,567
Okay.

752
00:28:08,567 --> 00:28:10,801
So all this fits together
in ways that allow us

753
00:28:10,801 --> 00:28:12,667
to recreate a lot of this stuff
that we expected

754
00:28:12,667 --> 00:28:13,667
in other languages.

755
00:28:13,667 --> 00:28:15,033
A lot of this
is convention.

756
00:28:15,033 --> 00:28:16,601
A lot of this isn't necessarily
the sort of thing

757
00:28:16,601 --> 00:28:18,234
that you're going
to have language level

758
00:28:18,234 --> 00:28:19,601
or syntactic support for,

759
00:28:19,601 --> 00:28:21,467
but if you understand
what's going on there,

760
00:28:21,467 --> 00:28:26,133
those sort of core little ideas
about mutability,

761
00:28:26,133 --> 00:28:32,067
scope, functions as first class
citizens, and dynamic behavior,

762
00:28:32,067 --> 00:28:34,834
we can start to recreate
things like classes.

763
00:28:34,834 --> 00:28:36,868
So here we've got an item type,

764
00:28:36,868 --> 00:28:39,701
which is we're going to
think of as a class.

765
00:28:39,701 --> 00:28:41,501
It's not really
called a class.

766
00:28:41,501 --> 00:28:43,200
It's just a function.
It's got the word function.

767
00:28:43,200 --> 00:28:44,567
As you saw earlier,

768
00:28:44,567 --> 00:28:46,634
when you use the word new
in front of any function,

769
00:28:46,634 --> 00:28:48,167
it sort of creates an object,

770
00:28:48,167 --> 00:28:50,400
calls that function inside
the context of that object,

771
00:28:50,400 --> 00:28:52,300
and then returns
that object back to you.

772
00:28:52,300 --> 00:28:54,267
That's the way to think
about the new keyword.

773
00:28:54,267 --> 00:28:56,100
So we're just going to
create a function,

774
00:28:56,100 --> 00:28:58,934
which we're going to call
with new sometime later,

775
00:28:58,934 --> 00:29:00,534
and inside of it
we're going to execute

776
00:29:00,534 --> 00:29:02,033
a couple of other functions.

777
00:29:02,033 --> 00:29:04,801
Now, we just saw .call,
and .call calls

778
00:29:04,801 --> 00:29:07,133
those other functions
in the scope of the object

779
00:29:07,133 --> 00:29:10,200
that we're being executed in
or that we want to pass in.

780
00:29:10,200 --> 00:29:12,868
In this case, we're going to
pass in the local object,

781
00:29:12,868 --> 00:29:14,067
and we're going
to do it twice,

782
00:29:14,067 --> 00:29:16,400
which means that
inside of tract,

783
00:29:16,400 --> 00:29:20,000
we're going to assign
a new property to this--

784
00:29:20,000 --> 00:29:22,434
which is to say the object
that was passed in--

785
00:29:22,434 --> 00:29:25,868
and inside of logged, we're
going to assign a new method

786
00:29:25,868 --> 00:29:29,133
where that method is going to go
dynamically look up the ID

787
00:29:29,133 --> 00:29:31,167
and log it out.

788
00:29:31,167 --> 00:29:32,467
So we call these mix-ins.

789
00:29:32,467 --> 00:29:34,367
These two methods up here
were written in a way

790
00:29:34,367 --> 00:29:35,968
that they don't delegate
to anything else.

791
00:29:35,968 --> 00:29:40,968
They don't assume anything about
the behavior of their methods

792
00:29:40,968 --> 00:29:43,033
or the properties
that they define.

793
00:29:43,033 --> 00:29:44,701
And instead,
they just add stuff.

794
00:29:44,701 --> 00:29:46,067
They just add stuff
dynamically

795
00:29:46,067 --> 00:29:50,334
when they're invoked against
some other object.

796
00:29:50,334 --> 00:29:52,200
So I could call them
in any other context,

797
00:29:52,200 --> 00:29:55,934
but in this case, I can use them
in the item type constructor

798
00:29:55,934 --> 00:29:59,067
to extend the item type
with some new stuff.

799
00:29:59,067 --> 00:30:01,968
We saw earlier how
delegation allows you to

800
00:30:01,968 --> 00:30:06,033
create new delegate
relationships between things,

801
00:30:06,033 --> 00:30:08,267
and functions also have
this idea of a prototype.

802
00:30:08,267 --> 00:30:09,934
This is the exposed version
of the thing we saw

803
00:30:09,934 --> 00:30:11,300
before with object.create,

804
00:30:11,300 --> 00:30:13,033
where I can say,
please wire up this relationship

805
00:30:13,033 --> 00:30:15,801
so that this object,
when you don't find it here,

806
00:30:15,801 --> 00:30:18,100
looks at that thing over there.

807
00:30:18,100 --> 00:30:21,434
So if we create
a new item type,

808
00:30:21,434 --> 00:30:23,667
what we'll see is
that it has an ID,

809
00:30:23,667 --> 00:30:27,434
and it has a type associated
with property added to them,

810
00:30:27,434 --> 00:30:30,200
which is pretty good.
And if we create another one,

811
00:30:30,200 --> 00:30:31,634
the counter is incremented,

812
00:30:31,634 --> 00:30:35,133
and the type is still
assigned to the same value.

813
00:30:35,133 --> 00:30:37,000
But if we create
a new sub item type,

814
00:30:37,000 --> 00:30:41,701
what we see is that,
because the prototype created

815
00:30:41,701 --> 00:30:46,400
a new property called type
with a new value,

816
00:30:46,400 --> 00:30:50,300
again, the delegate system
faults on the local object,

817
00:30:50,300 --> 00:30:53,167
looks at the object's
prototype--in this case,

818
00:30:53,167 --> 00:30:56,300
SubItemType.prototype--
pulls it out of there

819
00:30:56,300 --> 00:30:59,734
and doesn't fault all the way
through to ItemType.prototype.

820
00:30:59,734 --> 00:31:01,501
So we can compose
these things together in a way

821
00:31:01,501 --> 00:31:04,267
that gives us something like
classical inheritance.

822
00:31:04,267 --> 00:31:05,501
It's not exactly
the same thing.

823
00:31:05,501 --> 00:31:06,634
All this is dynamic.

824
00:31:06,634 --> 00:31:07,901
I can go and change
these prototypes.

825
00:31:07,901 --> 00:31:10,200
I can change
these objects later.

826
00:31:10,200 --> 00:31:12,667
But I've got the ability
to factor out code

827
00:31:12,667 --> 00:31:16,267
into something like a macro
or a trait, using mix-ins,

828
00:31:16,267 --> 00:31:18,267
and I've got the ability
to create

829
00:31:18,267 --> 00:31:20,868
an entire subclass
relationship,

830
00:31:20,868 --> 00:31:22,601
where I define
new function types

831
00:31:22,601 --> 00:31:25,133
which defer
to their super classes

832
00:31:25,133 --> 00:31:26,834
for a lot of their behavior.

833
00:31:26,834 --> 00:31:28,534
All right, we're starting
to get someplace.

834
00:31:28,534 --> 00:31:30,367
These core concepts have
given us the ability to

835
00:31:30,367 --> 00:31:33,767
define things that the language
didn't give us naturally,

836
00:31:33,767 --> 00:31:36,400
but we can go get
for ourselves.

837
00:31:36,400 --> 00:31:38,434
You know how I said
that everything is mutable,

838
00:31:38,434 --> 00:31:40,534
more or less?

839
00:31:40,534 --> 00:31:42,767
That means that we can
go and extend the stuff

840
00:31:42,767 --> 00:31:45,100
that is deferred to
by almost every object

841
00:31:45,100 --> 00:31:46,100
in the system, right?

842
00:31:46,100 --> 00:31:48,100
Remember, arrays
are objects.

843
00:31:48,100 --> 00:31:50,801
Objects are objects.
Functions are objects.

844
00:31:50,801 --> 00:31:52,467
Well, those things
have prototypes, too.

845
00:31:52,467 --> 00:31:53,901
They have exposed objects,

846
00:31:53,901 --> 00:31:56,434
which are--they defer to
when you don't find a property

847
00:31:56,434 --> 00:31:57,901
in the local object.

848
00:31:57,901 --> 00:32:01,367
So a radar prototype is, again,
an object which is mutable,

849
00:32:01,367 --> 00:32:04,467
and every instance of array,
every array in the system

850
00:32:04,467 --> 00:32:07,634
that faults on some property
is going to go look it up off

851
00:32:07,634 --> 00:32:10,300
of this object instead.
So I can extend it.

852
00:32:10,300 --> 00:32:12,801
I can say array.prototype.clear
is a new function.

853
00:32:12,801 --> 00:32:16,567
I can extend every single
array in the system at runtime,

854
00:32:16,567 --> 00:32:18,667
because the next line
is going to look it up

855
00:32:18,667 --> 00:32:21,767
through exactly
the same mechanism

856
00:32:21,767 --> 00:32:23,100
as everything else, right?

857
00:32:23,100 --> 00:32:25,734
This is not me
changing the type of array.

858
00:32:25,734 --> 00:32:27,467
I'm just extending
it dynamically.

859
00:32:27,467 --> 00:32:30,100
I'm creating a new thing
for you to hit,

860
00:32:30,100 --> 00:32:33,200
when you don't find the property
in the local array object.

861
00:32:33,200 --> 00:32:34,567
And I'm going to add to.

862
00:32:34,567 --> 00:32:36,334
In this case, they're
going to return new arrays

863
00:32:36,334 --> 00:32:38,968
when they're done, and so
I can chain them together.

864
00:32:38,968 --> 00:32:40,334
And so this is how
you can sort of create

865
00:32:40,334 --> 00:32:42,801
little dynamic languages
in JavaScript.

866
00:32:42,801 --> 00:32:44,133
You can create DSLs
in JavaScript

867
00:32:44,133 --> 00:32:46,567
by changing the things
that you delegate to.

868
00:32:46,567 --> 00:32:48,133
If you create new objects,

869
00:32:48,133 --> 00:32:49,667
and they delegate
to some prototype,

870
00:32:49,667 --> 00:32:51,234
and you can mutate
that prototype,

871
00:32:51,234 --> 00:32:55,334
well, then you can change almost
everything about the system.

872
00:32:55,334 --> 00:32:58,501
Yes, you can change almost
everything about the system.

873
00:32:58,501 --> 00:33:00,834
And, yes, it is a huge
maintainability nightmare.

874
00:33:00,834 --> 00:33:03,267
This is really good
when your code can do it.

875
00:33:03,267 --> 00:33:06,267
This can be a huge problem
when everybody's code can do it,

876
00:33:06,267 --> 00:33:08,467
especially as you get
into larger code bases.

877
00:33:08,467 --> 00:33:11,100
So collectively,
as a community,

878
00:33:11,100 --> 00:33:13,801
the JavaScript world has started
to learn these patterns

879
00:33:13,801 --> 00:33:17,234
of practice, which they say,
please don't ever go

880
00:33:17,234 --> 00:33:19,367
and mutate array.prototype.

881
00:33:19,367 --> 00:33:21,501
Please don't change
object.prototype,

882
00:33:21,501 --> 00:33:23,467
so that you don't wind up

883
00:33:23,467 --> 00:33:24,834
stepping on somebody
else's toes,

884
00:33:24,834 --> 00:33:26,567
stepping on somebody
else's extensions.

885
00:33:26,567 --> 00:33:28,367
But this is power
that we'd really like to have.

886
00:33:28,367 --> 00:33:29,801
This is power that
we'd really like to be able

887
00:33:29,801 --> 00:33:31,000
to take advantage of.

888
00:33:31,000 --> 00:33:32,601
Being able to extend
methods in the system

889
00:33:32,601 --> 00:33:34,000
is the sort of thing

890
00:33:34,000 --> 00:33:35,934
that we've seen work pretty well
in languages like C#,

891
00:33:35,934 --> 00:33:38,467
where they have extension
methods to interfaces.

892
00:33:38,467 --> 00:33:39,501
We really want to be able
to use this,

893
00:33:39,501 --> 00:33:40,734
because it shortens up our code.

894
00:33:40,734 --> 00:33:42,467
It makes it dynamic.
It makes it easy to read,

895
00:33:42,467 --> 00:33:44,868
and it makes it possible
to build up the language

896
00:33:44,868 --> 00:33:46,834
to meet us halfway,

897
00:33:46,834 --> 00:33:49,567
which is a great feature
of many dynamic languages.

898
00:33:49,567 --> 00:33:54,167
So JavaScript has this
incredible dynamic behavior,

899
00:33:54,167 --> 00:33:55,501
which gives us
a lot of power,

900
00:33:55,501 --> 00:33:58,400
and so we wind up using it
to do all sorts of things

901
00:33:58,400 --> 00:34:00,400
that the language
doesn't necessarily,

902
00:34:00,400 --> 00:34:03,067
because it's a little language,
have built-in support for.

903
00:34:03,067 --> 00:34:05,801
So in this case,
I'm going to, again,

904
00:34:05,801 --> 00:34:08,100
create an expression
that has an anonymous function

905
00:34:08,100 --> 00:34:09,367
defined inside of it.

906
00:34:09,367 --> 00:34:10,767
But, instead,
I'm going to do some stuff here

907
00:34:10,767 --> 00:34:13,567
where I'm going to define
a local object, right?

908
00:34:13,567 --> 00:34:14,868
We've seen this before,

909
00:34:14,868 --> 00:34:16,133
that might get captured
in an enclosure;

910
00:34:16,133 --> 00:34:18,434
and, in fact,
it's going to here.

911
00:34:18,434 --> 00:34:21,968
But the little piece
of sophistry

912
00:34:21,968 --> 00:34:23,234
at the bottom there,

913
00:34:23,234 --> 00:34:26,701
or in the middle there,
where I end the function,

914
00:34:26,701 --> 00:34:28,100
I end the expression,

915
00:34:28,100 --> 00:34:30,801
which is going to return
that function

916
00:34:30,801 --> 00:34:32,334
as the result of
that expression,

917
00:34:32,334 --> 00:34:34,267
and then I invoke it
immediately,

918
00:34:34,267 --> 00:34:35,534
means that what happens here

919
00:34:35,534 --> 00:34:37,701
is that I've sort of
created some code

920
00:34:37,701 --> 00:34:39,467
and just run it directly.

921
00:34:39,467 --> 00:34:40,801
I've just top to bottom

922
00:34:40,801 --> 00:34:44,100
run some code, which is going to
define a local variable,

923
00:34:44,100 --> 00:34:45,934
create a function--
which is not local,

924
00:34:45,934 --> 00:34:49,100
which is going to get exported
back out to the global scope,

925
00:34:49,100 --> 00:34:51,767
but that function can see
the local stuff, right?

926
00:34:51,767 --> 00:34:54,334
So I can sort of hide away
in my own private stuff

927
00:34:54,334 --> 00:34:55,868
inside of my module
by putting it in this pattern,

928
00:34:55,868 --> 00:34:57,467
using VAR for the stuff.

929
00:34:57,467 --> 00:35:00,367
It's a local and emitting VAR
for the stuff that's global.

930
00:35:00,367 --> 00:35:01,734
That's pretty good.

931
00:35:01,734 --> 00:35:03,434
We've got some sense
of modularity, again,

932
00:35:03,434 --> 00:35:07,501
built on this few set of
prototypical properties

933
00:35:07,501 --> 00:35:08,834
of the language:

934
00:35:08,834 --> 00:35:11,067
mutability, functions
as first class and functions

935
00:35:11,067 --> 00:35:12,968
as the only things
that create scope,

936
00:35:12,968 --> 00:35:16,133
the ability to modify
nearly everything,

937
00:35:16,133 --> 00:35:20,834
and closures as a way
to bind behavior to data

938
00:35:20,834 --> 00:35:24,968
and not the other way around.
Okay, so as you can imagine,

939
00:35:24,968 --> 00:35:26,334
we've seen a couple
of places here now

940
00:35:26,334 --> 00:35:28,067
with classes
and now with modules,

941
00:35:28,067 --> 00:35:30,701
where we could start to use
these patterns together

942
00:35:30,701 --> 00:35:33,501
to start to build up
our little library of stuff

943
00:35:33,501 --> 00:35:34,767
to help us
meet the challenges

944
00:35:34,767 --> 00:35:36,267
that we've got in
the large code base;

945
00:35:36,267 --> 00:35:38,167
and, in fact,
nearly every large code base

946
00:35:38,167 --> 00:35:40,701
has a library like this.

947
00:35:40,701 --> 00:35:42,100
The world of
JavaScript libraries

948
00:35:42,100 --> 00:35:44,400
has a lot of different answers
to a lot of the questions

949
00:35:44,400 --> 00:35:46,534
that you want.
So for modularity,

950
00:35:46,534 --> 00:35:48,901
it'd be great if we could
sort of have a script loader

951
00:35:48,901 --> 00:35:50,367
that would pull in
a bunch of stuff.

952
00:35:50,367 --> 00:35:51,767
It would transitive
dependency management,

953
00:35:51,767 --> 00:35:54,834
and it would put our stuff
inside of this body of code

954
00:35:54,834 --> 00:35:56,968
that we could then
think of as something

955
00:35:56,968 --> 00:35:59,868
that has dependencies
but can also hide local state.

956
00:35:59,868 --> 00:36:01,267
So this is the closure example.

957
00:36:01,267 --> 00:36:04,634
This is the tree control,
and these are its dependencies.

958
00:36:04,634 --> 00:36:06,067
And it does almost
exactly this, right?

959
00:36:06,067 --> 00:36:09,300
This is the module
that it might define,

960
00:36:09,300 --> 00:36:11,634
and it's going to
export some stuff.

961
00:36:11,634 --> 00:36:13,934
Okay, that's pretty good.

962
00:36:13,934 --> 00:36:15,934
But then you look at
other JavaScript libraries,

963
00:36:15,934 --> 00:36:17,634
and they do almost exactly
the same thing.

964
00:36:17,634 --> 00:36:19,400
Here's a tree control
from the tool kit

965
00:36:19,400 --> 00:36:22,067
that I used to work on, digit.

966
00:36:22,067 --> 00:36:25,267
And so that does exactly
the same thing, right?

967
00:36:25,267 --> 00:36:26,901
We've got this
module pattern here,

968
00:36:26,901 --> 00:36:29,467
where that's going to be
what you define inside of it.

969
00:36:29,467 --> 00:36:32,767
And at the same time,
these two syntaxes

970
00:36:32,767 --> 00:36:35,100
and these two semantics
aren't interoperable.

971
00:36:35,100 --> 00:36:37,667
You can't use them together.
That's not great.

972
00:36:37,667 --> 00:36:40,000
Now, we're in a place where
we have all of this raw power,

973
00:36:40,000 --> 00:36:42,634
and we can start to harness it
in ways that solve our problems,

974
00:36:42,634 --> 00:36:46,300
but we can't say the same thing
unless we all agree a priori

975
00:36:46,300 --> 00:36:47,767
which sort of patterns
we're going to use

976
00:36:47,767 --> 00:36:50,567
and in which style
we're going to use them.

977
00:36:50,567 --> 00:36:52,701
So this is the role
of the language.

978
00:36:52,701 --> 00:36:54,901
This is where language
evolution can really start

979
00:36:54,901 --> 00:36:56,767
to pay off
some big dividends.

980
00:36:56,767 --> 00:37:02,501
And so this is Dave Herman's
simple module proposal syntax,

981
00:37:02,501 --> 00:37:05,100
and this is something
like the array,

982
00:37:05,100 --> 00:37:10,033
the tree control requirements
written out in the new syntax.

983
00:37:10,033 --> 00:37:12,968
As you can see,
we actually have syntax saying

984
00:37:12,968 --> 00:37:14,200
this thing
is going to be a module.

985
00:37:14,200 --> 00:37:15,501
I'd like you
to acquire it.

986
00:37:15,501 --> 00:37:18,267
I'd like you to import
these sets of things

987
00:37:18,267 --> 00:37:20,601
into my local scope.

988
00:37:20,601 --> 00:37:23,934
And because we've got syntax
for this in harmony,

989
00:37:23,934 --> 00:37:26,267
which is the next version
of ECMAScript,

990
00:37:26,267 --> 00:37:27,801
we've got the ability
for everyone

991
00:37:27,801 --> 00:37:29,934
to agree on what it is
you're trying to get done.

992
00:37:29,934 --> 00:37:31,334
Because you have syntax,

993
00:37:31,334 --> 00:37:34,467
no one now has the incentive
to go write their own thing.

994
00:37:34,467 --> 00:37:37,868
You can start to rely on
there being one canonical way

995
00:37:37,868 --> 00:37:41,267
of saying here are my exports,
here are my imports.

996
00:37:41,267 --> 00:37:42,434
Here's how it's done.

997
00:37:42,434 --> 00:37:44,434
And so tool kits can
start to interoperate.

998
00:37:44,434 --> 00:37:45,934
They don't have to
continue to compete

999
00:37:45,934 --> 00:37:47,701
or, you know, reinvent

1000
00:37:47,701 --> 00:37:50,367
on the basis of
a low level set of things

1001
00:37:50,367 --> 00:37:52,400
that you might hope
would be provided for you

1002
00:37:52,400 --> 00:37:54,067
in the language.

1003
00:37:54,067 --> 00:37:55,567
The same thing
goes for classes.

1004
00:37:55,567 --> 00:37:57,534
You know how we saw
all that boilerplate earlier,

1005
00:37:57,534 --> 00:37:59,234
where you had the mix-ins
were for functions,

1006
00:37:59,234 --> 00:38:01,567
and the classes which were
defined as functions--

1007
00:38:01,567 --> 00:38:04,033
well, they all have
the same word, function.

1008
00:38:04,033 --> 00:38:05,334
How do you know
it's a function?

1009
00:38:05,334 --> 00:38:06,901
Again, we saw the word function
reused to go define

1010
00:38:06,901 --> 00:38:08,200
that closure,

1011
00:38:08,200 --> 00:38:11,200
which gave us the scope
for using the module pattern.

1012
00:38:11,200 --> 00:38:12,834
Well, the word function
gets a lot of use,

1013
00:38:12,834 --> 00:38:15,400
and in fact,
it is used so often

1014
00:38:15,400 --> 00:38:17,000
that it's hard
to understand exactly

1015
00:38:17,000 --> 00:38:18,901
what it is
you're reading sometimes,

1016
00:38:18,901 --> 00:38:20,734
if you're not familiar
with all of these patterns.

1017
00:38:20,734 --> 00:38:23,467
And so nearly every tool kit
comes along

1018
00:38:23,467 --> 00:38:26,167
and creates a shorthand
to help you define a class,

1019
00:38:26,167 --> 00:38:27,434
because, you know,

1020
00:38:27,434 --> 00:38:28,667
you can just write
a function that'll do it.

1021
00:38:28,667 --> 00:38:32,234
Closure does it.

1022
00:38:32,234 --> 00:38:34,200
Prototype does it.

1023
00:38:34,200 --> 00:38:35,834
You can imagine
that MochiKit

1024
00:38:35,834 --> 00:38:37,534
or Dojo all do it slightly
differently,

1025
00:38:37,534 --> 00:38:39,467
and these all lead to slightly
different semantics,

1026
00:38:39,467 --> 00:38:42,667
because the way that you wire up
those relationships internally--

1027
00:38:42,667 --> 00:38:47,534
and I showed you one way
with using traits

1028
00:38:47,534 --> 00:38:49,868
or mix-ins inside
of constructor functions.

1029
00:38:49,868 --> 00:38:51,234
They make different
decisions.

1030
00:38:51,234 --> 00:38:52,734
You can compose this stuff
a lot of different ways,

1031
00:38:52,734 --> 00:38:54,467
because you're always sort of
cobbling it together

1032
00:38:54,467 --> 00:38:56,734
from the raw material
that's already in front of you.

1033
00:38:56,734 --> 00:38:57,901
It's incredibly powerful,

1034
00:38:57,901 --> 00:38:59,734
but with that power
comes the requirement

1035
00:38:59,734 --> 00:39:01,868
that you have to get a bunch
of people to agree with you

1036
00:39:01,868 --> 00:39:03,501
about how to use it.

1037
00:39:03,501 --> 00:39:04,667
And in this case,

1038
00:39:04,667 --> 00:39:06,901
a bunch of well-meaning
library authors came up

1039
00:39:06,901 --> 00:39:09,501
with really good solutions
that fit their constraints.

1040
00:39:09,501 --> 00:39:11,200
And in this case,

1041
00:39:11,200 --> 00:39:12,701
they all differ
a little bit in terms of

1042
00:39:12,701 --> 00:39:14,734
the underlying semantic, and
that's a little bit frustrating

1043
00:39:14,734 --> 00:39:16,467
when you want to just
share a little bit of code

1044
00:39:16,467 --> 00:39:17,701
with somebody over there.

1045
00:39:17,701 --> 00:39:20,501
So what we'd like to do
is say what we mean.

1046
00:39:20,501 --> 00:39:23,400
So this is a little bit of code
that comes from

1047
00:39:23,400 --> 00:39:26,667
Marcin Wichary's
awesome Pac-Man demo,

1048
00:39:26,667 --> 00:39:28,834
but this wouldn't be
how you'd write it today.

1049
00:39:28,834 --> 00:39:31,133
This is how you'd have
to write in the future.

1050
00:39:31,133 --> 00:39:33,033
Or this isn't how you would
have to write it today.

1051
00:39:33,033 --> 00:39:34,300
This is what you would
like to be writing.

1052
00:39:34,300 --> 00:39:35,934
You'd like to say,
I've got a class.

1053
00:39:35,934 --> 00:39:39,367
It's got a constructor body,
and it's got some methods,

1054
00:39:39,367 --> 00:39:40,968
and then I've got
a subclass which,

1055
00:39:40,968 --> 00:39:43,100
you know, wires with that
prototypal relationship

1056
00:39:43,100 --> 00:39:45,868
with the other thing.
It's got a constructor body,

1057
00:39:45,868 --> 00:39:48,534
and it defines some properties
on its prototype.

1058
00:39:48,534 --> 00:39:50,701
What we'd like to do
is have this syntax map

1059
00:39:50,701 --> 00:39:52,367
to exactly what
we saw before, right?

1060
00:39:52,367 --> 00:39:56,267
We don't want to change
the fundamental idea

1061
00:39:56,267 --> 00:39:57,601
of what the language is.

1062
00:39:57,601 --> 00:40:00,133
Prototype based,
functions as first class,

1063
00:40:00,133 --> 00:40:03,701
closures to carry state,
top to bottom evaluation,

1064
00:40:03,701 --> 00:40:07,033
delegation and not classes.

1065
00:40:07,033 --> 00:40:09,834
When we introduce a syntax
for the word class, right,

1066
00:40:09,834 --> 00:40:11,934
what we would like
for this to have happen here

1067
00:40:11,934 --> 00:40:13,300
is when we evolve
the language,

1068
00:40:13,300 --> 00:40:15,934
we want to hold on to
that fundamental set of things

1069
00:40:15,934 --> 00:40:17,501
that define JavaScript
as JavaScript,

1070
00:40:17,501 --> 00:40:20,234
so that you can understand old
code in the context of new code

1071
00:40:20,234 --> 00:40:22,567
and that JavaScript can maintain
a lot of that dynamic,

1072
00:40:22,567 --> 00:40:25,534
which pays off so well when
we need to start doing things

1073
00:40:25,534 --> 00:40:26,834
that the language
doesn't provide for us.

1074
00:40:26,834 --> 00:40:28,300
Because
what we've seen today is

1075
00:40:28,300 --> 00:40:32,000
that we've put together a whole
series of things from raw parts,

1076
00:40:32,000 --> 00:40:34,300
just little raw material, things
that are very high level,

1077
00:40:34,300 --> 00:40:37,767
very high level constructs that
you're going to need to use,

1078
00:40:37,767 --> 00:40:40,367
that you might not expect
to be there on JavaScript,

1079
00:40:40,367 --> 00:40:41,734
but JavaScript
provides them for you.

1080
00:40:41,734 --> 00:40:42,834
And it's easy
to love a language

1081
00:40:42,834 --> 00:40:45,400
that gives you
that kind of power.

1082
00:40:45,400 --> 00:40:46,868
So we wanted something that

1083
00:40:46,868 --> 00:40:48,300
we in the standards committee
call de-sugaring.

1084
00:40:48,300 --> 00:40:49,734
And de-sugaring
is the concept

1085
00:40:49,734 --> 00:40:53,100
of when you define a new idea,
or you define new syntax,

1086
00:40:53,100 --> 00:40:56,868
or a new semantic
in the language,

1087
00:40:56,868 --> 00:40:59,634
it would be best if we could
describe that new thing

1088
00:40:59,634 --> 00:41:01,767
in terms of the stuff
that's already there.

1089
00:41:01,767 --> 00:41:04,868
So if I describe
a new language feature by

1090
00:41:04,868 --> 00:41:07,501
what it would be like
if I'd just written it all out,

1091
00:41:07,501 --> 00:41:09,334
we can start to say, aha.

1092
00:41:09,334 --> 00:41:10,634
This fits
or this doesn't fit

1093
00:41:10,634 --> 00:41:12,667
with the way we start to use
JavaScript today.

1094
00:41:12,667 --> 00:41:14,801
So this is an example
of what I'd like to write

1095
00:41:14,801 --> 00:41:18,367
in the new style, and what
you would have to write today

1096
00:41:18,367 --> 00:41:21,734
to go make this all
work in the old style.

1097
00:41:21,734 --> 00:41:25,501
Okay, that's a lot,
and it's a lot of boilerplate

1098
00:41:25,501 --> 00:41:28,100
that we shouldn't
have to write.

1099
00:41:28,100 --> 00:41:30,334
The same thing goes for
a lot of sort of little

1100
00:41:30,334 --> 00:41:31,567
syntactic niggles.

1101
00:41:31,567 --> 00:41:34,167
So let's say
I want a function

1102
00:41:34,167 --> 00:41:35,601
that takes variable arguments.

1103
00:41:35,601 --> 00:41:37,667
Today, in JavaScript, I have
to go unpack those arguments

1104
00:41:37,667 --> 00:41:39,534
out of an explicit
arguments property

1105
00:41:39,534 --> 00:41:41,634
that's available
inside the scope of any--

1106
00:41:41,634 --> 00:41:44,167
inside of any function.

1107
00:41:44,167 --> 00:41:46,100
So if I want a default value,

1108
00:41:46,100 --> 00:41:47,601
I have to go
provide it for myself,

1109
00:41:47,601 --> 00:41:50,267
and if I want to go grab
variable array arguments,

1110
00:41:50,267 --> 00:41:54,467
I have to go grab the--turn
the best of the arguments

1111
00:41:54,467 --> 00:41:58,934
into an array,
using array.prototype.slice,

1112
00:41:58,934 --> 00:42:02,100
pass it in to the arguments
object as the scope,

1113
00:42:02,100 --> 00:42:04,601
and then say give me everything
after the first one, right?

1114
00:42:04,601 --> 00:42:06,167
And then create me
the list of parameters.

1115
00:42:06,167 --> 00:42:07,367
That's a lot of boilerplate.

1116
00:42:07,367 --> 00:42:09,834
It's sort of hard
to read that function,

1117
00:42:09,834 --> 00:42:14,968
if you don't know this
particular sort of pattern,

1118
00:42:14,968 --> 00:42:16,901
and then to understand what
it is that it's trying to do.

1119
00:42:16,901 --> 00:42:18,367
It's much better
as a language,

1120
00:42:18,367 --> 00:42:20,868
if what we get to is a place
where we can say what we mean

1121
00:42:20,868 --> 00:42:22,200
when we're writing
our functions.

1122
00:42:22,200 --> 00:42:25,000
I'd like the format
to have a default property

1123
00:42:25,000 --> 00:42:28,167
of a blank string,
and I'd like the parameters

1124
00:42:28,167 --> 00:42:33,033
that you don't have allocated
to some named argument

1125
00:42:33,033 --> 00:42:35,567
stashed away in an array
called params.

1126
00:42:35,567 --> 00:42:38,300
That's a pretty common thing
to want to do.

1127
00:42:38,300 --> 00:42:42,501
And so this sort of thing
is coming in the next version

1128
00:42:42,501 --> 00:42:44,000
of the language,

1129
00:42:44,000 --> 00:42:50,601
and last week at JS Conf
and again at Node Conf,

1130
00:42:50,601 --> 00:42:51,968
we started talking
about some work

1131
00:42:51,968 --> 00:42:55,234
that we're doing on the Chrome
Team with the JavaScript

1132
00:42:55,234 --> 00:42:57,734
and JavaScript compiler
written in JavaScript

1133
00:42:57,734 --> 00:42:59,334
called Traceur.

1134
00:42:59,334 --> 00:43:00,767
And Traceur's goal

1135
00:43:00,767 --> 00:43:02,968
is to help us design
these new language features

1136
00:43:02,968 --> 00:43:06,567
in a way that works really
well by trying them out,

1137
00:43:06,567 --> 00:43:09,033
because language evolution
isn't a straight line thing.

1138
00:43:09,033 --> 00:43:11,234
You know, we said that all these
libraries have different ways

1139
00:43:11,234 --> 00:43:13,300
of doing a lot of the stuff,

1140
00:43:13,300 --> 00:43:14,667
so what we'd like to do
is figure out

1141
00:43:14,667 --> 00:43:16,100
what's the best pattern
or practice?

1142
00:43:16,100 --> 00:43:17,868
What's the thing that
we would really like to blast?

1143
00:43:17,868 --> 00:43:19,100
Or when there is
a new semantic

1144
00:43:19,100 --> 00:43:21,067
that we can introduce
into the language,

1145
00:43:21,067 --> 00:43:22,934
what is it that we would be
trying to say

1146
00:43:22,934 --> 00:43:24,567
in JavaScript directly?

1147
00:43:24,567 --> 00:43:31,033
And so this way, we sort of
have a way of, at runtime,

1148
00:43:31,033 --> 00:43:34,300
running this compiler over
some piece of JavaScript

1149
00:43:34,300 --> 00:43:36,033
written in the new syntax
and have it do something

1150
00:43:36,033 --> 00:43:37,667
in the old syntax.

1151
00:43:37,667 --> 00:43:40,934
So in this case--

1152
00:43:48,400 --> 00:43:51,100
I'm going to go grab something
out of the parameters,

1153
00:43:51,100 --> 00:43:55,701
and as you can see, it's
recompiling here, as I type.

1154
00:44:08,167 --> 00:44:12,834
And now it has--

1155
00:44:12,834 --> 00:44:14,601
ah, yes, there we are.

1156
00:44:14,601 --> 00:44:16,501
Now it's created
all of the stuff

1157
00:44:16,501 --> 00:44:18,167
that I was going to have
to write out by hand.

1158
00:44:18,167 --> 00:44:19,300
It's just compiled that down

1159
00:44:19,300 --> 00:44:21,734
from the new syntax
to the old syntax,

1160
00:44:21,734 --> 00:44:24,567
and I can run it.

1161
00:44:24,567 --> 00:44:27,300
I should be able to run it.

1162
00:44:27,300 --> 00:44:33,033
man:
[indistinct comment]

1163
00:44:33,033 --> 00:44:39,334
Russell:
Ah, yes, good call.

1164
00:44:39,334 --> 00:44:40,601
Great, there we go.

1165
00:44:40,601 --> 00:44:45,367
So this is a tool
that we're starting to use

1166
00:44:45,367 --> 00:44:47,634
to help inform
the language evolution

1167
00:44:47,634 --> 00:44:50,200
in order to help us
prototype stuff fast,

1168
00:44:50,200 --> 00:44:51,901
get feedback
about how it works,

1169
00:44:51,901 --> 00:44:53,701
and so we can
start to understand

1170
00:44:53,701 --> 00:44:55,467
how the new stuff that
we're adding into the language

1171
00:44:55,467 --> 00:44:57,801
fits with the old stuff
by writing real code in it.

1172
00:44:57,801 --> 00:44:59,300
And as we work
in the standards committee

1173
00:44:59,300 --> 00:45:02,033
to help make this stuff reality,
this sort of tool,

1174
00:45:02,033 --> 00:45:04,067
I hope, is going to
make it possible for us

1175
00:45:04,067 --> 00:45:06,767
to evolve faster and evolve
in a straighter line

1176
00:45:06,767 --> 00:45:09,167
with the existing versions
of JavaScript,

1177
00:45:09,167 --> 00:45:10,400
because what we don't want
is for us

1178
00:45:10,400 --> 00:45:13,367
to add new things
like the idea of a class

1179
00:45:13,367 --> 00:45:15,868
and have it be at war with the
idea of prototypal inheritance

1180
00:45:15,868 --> 00:45:17,734
or functions
as first class objects.

1181
00:45:17,734 --> 00:45:21,901
We want to continue to help you
build on these core fundamental,

1182
00:45:21,901 --> 00:45:23,534
really powerful building blocks
in the language

1183
00:45:23,534 --> 00:45:29,033
without introducing
new sorts of ideas or overhead

1184
00:45:29,033 --> 00:45:30,801
that you have to consider
when you're writing your code.

1185
00:45:30,801 --> 00:45:33,567
And so Traceur, again,
is an effort to help us

1186
00:45:33,567 --> 00:45:35,701
understand and experiment
with the language,

1187
00:45:35,701 --> 00:45:39,000
and it's available as an open
source project on Google Code.

1188
00:45:39,000 --> 00:45:41,834
You can use it today, both on
the server and on the client,

1189
00:45:41,834 --> 00:45:43,734
and you can start
to play with it.

1190
00:45:43,734 --> 00:45:45,300
You can start to write
real code in it.

1191
00:45:45,300 --> 00:45:48,167
There's a read, evaluate,
and print loop

1192
00:45:48,167 --> 00:45:56,033
that you can just go to
and start typing code into.

1193
00:45:56,033 --> 00:45:58,133
So I won't belabor
that anymore,

1194
00:45:58,133 --> 00:46:04,067
but what we're really hoping
for is that you can start to use

1195
00:46:04,067 --> 00:46:06,767
a lot of the new features that
we've started to play with.

1196
00:46:06,767 --> 00:46:09,033
We have a list of features that
we've implemented in Traceur,

1197
00:46:09,033 --> 00:46:10,367
and that's expanding every day.

1198
00:46:10,367 --> 00:46:12,868
But things like modules,
classes, and traits,

1199
00:46:12,868 --> 00:46:14,200
asynchronous programming--

1200
00:46:14,200 --> 00:46:16,000
Asynchronous programming
is something we have to do

1201
00:46:16,000 --> 00:46:17,968
all the time, and we wind up
doing it with a callback system.

1202
00:46:17,968 --> 00:46:19,434
It'd be great if
there was support for that

1203
00:46:19,434 --> 00:46:21,133
in a language that we didn't
have to continue to write

1204
00:46:21,133 --> 00:46:23,100
the same boilerplate
over and over and over again.

1205
00:46:23,100 --> 00:46:24,968
Destructuring assignment,
like we just saw,

1206
00:46:24,968 --> 00:46:27,834
and the ability to use
the prototypal sort of style

1207
00:46:27,834 --> 00:46:29,868
of extension,
but have it happen in a way

1208
00:46:29,868 --> 00:46:31,601
that doesn't conflict
with everybody else's objects

1209
00:46:31,601 --> 00:46:32,801
in the system.

1210
00:46:32,801 --> 00:46:34,667
Those are the sorts of
high priority work items

1211
00:46:34,667 --> 00:46:38,734
that we're starting to use
Traceur to evaluate designs for,

1212
00:46:38,734 --> 00:46:40,167
and we'd love your help.

1213
00:46:40,167 --> 00:46:42,601
We'd love for you to start
using it, testing it out,

1214
00:46:42,601 --> 00:46:44,968
working with the system,
and helping us write code

1215
00:46:44,968 --> 00:46:46,234
in the new style,
so we can understand

1216
00:46:46,234 --> 00:46:48,667
whether or not
it's actually good.

1217
00:46:48,667 --> 00:46:52,133
So Traceur is one idea
to help us get there.

1218
00:46:52,133 --> 00:46:54,968
We need implementations early
to inform the design process

1219
00:46:54,968 --> 00:46:57,267
for the future of the language,
so that the things that you do

1220
00:46:57,267 --> 00:47:00,334
in the language now
carry out into the future

1221
00:47:00,334 --> 00:47:05,100
as core idioms and core concepts
that you can rely on there, too.

1222
00:47:05,100 --> 00:47:07,300
But we need those things
to eventually trickle down

1223
00:47:07,300 --> 00:47:10,934
into real, live implementations,
V8, other JavaScript engines,

1224
00:47:10,934 --> 00:47:12,367
and we want to make sure
that these things

1225
00:47:12,367 --> 00:47:15,033
are available to you quickly in
the fast-moving constituencies.

1226
00:47:15,033 --> 00:47:18,667
So if you can start to use this
stuff in the Chrome Web Store--

1227
00:47:18,667 --> 00:47:21,534
because almost everyone in
the Chrome Web Store gets--

1228
00:47:21,534 --> 00:47:23,868
or who you can target
through the Chrome Web Store

1229
00:47:23,868 --> 00:47:25,734
gets the latest version
of Chrome within a week--

1230
00:47:25,734 --> 00:47:26,968
that's really good.

1231
00:47:26,968 --> 00:47:28,868
We can start to get fast
feedback in the language

1232
00:47:28,868 --> 00:47:31,501
and in the design of the
next version of JavaScript

1233
00:47:31,501 --> 00:47:33,467
based on your feedback
about what's working

1234
00:47:33,467 --> 00:47:36,267
and what's not in ways
that we couldn't before.

1235
00:47:36,267 --> 00:47:39,467
The lead time on a new version
of the language has been years--

1236
00:47:39,467 --> 00:47:42,267
in some cases,
closer to a decade.

1237
00:47:42,267 --> 00:47:47,267
And so you can follow along
the ECMAScript wiki.

1238
00:47:47,267 --> 00:47:48,567
I realize this is--
the link

1239
00:47:48,567 --> 00:47:50,033
is a little bit long,
but there's a list

1240
00:47:50,033 --> 00:47:51,868
of accepted proposals for the
next version of the language.

1241
00:47:51,868 --> 00:47:53,267
That's going to be
somewhat formalized

1242
00:47:53,267 --> 00:47:54,567
in the next couple of months.

1243
00:47:54,567 --> 00:47:56,300
And as that list
is locked down,

1244
00:47:56,300 --> 00:47:58,300
we're going to continue
to iterate on those proposals.

1245
00:47:58,300 --> 00:47:59,601
They're going to get
new syntax.

1246
00:47:59,601 --> 00:48:01,100
Things are going
to change there.

1247
00:48:01,100 --> 00:48:02,968
But the list of things
that are in the proposal stage

1248
00:48:02,968 --> 00:48:04,334
for Harmony are the set
of things that we,

1249
00:48:04,334 --> 00:48:06,267
as a committee,
have agreed to go work on

1250
00:48:06,267 --> 00:48:07,667
and standardize together.

1251
00:48:07,667 --> 00:48:08,868
And so Traceur
is going to continue

1252
00:48:08,868 --> 00:48:10,200
to follow that evolution

1253
00:48:10,200 --> 00:48:12,634
and allow us
to start to work in ways

1254
00:48:12,634 --> 00:48:15,367
that give us quick feedback
about whether or not

1255
00:48:15,367 --> 00:48:17,000
we're doing the right things
for you

1256
00:48:17,000 --> 00:48:20,734
as you're writing large
pieces of JavaScript.

1257
00:48:20,734 --> 00:48:24,167
Okay, questions?

1258
00:48:29,734 --> 00:48:33,501
man: Hi. So the common JS
modules specification

1259
00:48:33,501 --> 00:48:37,434
has like a really simple
require and exports

1260
00:48:37,434 --> 00:48:39,767
that really doesn't--
that--it's kind of--

1261
00:48:39,767 --> 00:48:41,367
it doesn't factor in,
you know,

1262
00:48:41,367 --> 00:48:42,734
how things
get loaded or whatever.

1263
00:48:42,734 --> 00:48:44,801
It's really just a binding
mechanism between

1264
00:48:44,801 --> 00:48:46,334
disparate name space.

1265
00:48:46,334 --> 00:48:47,934
That seems ultimately
simple to me,

1266
00:48:47,934 --> 00:48:50,968
but it doesn't seem like Harmony
is going in that direction.

1267
00:48:50,968 --> 00:48:54,868
Russell: So the simple
modules proposal

1268
00:48:54,868 --> 00:48:57,734
gives us a way
to have a first pass.

1269
00:48:57,734 --> 00:49:01,968
So...sorry, I should run this
backwards.

1270
00:49:01,968 --> 00:49:07,534
The common JS module system
sort of is implicitly server JS.

1271
00:49:07,534 --> 00:49:09,534
You kind of assume that
the thing that you're getting

1272
00:49:09,534 --> 00:49:11,200
in the next statement
is cheap to fetch.

1273
00:49:11,200 --> 00:49:12,868
And so what we need
for the client

1274
00:49:12,868 --> 00:49:17,534
is an ability to make the
require and provide statements

1275
00:49:17,534 --> 00:49:19,734
look apparently synchronous
but have them operate

1276
00:49:19,734 --> 00:49:22,000
asynchronously on the network,
which means that we want to get

1277
00:49:22,000 --> 00:49:24,667
the transitive closure
of all of the dependencies

1278
00:49:24,667 --> 00:49:26,000
that your module needs.

1279
00:49:26,000 --> 00:49:27,601
man: Then you're kind of
mixing like load,

1280
00:49:27,601 --> 00:49:28,601
the loading and--

1281
00:49:28,601 --> 00:49:29,601
Russell:
They are mixed.

1282
00:49:29,601 --> 00:49:30,834
There's no way
to unmix them.

1283
00:49:30,834 --> 00:49:32,767
Because of the way
that JavaScript evaluates

1284
00:49:32,767 --> 00:49:34,367
top to bottom,
we either have to--

1285
00:49:34,367 --> 00:49:35,834
and because
it runs on the UI thread,

1286
00:49:35,834 --> 00:49:39,267
we either have to block
the entire client

1287
00:49:39,267 --> 00:49:41,367
while we go fetch resources,
which is what happens

1288
00:49:41,367 --> 00:49:43,234
with the document.write,
that sort of thing--

1289
00:49:43,234 --> 00:49:44,234
man: Yeah, I see
what you're saying.

1290
00:49:44,234 --> 00:49:45,567
Russell:
Or we have to find a way

1291
00:49:45,567 --> 00:49:48,467
to accommodate asynchronous
loading in the syntax,

1292
00:49:48,467 --> 00:49:49,834
and that's what the simple
module proposal does.

1293
00:49:49,834 --> 00:49:50,968
man:
I see what you're saying.

1294
00:49:50,968 --> 00:49:52,234
Russell: Which is
fundamentally different,

1295
00:49:52,234 --> 00:49:53,968
because we can use syntax
to do that in a way

1296
00:49:53,968 --> 00:49:55,400
that common JS can't.

1297
00:49:55,400 --> 00:49:57,767
man: Yeah, I use a system where
I kind of--you use common JS

1298
00:49:57,767 --> 00:50:02,400
on the client, but I don't--
I allow for, like,

1299
00:50:02,400 --> 00:50:03,634
forward references.
Russell: Right.

1300
00:50:03,634 --> 00:50:05,567
man: So like, those things,
they get resolved

1301
00:50:05,567 --> 00:50:06,934
at a later time,

1302
00:50:06,934 --> 00:50:10,067
so you can't kind of use them
completely until later.

1303
00:50:10,067 --> 00:50:11,534
Russell: Yeah, I'm really
hopeful that we can get

1304
00:50:11,534 --> 00:50:13,901
the semantic that Dave Herman
has put forward,

1305
00:50:13,901 --> 00:50:16,300
because it really does give us
the power to not force you

1306
00:50:16,300 --> 00:50:17,734
to think about when your code
is going to run.

1307
00:50:17,734 --> 00:50:20,033
If you say require in one line,
you can use it in the next one,

1308
00:50:20,033 --> 00:50:23,267
and I think that's
a key usability feature

1309
00:50:23,267 --> 00:50:27,834
of a language improvement
in this area.

1310
00:50:27,834 --> 00:50:29,367
man:
Question. On the last slide,

1311
00:50:29,367 --> 00:50:31,033
one of the things you mentioned
was asynchronous programming

1312
00:50:31,033 --> 00:50:32,467
with JavaScript.

1313
00:50:32,467 --> 00:50:36,701
And, you know, like Node JS
is one of the new frameworks.

1314
00:50:36,701 --> 00:50:38,133
I'm wondering if you can talk
a little bit about

1315
00:50:38,133 --> 00:50:41,300
some best practices for
how to handle error conditions

1316
00:50:41,300 --> 00:50:45,334
or exceptions when you're
doing an asynchronous call

1317
00:50:45,334 --> 00:50:47,133
that may not be
in the same call stack

1318
00:50:47,133 --> 00:50:49,901
as when you actually
executed the call.

1319
00:50:49,901 --> 00:50:52,434
Russell:
So this is a hot topic.

1320
00:50:52,434 --> 00:50:56,868
The asynchronous pattern
that seems to have won

1321
00:50:56,868 --> 00:50:59,701
the most mindshare is something
like deferreds or promises.

1322
00:50:59,701 --> 00:51:02,367
Again, the common JS guys
have done great work there.

1323
00:51:02,367 --> 00:51:06,234
And so those systems
tend to have some error

1324
00:51:06,234 --> 00:51:10,300
handling callback
that you can register,

1325
00:51:10,300 --> 00:51:13,601
so that if an error does occur,
you can be notified of it.

1326
00:51:13,601 --> 00:51:16,634
I actually was talking with
the Node JS guys just last week

1327
00:51:16,634 --> 00:51:19,000
in Portland about exactly
how they want to do this,

1328
00:51:19,000 --> 00:51:21,167
because I'm hopeful
that what we can do

1329
00:51:21,167 --> 00:51:25,033
is build on top of built-in
language deferred

1330
00:51:25,033 --> 00:51:28,000
or promise API,
the ability to use the weight

1331
00:51:28,000 --> 00:51:31,167
or async keywords to go help
mark particular methods

1332
00:51:31,167 --> 00:51:32,667
of returning
these deferred objects,

1333
00:51:32,667 --> 00:51:36,601
but error handling does turn
into a primary question then.

1334
00:51:36,601 --> 00:51:39,467
So what they came to,

1335
00:51:39,467 --> 00:51:41,000
and I think
it's a pretty good answer,

1336
00:51:41,000 --> 00:51:43,267
is that you have
a single callback, right?

1337
00:51:43,267 --> 00:51:46,067
And that needs to be
also informed of errors.

1338
00:51:46,067 --> 00:51:48,601
But you can have
an optional second callback,

1339
00:51:48,601 --> 00:51:51,200
which will be told
about error conditions

1340
00:51:51,200 --> 00:51:53,200
if you choose to handle them
independently.

1341
00:51:53,200 --> 00:51:55,467
And I think,
you know, the idea

1342
00:51:55,467 --> 00:51:56,534
that you're not going
to have to deal with errors

1343
00:51:56,534 --> 00:51:58,400
in the primary callback

1344
00:51:58,400 --> 00:51:59,767
is a little bit farfetched,

1345
00:51:59,767 --> 00:52:01,601
and so I think that's maybe
a good trade-off.

1346
00:52:01,601 --> 00:52:04,934
But it is an open topic.

1347
00:52:04,934 --> 00:52:07,133
We probably need
language level support

1348
00:52:07,133 --> 00:52:10,868
for sort of moving
stack traces.

1349
00:52:10,868 --> 00:52:14,434
Like, if I throw in one catch
here and then re-throw

1350
00:52:14,434 --> 00:52:16,400
the exception someplace else,
we need some VM

1351
00:52:16,400 --> 00:52:19,734
or language level support
to help us make that reporting

1352
00:52:19,734 --> 00:52:21,501
cleaner and nicer.

1353
00:52:21,501 --> 00:52:23,834
And I think
that's another important area

1354
00:52:23,834 --> 00:52:27,434
that we might be able to help
tie these things back together,

1355
00:52:27,434 --> 00:52:30,400
once we go async.
man: Okay, great.

1356
00:52:30,400 --> 00:52:33,267
man: Hi, I just wanted to know
if there was any interest

1357
00:52:33,267 --> 00:52:39,234
or effort within Google
to do some more of the more

1358
00:52:39,234 --> 00:52:41,234
server side JavaScript,
stuff like Node JS,

1359
00:52:41,234 --> 00:52:45,367
and maybe any possibility
of ever having that available

1360
00:52:45,367 --> 00:52:46,901
like on App Engine.

1361
00:52:46,901 --> 00:52:48,701
Russell: I can't speak
to future product plans,

1362
00:52:48,701 --> 00:52:50,801
but I can say that the VA team
is working closely

1363
00:52:50,801 --> 00:52:54,534
with the Node team to continue
to make Node faster.

1364
00:52:54,534 --> 00:52:56,167
We care a lot about
their use cases,

1365
00:52:56,167 --> 00:53:00,801
and we want to make sure
that we're supporting them.

1366
00:53:00,801 --> 00:53:04,634
man: So looking at the Traceur
function and the no sugar,

1367
00:53:04,634 --> 00:53:07,467
de-sugaring, in Lisp,
this was done

1368
00:53:07,467 --> 00:53:10,033
because they had
a powerful macro facility,

1369
00:53:10,033 --> 00:53:12,934
so that the developer could
actually introduce new syntax

1370
00:53:12,934 --> 00:53:16,901
into their programs and define
the behaviors in Lisp.

1371
00:53:16,901 --> 00:53:18,434
Is there any thought of
doing something like that

1372
00:53:18,434 --> 00:53:19,734
in JavaScript?

1373
00:53:19,734 --> 00:53:21,434
Russell: We have a hard time
with that in JavaScript,

1374
00:53:21,434 --> 00:53:23,868
because we have both statements
and expressions,

1375
00:53:23,868 --> 00:53:26,400
and we have, you know,

1376
00:53:26,400 --> 00:53:30,033
a lot of complex grammar
that's not movable.

1377
00:53:30,033 --> 00:53:32,334
And as a result,
any macro facility

1378
00:53:32,334 --> 00:53:34,300
is going to quickly
become undecidable.

1379
00:53:34,300 --> 00:53:37,801
And so I think
we're in a place where macros,

1380
00:53:37,801 --> 00:53:40,667
the way I think you want them,
aren't possible

1381
00:53:40,667 --> 00:53:41,968
in JavaScript.

1382
00:53:41,968 --> 00:53:43,634
New syntax, specifically,

1383
00:53:43,634 --> 00:53:48,534
is going to have to continue
to happen through the committee.

1384
00:53:48,534 --> 00:53:50,000
So I think there are places

1385
00:53:50,000 --> 00:53:52,834
where we can carve out
some stuff.

1386
00:53:52,834 --> 00:53:55,100
There's been some good work
in string formatting,

1387
00:53:55,100 --> 00:53:57,334
for instance, to make it
possible to plug in--

1388
00:53:57,334 --> 00:54:01,000
through protocols--some new
behavior into existing syntax,

1389
00:54:01,000 --> 00:54:03,634
and I think that's maybe
the promising way forward.

1390
00:54:03,634 --> 00:54:06,534
man: Yeah.

1391
00:54:06,534 --> 00:54:09,801
man: So did you know
that you can build Firefox

1392
00:54:09,801 --> 00:54:13,234
with support for Python
as a scripting language?

1393
00:54:13,234 --> 00:54:14,667
Russell:
I've heard tell of this,

1394
00:54:14,667 --> 00:54:16,734
but it's been that way
for many years, as I recall.

1395
00:54:16,734 --> 00:54:19,200
man: Yes, debug build
with Firefox comes with it.

1396
00:54:19,200 --> 00:54:21,767
More seriously,
what do you think of GWT

1397
00:54:21,767 --> 00:54:27,734
or more usefully Pyjamas
as actual development platforms

1398
00:54:27,734 --> 00:54:30,767
instead of writing
direct JavaScript,

1399
00:54:30,767 --> 00:54:36,033
and using the richer type system
of Python or Java

1400
00:54:36,033 --> 00:54:38,701
instead of the bare bones one
in JavaScript?

1401
00:54:38,701 --> 00:54:40,067
Russell: Type systems
are really great.

1402
00:54:40,067 --> 00:54:44,033
I think that it's a key
missing feature from JavaScript

1403
00:54:44,033 --> 00:54:45,934
specifically because what
you wind up writing, again,

1404
00:54:45,934 --> 00:54:47,501
is a lot of boilerplate
to help you test

1405
00:54:47,501 --> 00:54:50,467
whether or not you were actually
tall enough to ride the ride.

1406
00:54:50,467 --> 00:54:52,100
You actually have to
sort of go cart around

1407
00:54:52,100 --> 00:54:53,467
a lot of this
testing magic.

1408
00:54:53,467 --> 00:54:55,000
I'm not hopeful
for type systems.

1409
00:54:55,000 --> 00:54:56,367
This is my personal opinion.

1410
00:54:56,367 --> 00:54:59,234
I'm not hopeful for type systems
as a be all and end all

1411
00:54:59,234 --> 00:55:02,334
sort of verification system
for your program.

1412
00:55:02,334 --> 00:55:03,834
The web is too dynamic.

1413
00:55:03,834 --> 00:55:05,734
Client-side programs
are too dynamic for that.

1414
00:55:05,734 --> 00:55:07,434
We're dealing with
user behavior a lot.

1415
00:55:07,434 --> 00:55:10,234
Instead, what I'd like for us
to get to is a place

1416
00:55:10,234 --> 00:55:14,334
where the syntactic warts
of JavaScript sort of get

1417
00:55:14,334 --> 00:55:15,567
eased over one way
or the other.

1418
00:55:15,567 --> 00:55:16,701
Things like CoffeeScript

1419
00:55:16,701 --> 00:55:18,133
are pointing
in a good direction here,

1420
00:55:18,133 --> 00:55:22,734
where you can sort of come
back up with some new syntax,

1421
00:55:22,734 --> 00:55:24,467
and hopefully that'll
eventually work its way

1422
00:55:24,467 --> 00:55:25,667
into the language.

1423
00:55:25,667 --> 00:55:27,167
But things like
the module that are--

1424
00:55:27,167 --> 00:55:29,467
they're going to have
an analogous API, again,

1425
00:55:29,467 --> 00:55:32,634
building a protocol that you can
plug into with your own code,

1426
00:55:32,634 --> 00:55:35,067
and that API will allow you
to do things like run

1427
00:55:35,067 --> 00:55:37,934
the CoffeeScript compiler
or the Pyjamas compiler

1428
00:55:37,934 --> 00:55:40,267
across loaded modules
before they're run,

1429
00:55:40,267 --> 00:55:42,567
which means that you can
sort of have runtime support

1430
00:55:42,567 --> 00:55:45,033
for those built-in.

1431
00:55:45,033 --> 00:55:46,667
I think the--you asked a
question

1432
00:55:46,667 --> 00:55:47,834
of what do I think about

1433
00:55:47,834 --> 00:55:51,200
those tools as a way to do
production work.

1434
00:55:51,200 --> 00:55:54,334
If your language veers far
enough from the core semantics

1435
00:55:54,334 --> 00:55:57,334
of JavaScript, you wind up
not just with the ability

1436
00:55:57,334 --> 00:55:59,901
to do all sorts of tooling
and stuff that comes along

1437
00:55:59,901 --> 00:56:02,667
with your source language,
but you also wind up with

1438
00:56:02,667 --> 00:56:06,067
the need for the runtime
to do dead code edition.

1439
00:56:06,067 --> 00:56:11,234
You need to go and sort of
not just do a one-for-one

1440
00:56:11,234 --> 00:56:13,167
translation down to the
analogous statements

1441
00:56:13,167 --> 00:56:14,434
in the other language,
but you have to make sure

1442
00:56:14,434 --> 00:56:16,234
that the semantics are right.

1443
00:56:16,234 --> 00:56:17,667
You have to make sure
that you have code in there

1444
00:56:17,667 --> 00:56:20,367
to support any differences,
any impotence mismatches

1445
00:56:20,367 --> 00:56:21,434
between the two languages.

1446
00:56:21,434 --> 00:56:23,234
And so I'm much more hopeful

1447
00:56:23,234 --> 00:56:27,501
about things like CoffeeScript
and the Traceur editions

1448
00:56:27,501 --> 00:56:30,033
because they don't add
a lot of extra stuff,

1449
00:56:30,033 --> 00:56:31,467
because the languages
aren't that far away

1450
00:56:31,467 --> 00:56:33,033
in terms of core semantic.

1451
00:56:33,033 --> 00:56:35,534
man: All right,
thank you.

1452
00:56:35,534 --> 00:56:38,968
man: Hi, one kind of application
domain that could benefit

1453
00:56:38,968 --> 00:56:41,634
from scripting
that's not really--

1454
00:56:41,634 --> 00:56:45,067
doesn't have a solution today
is a native Android app.

1455
00:56:45,067 --> 00:56:46,334
So I wonder if there are any--

1456
00:56:46,334 --> 00:56:47,968
we've dabbled with,
you know, plug-in Rhino

1457
00:56:47,968 --> 00:56:49,334
and things like that.

1458
00:56:49,334 --> 00:56:52,434
I wonder if there's any activity
in that area right now.

1459
00:56:52,434 --> 00:56:54,100
Russell: I think you'd have
to ask the Android team.

1460
00:56:54,100 --> 00:56:55,968
I'm sorry, I'm not up-to-date
on what they're doing there.

1461
00:56:55,968 --> 00:56:58,567
man: Okay.
Russell: Thanks.

1462
00:56:58,567 --> 00:56:59,834
man:
I had another question.

1463
00:56:59,834 --> 00:57:04,400
So in my Python programs,
I like to use sometimes

1464
00:57:04,400 --> 00:57:07,167
multiple inheritance,
and I have complex--

1465
00:57:07,167 --> 00:57:08,968
Russell: C3MRO,
right, yeah.

1466
00:57:08,968 --> 00:57:10,567
man: Dependency graphs
and so on, yeah.

1467
00:57:10,567 --> 00:57:14,534
So and they have a method
resolution order in Python

1468
00:57:14,534 --> 00:57:17,434
that allows you to call
the super classes methods,

1469
00:57:17,434 --> 00:57:19,601
you know, exactly once
in the right order, and--

1470
00:57:19,601 --> 00:57:22,100
or at least
a well-defined order.

1471
00:57:22,100 --> 00:57:26,334
Is anything going on in Harmony
for allowing for something

1472
00:57:26,334 --> 00:57:30,300
like an MRO type
call graph resolution?

1473
00:57:30,300 --> 00:57:33,000
Russell: I don't think
we're going to break the idea

1474
00:57:33,000 --> 00:57:35,234
of a single prototype.
man: Right.

1475
00:57:35,234 --> 00:57:37,033
Russell: So the analogous
thing here would be

1476
00:57:37,033 --> 00:57:39,501
multi prototype languages.

1477
00:57:39,501 --> 00:57:40,801
I'm hopeful
that what we'll get done

1478
00:57:40,801 --> 00:57:42,734
is something like
Tom Van Cutsem's

1479
00:57:42,734 --> 00:57:44,634
Traits semantic,

1480
00:57:44,634 --> 00:57:46,767
where we can add
a syntax for defining

1481
00:57:46,767 --> 00:57:49,100
a set of things
that you would sort of--

1482
00:57:49,100 --> 00:57:51,100
like we did with mix-ins,
add to the class,

1483
00:57:51,100 --> 00:57:54,968
and then do conflict resolution
with syntax.

1484
00:57:54,968 --> 00:57:56,567
Because what you're trying to
say in a lot of these cases

1485
00:57:56,567 --> 00:57:58,901
isn't, I'd like for you
to sort of decide for me

1486
00:57:58,901 --> 00:58:00,567
which of these things
I am at runtime.

1487
00:58:00,567 --> 00:58:02,300
It's not really a--
an "is a" relationship.

1488
00:58:02,300 --> 00:58:03,434
It's sort of a "has a"
relationship,

1489
00:58:03,434 --> 00:58:04,467
what you're saying.

1490
00:58:04,467 --> 00:58:05,734
I'd like this new behavior

1491
00:58:05,734 --> 00:58:07,834
to also be available
to my object.

1492
00:58:07,834 --> 00:58:09,200
And if you can factor
those things out,

1493
00:58:09,200 --> 00:58:11,267
it can help with composability
and then eventually

1494
00:58:11,267 --> 00:58:12,667
with type testing.

1495
00:58:12,667 --> 00:58:15,901
And I think Traits are where,
at least I'm hopeful,

1496
00:58:15,901 --> 00:58:18,200
that we'll go
to make a lot of that easier.

1497
00:58:18,200 --> 00:58:20,701
man: Yeah, I use a wrapper
where like I kind of

1498
00:58:20,701 --> 00:58:23,834
build a copy of
a well-defined prototype chain,

1499
00:58:23,834 --> 00:58:26,534
specifically for this
particular set of mix-ins,

1500
00:58:26,534 --> 00:58:28,567
and so like
you can kind of emulate,

1501
00:58:28,567 --> 00:58:29,934
you know,
by specifically listing

1502
00:58:29,934 --> 00:58:33,601
the order in which you want
things to be resolved

1503
00:58:33,601 --> 00:58:39,234
and kind of get the behavior
for that in JavaScript.

1504
00:58:39,234 --> 00:58:42,067
man: Mainly curious, do you know
whether Traceur shares

1505
00:58:42,067 --> 00:58:44,734
common lineage with
the cross interpreter

1506
00:58:44,734 --> 00:58:47,234
in Google Widget Toolkit?

1507
00:58:47,234 --> 00:58:48,834
Russell: The Traceur code base
is brand-new.

1508
00:58:48,834 --> 00:58:51,000
It's a, you know,

1509
00:58:51,000 --> 00:58:55,968
a new client-side compiler
that we wrote,

1510
00:58:55,968 --> 00:58:59,868
hand-built parser,
that sort of thing.

1511
00:58:59,868 --> 00:59:03,267
man: Thank you.
Russell: Yeah.

1512
00:59:03,267 --> 00:59:06,801
All right, one more.
All right.

1513
00:59:06,801 --> 00:59:08,901
man:
So I'm a C# developer,

1514
00:59:08,901 --> 00:59:13,200
and I've stayed away from
JavaScript for a very long time,

1515
00:59:13,200 --> 00:59:15,834
mostly because I didn't--
I knew the what,

1516
00:59:15,834 --> 00:59:18,901
but I didn't know the why,
and that's been really good

1517
00:59:18,901 --> 00:59:21,000
in today's session.

1518
00:59:21,000 --> 00:59:24,634
I'd like to continue
exploring.

1519
00:59:24,634 --> 00:59:27,934
Can you recommend any reading--
specific reading material?

1520
00:59:27,934 --> 00:59:29,868
Because, of course, I could
always do a Google search.

1521
00:59:29,868 --> 00:59:31,234
Russell:
Yeah.

1522
00:59:31,234 --> 00:59:33,501
man: But that would continue
along the path of not just

1523
00:59:33,501 --> 00:59:35,534
the what but the why also.

1524
00:59:35,534 --> 00:59:36,868
Russell:
The latest version

1525
00:59:36,868 --> 00:59:39,067
of "JavaScript, the Definitive
Guide" is pretty good.

1526
00:59:39,067 --> 00:59:42,067
I recommend
"Eloquent JavaScript."

1527
00:59:42,067 --> 00:59:44,634
It does a great job of sort of
introducing these core concepts

1528
00:59:44,634 --> 00:59:48,567
and getting you through not just
sort of what you can do.

1529
00:59:48,567 --> 00:59:50,801
I didn't talk a lot
about how DOM interacts

1530
00:59:50,801 --> 00:59:53,601
with all of these things.

1531
00:59:53,601 --> 00:59:57,100
My recommendation
is that you find someplace

1532
00:59:57,100 --> 00:59:59,868
to start playing with a language
that's not a web browser.

1533
00:59:59,868 --> 01:00:01,234
I mean, web browsers
are really handy.

1534
01:00:01,234 --> 01:00:03,968
You can start to sort of like
make this all happen.

1535
01:00:03,968 --> 01:00:05,767
But if you just sort of play
with the command line

1536
01:00:05,767 --> 01:00:09,400
in the browser or start to work
with a local copy of V8

1537
01:00:09,400 --> 01:00:11,334
or Node JS,
you can really get a feel

1538
01:00:11,334 --> 01:00:13,501
for what's in the language
and what's not in the browser.

1539
01:00:13,501 --> 01:00:15,400
JavaScript takes--in almost
every environment,

1540
01:00:15,400 --> 01:00:18,234
it takes a lot of its identity
from the standard library

1541
01:00:18,234 --> 01:00:20,567
that sort of
it's been wedded to.

1542
01:00:20,567 --> 01:00:21,901
And in most cases,

1543
01:00:21,901 --> 01:00:22,934
because it has
a very small standard library,

1544
01:00:22,934 --> 01:00:24,400
all of that is in
the environment.

1545
01:00:24,400 --> 01:00:28,300
And so the more you can sort of
remove those potential hurdles

1546
01:00:28,300 --> 01:00:29,934
or sort of impotence mismatches

1547
01:00:29,934 --> 01:00:31,567
with what's just
in the language,

1548
01:00:31,567 --> 01:00:34,701
I think the faster
it'll help you learn it.

1549
01:00:34,701 --> 01:00:35,934
Yeah.

1550
01:00:35,934 --> 01:00:38,200
man: Actually,
in a similar situation

1551
01:00:38,200 --> 01:00:40,601
as the previous question,
which is I stayed away

1552
01:00:40,601 --> 01:00:43,467
from JavaScript
for a number of reasons.

1553
01:00:43,467 --> 01:00:44,968
Probably
one of the biggest ones

1554
01:00:44,968 --> 01:00:47,367
was the lack of debug support.
Russell: Mm-hmm.

1555
01:00:47,367 --> 01:00:52,033
man: And the fact that you have
unexpected surprises,

1556
01:00:52,033 --> 01:00:56,267
like being able to overload
the array constructor,

1557
01:00:56,267 --> 01:00:59,968
that lend itself to,
you know, security holes,

1558
01:00:59,968 --> 01:01:01,801
whereas someone coming
from another language

1559
01:01:01,801 --> 01:01:04,000
isn't expecting that,
and they don't even consider

1560
01:01:04,000 --> 01:01:06,434
that as a possibility
when you're looking at code.

1561
01:01:06,434 --> 01:01:09,934
So specifically, is there
anything that's talked about

1562
01:01:09,934 --> 01:01:13,200
being added, where--
when you talk about modules,

1563
01:01:13,200 --> 01:01:16,000
that the module can set up
certainly like preconditions?

1564
01:01:16,000 --> 01:01:19,634
I'm expecting these sets
of things to be true,

1565
01:01:19,634 --> 01:01:22,234
like the array constructor
cannot be overloaded,

1566
01:01:22,234 --> 01:01:26,934
or anything else
where you can say, flag,

1567
01:01:26,934 --> 01:01:29,701
this is going to be a problem
or not going to run right.

1568
01:01:29,701 --> 01:01:31,100
Russell: So one of the big
things that's happening

1569
01:01:31,100 --> 01:01:33,834
with the module syntax
is that we're removing

1570
01:01:33,834 --> 01:01:36,300
the ability to share globals,
so you won't have

1571
01:01:36,300 --> 01:01:39,300
a single shared global,
which is going to be big,

1572
01:01:39,300 --> 01:01:41,767
to prevent people from sort of
blowing your own legs off.

1573
01:01:41,767 --> 01:01:44,133
The other thing
is that ECMAScript 5,

1574
01:01:44,133 --> 01:01:47,968
the version that was just
recently ratified,

1575
01:01:47,968 --> 01:01:50,200
implements what we call
a strict mode.

1576
01:01:50,200 --> 01:01:52,467
And strict mode turns off
some of the worst foot guns.

1577
01:01:52,467 --> 01:01:59,234
It helps keep you out of trouble
by giving you more and more

1578
01:01:59,234 --> 01:02:02,367
pre-checking for things
like uninitialized variables,

1579
01:02:02,367 --> 01:02:04,634
that sort of thing,
where it keeps you from

1580
01:02:04,634 --> 01:02:07,968
sort of tripping over yourself
in some pretty common areas.

1581
01:02:07,968 --> 01:02:10,200
It's not perfect,
but it's certainly a start.

1582
01:02:10,200 --> 01:02:11,801
So use strict inside
of all of your functions,

1583
01:02:11,801 --> 01:02:13,200
and you should be good to go.

1584
01:02:13,200 --> 01:02:17,300
man: And what about the idea
of like official debug support?

1585
01:02:17,300 --> 01:02:20,667
Russell: So that's
an engine-by-engine thing.

1586
01:02:20,667 --> 01:02:26,033
The topic of common stack traces
has been raised

1587
01:02:26,033 --> 01:02:28,000
a bunch of times, and it's
going to be very difficult,

1588
01:02:28,000 --> 01:02:30,067
because that constrains
our ability to optimize.

1589
01:02:30,067 --> 01:02:33,400
So things like
alighting away dead code,

1590
01:02:33,400 --> 01:02:35,567
those are the sorts of things
that are going to be hard to do

1591
01:02:35,567 --> 01:02:37,267
if we have to agree
on a stack trace format.

1592
01:02:37,267 --> 01:02:39,367
So what we do have is
really good support,

1593
01:02:39,367 --> 01:02:43,300
say, in the Chrome web inspector
for setting breakpoints,

1594
01:02:43,300 --> 01:02:46,000
future breakpoints,
getting call stacks,

1595
01:02:46,000 --> 01:02:50,033
and soon the ability to
sort of wire up line numbers

1596
01:02:50,033 --> 01:02:51,167
to source code.

1597
01:02:51,167 --> 01:02:53,734
So yeah, debugability
is a hot topic.

1598
01:02:53,734 --> 01:02:55,701
It tends to happen
through the browser

1599
01:02:55,701 --> 01:02:57,634
and not through
the language runtime.

1600
01:02:57,634 --> 01:03:01,467
man:
[indistinct]

1601
01:03:01,467 --> 01:03:03,200
Russell: So the question was
will a closure compiler

1602
01:03:03,200 --> 01:03:05,601
help with the debugability.
If the closure compiler has--

1603
01:03:05,601 --> 01:03:08,901
man:
[indistinct]

1604
01:03:08,901 --> 01:03:11,434
Russell: Oh, will the closure
compiler help beginners?

1605
01:03:11,434 --> 01:03:15,767
No. It's designed
to help folks who know

1606
01:03:15,767 --> 01:03:17,767
that they have a problem
avoid having problems.

1607
01:03:17,767 --> 01:03:19,133
Okay, cool.

1608
01:03:19,133 --> 01:03:22,100
Thanks again for coming,
and I'm looking forward to it.

